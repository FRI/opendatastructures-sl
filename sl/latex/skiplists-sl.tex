\translatedby{Jan Štrekelj}{sl}
\chapter{Preskočni seznami}

\chaplabel{skiplists}

V tem poglavju bomo govorili o lepi podatkovni strukturi: preskočnem seznamu, ki ima veliko možnosti uporabe. Z uporabo preskočnega seznama lahko implementiramo #List#, ki ima $O(\log n)$ časovno implementacijo #get(i)#, #set(i,x)#,
#add(i,x)# in #remove(i)#. Prav tako lahko implementiramo #SSet#, v katerem vse operacije potrebujejo $O(\log #n#)$ pričakovanega časa.
%Nazadnje je preskočni seznam lahko uporabljen za implementacijo #Rope#, kjer se vse operacije izvedejo v
% $O(\log #n#)$.

Učinkovitost preskočnega seznama je povezana z njegovo naključnostjo. Pri dodajanju novega elementa seznamu, se njegova višina določi z naključnimi meti kovanca. Učinek preskočnega seznama je odvisen od pričakovanih izvajanj in dolžine poti. To pričakovanje pa je povezano z uporabo metode meta kovanca. V implementaciji je metoda meta kovanca simulirana z uporabo namenskega številskega generatorja.


\section{Osnovna struktura}

\index{preskočni seznam}%

Konceptualno je preskočni seznam zaporedje enojno povezanih seznamov $L_0,\ldots,L_h$.Vsak seznam $L_r$ vsebuje podmnožico elementov v $L_{r-1}$. Začnimo z vhodnim seznamom $L_0$, ki vsebuje #n# elementov in naredimo sezname $L_1$ iz $L_0$, $L_2$ iz $L_1$, in tako naprej.
Elemente v $L_r$ pridobimo z metanjem kovanca za vsak element, #x#, v $L_{r-1}$ in #x# v $L_r$, če met kovanca "pokaže" glavo. Postopek ponavljamo, dokler ne naredimo praznega seznama $L_r$. Primer preskočnega seznama je prikazan na sliki \figref{skiplist}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist}
  \end{center}
  \caption{Preskočni seznam s sedmimi elementi.}
  \figlabel{skiplist}
\end{figure}

Za element #x#, v preskočnem seznamu imenujemo \emph{višino}
\index{height!of a skiplist}%
 #x#-a največja vrednost $r$, kjer se #x# pojavi v $L_r$.  Tako imajo na primer elementi, ki se pojavijo samo v $L_0$, višino $0$. Če pomislimo, ugotovimo, da je višina #x# ustreza naslednjemu eksperimentu:  Mečimo kovanec tako dolgo, dokler ne bo pokazal cifre. Kolikokrat je pokazal glavo?Odgovor je pričakovana višina vozlišča, ki je, nepresenetljivo, enaka 1. (Pričakovali smo, da bomo kovanec vrgli dvakrat, da dobimo cifro, vendar nismo šteli zadnjega meta). \emph{Višina} preskočnega seznama je višina njegovega najvišjega vozlišča.

Na začetku vsakega seznama je posebno vozlišče, imanovano \emph{stražar} \index{sentinel node}%, ki predstavlja statista za seznam. Glavna lastnost preskočnega seznama je, da obstaja kratka pot, imanovana \emph{pot iskanja}, 
\index{search path!in a skiplist}%
od stražarja v $L_h$ do vsakega vozlišča v $L_0$.  Narediti pot iskanja za posamezno vozlišče #u#je preprosto (glej \figref{skiplist-searchpath})
: Začnemo v zgornjem levem kotu preskočnega seznama (stražar je v $L_h$) in se premikamo desno toliko časa, dokler ne gremo preko vozlišča #u#, nato pa se premaknemo korak nižje v spodnji seznam.

Natančneje, za izdelati pot iskanja za vozlišče #u# v $L_0$, začnemo pri stražarju #w# v $L_h$. Nato izvedemo #w.next#. Če #w.next# vsebuje element, ki se pojavi pred #u# v $L_0$, nastavimo $#w#=#w.next#$, sicer se premaknemo navzdol in nadaljujemo iskanje pojavitve #w# v seznamu $L_{h-1}$.  Postopek ponavljamo dokler na dosežemo predhodnika od #u# v $L_0$. 
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-searchpath}
  \end{center}
  \caption{The search path for the node containing $4$ in a skiplist.}
  \figlabel{skiplist-searchpath}
\end{figure}

Rešitev, ki si jo bomo podrobneje pogledali v \secref{skiplist-analysis},
nam pokaže, da je pot iskanja dokaj kratka:

\begin{lem}\lemlabel{skiplist-searchpath}
Pričakovana dolžina poti iskanja  za vsako vozlišče #u# v $L_0$ je največ $2\log #n# + O(1) = O(\log #n#)$.
\end{lem}

Prostorsko učinkovit način za implementacijo preskočnega seznama je ta, da definiramo #Vozlisce#,
#u#, ki je sestavljeno iz podatka #x# in polja kazalcev #next#, kjer #u.next[i]# kaže na naslednika #u#-ja v seznamu $L_{#i#}$.  Na ta način je podatek #x# v vozlišču \javaonly{referenciran}\cpponly{stored} samo enkrat, čeprav se #x# pojavlja v različnih seznamih.

\javaimport{ods/SkiplistSSet.Node<T>}
\cppimport{ods/SkiplistSSet.Node}

V naslednjih dveh podpoglavjih tega poglavja bomo govorili o dveh različnih uporabah preskočnih seznamov. Pri obeh je v $L_0$ shranjena glavna struktura (seznam elementov ali sortirana množica elementov). Glavna razlika med tema dvema strukturama je v načinu premikanja po poti iskanja; podrobneje povedano, razlikujeta se v odločitvi, ali naj se pot iskanja nadaljuje, nižje, v $L_{r-1}$, ali naj gre ta desno v $L_r$.

\section{#SkiplistSSet#: Učinkovit #SSet#}
\seclabel{skiplistset}

\index{SkiplistSSet@#SkiplistSSet#}%
#SkiplistSSet# uporablja preskočni seznam za implementacijo #SSet# vmesnika. Ko ga uporabljamo na ta način, so v seznamu $L_0$ shranjeni elementi #SSet#-a v urejenem vrstnem redu. Metoda #find(x)# deluje tako, da sledi poti iskanja za najmanjšo vrednostjo #y#, kjer je $#y#\ge#x#$:

\codeimport{ods/SkiplistSSet.find(x).findPredNode(x)}

Sledenje poti iskanja za #y# je preprosto: ko se nahajamo v določenem vozlišču #u# v $L_{#r#}$, pogledamo desno v #u.next[r].x#. Če je $#x#>#u.next[r].x#$, se premaknemo za eno mesto v desno v $L_{#r#}$; sicer se premaknemo navzdol v $L_{#r#-1}$. Vsak korak (desno ali navzdol) v takem iskanju potrebuje konstanten čas; potemtakem, po \lemref{skiplist-searchpath}, je pričakovani čas izvajanja #find(x)# enak $O(\log #n#)$.

Preden lahko dodamo element v #SkipListSSet#, potrebujemo metodo, ki bo simulirala met kovanca za določitev višine #k# novega vozlišča. To naredimo tako, da si izberemo poljubno število #z# in štejemo število zaporednih enic v binarnem zapisu števila  #z#:\footnote{Ta metoda ne popolnoma ponazarja eksperimenta metanja kovanca, saj bo vrednost #k# vedno manjša od števila bitov v #int#. Kakorkoli, to bo imelo zanemarljiv vpliv dokler ne bo število elementov v strukturi veliko večje kot $2^{32}=4294967296$.}

\codeimport{ods/SkiplistSSet.pickHeight()}

Za implementacijo metode #add(x)# v #SkiplistSSet# smo najprej poiskali #x# in ga nato dodali v več seznamov $L_0$,\ldots,$L_{#k#}$, kjer je #k# izbran  s pomočjo #pickHeight()# metode. Najlažji način te izvedbe je s pomočjo polja, #sklad#, ki hrani sled vozlišč, kjer se je pot iskanja spustila iz seznama $L_{#r#}$ v $L_{#r#-1}$. Natančneje, #sklad[r]# je vozlišče v $L_{#r#}$ kjer se je pot iskanja nadaljevala  en nivo nižje, v seznamu $L_{#r#-1}$. Vozlišča, ki smo jih prilagodili za vstavljanje #x#-a so točno vozlišča $#stack[0]#,\ldots,#stack[k]#$. Koda v nadaljevanju prikazuje implementacijo algoritma #add(x)#:
\label{pg:skiplist-add}
\codeimport{ods/SkiplistSSet.add(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-add}
  \end{center}
  \caption[Adding to a skiplist]{Dodajanje vozlišča $3.5$ v preskočni seznam.  Vozlišča shranjena v #sklad#
  so označena.}
  \figlabel{skiplist-add}
\end{figure}

Brisanje elementa #x# je podobno vstavljanju, le da pri tej metodi ni potrebe po #skladu# za hranjenje poti iskanja. Brisanje je lahko opravljeno s sledenjem poti iskanja. Ko iščemo #x#, vedno ko se premaknemo korak navzdol iz vozlišča #u#, preverimo, če je $#u.next.x#=#x#$ in če je, odstranimo #u# iz seznama:
\codeimport{ods/SkiplistSSet.remove(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-remove}
  \end{center}
  \caption{Brisanje vozlišča $3$ iz preskočnega seznama.}
  \figlabel{skiplist-remove}
\end{figure}

\subsection{Povzetek}

Naslednji teorem povzema uporabnost preskočnega seznama, ko ga uporabljamo za implementacijo sortiranih množic:

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet# je uporabljen za implementacijo #SSet# vmesnika. #SkiplistSSet# opravi  operacije #add(x)# (dodaj), #remove(x)# (odstrani) in #find(x)# (najdi) v $O(\log #n#)$ pričakovanega časa za operacijo.
\end{thm}

\translatedby{Tadej Dragutinovič}{sl}
\subsection{Summary}

Sledeči teorem povzema uporabnost preskočnega seznama, ko ga uporabljamo pri implementaciji urejenih sklopov:

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet# implementira #SSet# vmesnik. A #SkiplistSSet# vsebuje operacije #add(x)#, #remove(x)#, and #find(x)# in $O(\log #n#)$
pričakovani čas za izvedbo operacije.
\end{thm}

\section{#SkiplistList#: Učinkovit naključni dostop #List#}
\seclabel{skiplistlist}

\index{SkiplistList@#SkiplistList#}%
A #SkiplistList# implementira #List# vmesnik s pomočjo(uporabo) preskočnega seznama.
V #SkiplistList#, $L_0$ vsebuje elemente seznama po vrstnem redu pojavljanja  elementov.
Kot pri
#SkiplistSSet#, elemente lahko dodajamo, brišemo ali do njih dostopamo v $O(\log
#n#)$ časa.

Za doseganje tega, potrebujemo možnost iskanja poti 
#i#-tega elementa v $L_0$.  Najlažji način je definirati notacijo
 the \emph{length} od roba nekega seznama, $L_{#r#}$.
Vsak rob seznama definiramo $L_{0}$ kot 1.  Dolžina roba, #e#,
v $L_{#r#}$, $#r#>0$, je definirana kot vsota dolžin robov pod njim #e#
v $L_{#r#-1}$. Dolžina #e# je ekvivalentna
številu robov v $L_0$ pod #e#-jem.  Poglej \figref{skiplist-lengths} za primer preskočnega seznama z dolžino njegovih robov. Ker so robovi preskočnega seznama shranjeni v poljih, lahko tako hranimo tudi njegove dolžine:

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-lengths}
  \end{center}
  \caption{The lengths of the edges in a skiplist.}
  \figlabel{skiplist-lengths}
\end{figure}

\codeimport{ods/SkiplistList.Node}

Povzetek te opredelitve dolžin je da smo trenutno na vozlišču, ki se nahaja na poziciji
#j# v $L_0$ in sledimo robu dolžine $\ell$, nato se premaknemo na vozlišče čigar pozicija v $L_0$,
je $#j#+\ell$.  Po takem postopku, medtem ko iščemo iskalno pot lahko ohranjamo
vrednost pozicije, #j#, trenutnega vozlišča v $L_0$.  Medtem ko na vozlišču, #u#, v $L_{#r#}$, gremo desno če #j# plus dolžina  roba
#u.next[r]# je manj kakor #i#. V nasprotnem primeru, gremo navzdol v  $L_{#r#-1}$.

\codeimport{ods/SkiplistList.findPred(i)}
\codeimport{ods/SkiplistList.get(i).set(i,x)}

Ker je najtežji del operacij #get(i)# in #set(i,x)# 
iskanje #i#-tega vozlišča v $L_0$, se operacije izvedejo v 
$O(\log #n#)$ časa.

Dodajanje elementa v  #SkiplistList# na pozicijo, #i#, je enostavno.  
Za razliko dodajanje v  #SkiplistSSet#, smo prepričani da bo vozlišče
Dejansko dodano, zato lahko hkrati dodajamo in iščemo lokacijo za  novo  
vozlišče. Najprej izberemo višino, #k#,
novo dodanega vozlišča  #w#, nato sledimo iskalni poti #i#.
Vsakič ko se iskalna pot premakne navzdol od $L_{#r#}$ z $#r#\le #k#$, uporabimo
 spoj #w# v $L_{#r#}$.  Dodatno moremo biti pozorni da se dolžina robov
pravilno osvežuje.  Poglej \figref{skiplist-addix}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-addix}
  \end{center}
  \caption[Adding to a SkiplistList]{Adding an element to a #SkiplistList#.}
  \figlabel{skiplist-addix}
\end{figure}

Pozorni moremo biti, da vsakič ko se iskalna pot premakne za eno vozščišče navzdol, #u#, v $L_{#r#}$,
se dolžina roba #u.next[r]# poveča za ena, ker dodajamo element pod rob na poziciji #i#.  
Spojimo vozlišče #w# med vozlišča,
#u# in #z#, deluje kakor prikazano v  \figref{skiplist-lengths-splice}.  Medtem
Ko sledimo iskalni poti, tudi shranjujemo pozicijo 
#j#, od #u# v $L_0$.  Zato, vemo da je dolžina roba od 
#u# do #w#  velikosti  $#i#-#j#$.  Sklepamo lahko da je razdalja roba 
od #w#  do #z# iz dolžine, $\ell$, od roba  #u# do #z#.
Potemtakem, lahko spojimo v #w# in osvežimo dolžine od robov v konstantnem času. 

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/skiplist-lengths-splice}
  \end{center}
  \caption[Adding to a SkiplistList]{Osveževanje dolžin robov, med spojem vozlišča
   #w# v preskočni seznam.}
  \figlabel{skiplist-lengths-splice}
\end{figure}

Postopek izgleda veliko bolj zapleten, kot v resnici je. Koda je pravzaprav zelo enostavna:

\codeimport{ods/SkiplistList.add(i,x)}
\codeimport{ods/SkiplistList.add(i,w)}


Do sedaj bi vam morala biti implementacija #remove(i)# operacije v #SkiplistList# jasna.  Iščemo iskalno pot vozlišča na poziciji #i#.  Vsakič ko se iskalna pot zmanjša za ena od vozlišča #u#, na ravni #r# zmanjšamo radaljo od roba, tako da pustimo #u# na tistem nivoju.  Pregledovati moramo tudi, da je #u.next[r]# element ranga #i# in v kolikor to drži, ga premaknemo iz seznama na tisti nivo.   Primer si lahko ogledate tukaj \figref{skiplist-removei}.
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-removei}
  \end{center}
  \caption[Removing an element from a SkiplistList]{Odstranjevanje elementa iz #SkiplistList#.}
  \figlabel{skiplist-removei}
\end{figure}
\codeimport{ods/SkiplistList.remove(i)}

\subsection{Summary}

Naslednji teorem povzema učinkovitost podatkovne strukture #SkiplistList#:

\begin{thm}\thmlabel{skiplistlist}
  #SkiplistList# implementira  #List# -ov vmesnik.   #SkiplistList#
  podpira operacije #get(i)#, #set(i,x)#, #add(i,x)#, ter
  #remove(i)# v $O(\log #n#)$ pričakovanem času na operacijo.
\end{thm}

%\section{Skiplists as Ropes}
%TODO: A section on ropes

\section{Analiza preskočnega seznama}
\seclabel{skiplist-analiza}

V sledečem delu bomo analizirali pričakovano višino, velikost ter dolžino
iskalne poti v  preskočnem seznamu.  Za razumevanje tega podpoglavja, je potrebno osnovno znanje iz verjetnosti. Nekateri dokazi  so osnovani na metu kovanca.


\begin{lem}\lemlabel{met kovanca}
  \index{coin toss}%
  Naj bo  $T$ število metov pravičnega kovanca, dokler prvič ne pade glava. Takrat $\E[T]=2$.
\end{lem}

\begin{proof}
  Recimo da nehamo metati kovanec kadar prvič pade z glava.
 Definirajmo indikacijsko spremenljivko
  \[ I_{i} = \left\{\begin{array}{ll}
     0 & \mbox{če je kovanec vržen $i$ kar} \\
     1 & \mbox{če je kovanec vržen $i$ ali več krat}
     \end{array}\right.
  \]
  Upoštevajte da  $I_i=1$ če in samo če prvih $i-1$ metov kovanca pade cifra,
  torej $\E[I_i]=\Pr\{I_i=1\}=1/2^{i-1}$.  Opazimo da  $T$, vsi meti kovanca, 
  lahko zapišemo kot $T=\sum_{i=1}^{\infty} I_i$.
  Sledi,
  \begin{align*}
    \E[T] & =  \E\left[\sum_{i=1}^\infty I_i\right] \\
     & =  \sum_{i=1}^\infty \E\left[I_i\right] \\
     & =  \sum_{i=1}^\infty 1/2^{i-1} \\
     & =  1 + 1/2 + 1/4 + 1/8 + \cdots \\
     & =  2 \enspace .   \qedhere
  \end{align*}
\end{proof}

Naslednji hipotezi nam pokažeta da ima preskočni seznam linearno velikost:

\begin{lem}\lemlabel{skiplist-size1}
  Pričakovano število vozlišč v preskočnem seznamu ki vsebuje $#n#$ elementov,
če ne upoštevamo pojavljanj stražarja,  je $2#n#$.
\end{lem}

\begin{proof}
 Verjetnost, da je  kateri koli element, #x#, vsebovan v seznamu
  $L_{#r#}$ je $1/2^{#r#}$, torej je pričakovano število vozlišč v $L_{#r#}$
  $#n#/2^{#r#}$.\footnote{Poglej \secref{randomization} za obrazložietv kako pridemo do rezultata z uporabo indikatorja spremenljivk in linearnosti pričakovanja.}
  Sledi, da je skupno število pričakovanih vozlišč v seznamu
  \[ \sum_{#r#=0}^\infty #n#/2^{#r#} = #n#(1+1/2+1/4+1/8+\cdots) = 2#n# \enspace . \qedhere \]
\end{proof}

\begin{lem}\lemlabel{skiplist-height}
  Pričakovana višina preskočnega seznama, ki vsebuje #n# elementov je največ
  $\log #n# + 2$.
\end{lem}

\begin{proof}
  Za vsak $#r#\in\{1,2,3,\ldots,\infty\}$,
  Definiramo indikator naključnih  spremenljivk
  \[ I_{#r#} = \left\{\begin{array}{ll}
     0 & \mbox{if $L_{#r#}$ je prazen} \\
     1 & \mbox{if $L_{#r#}$ ni prazen}
     \end{array}\right.
  \]
  Višina, #h#, preskočnega seznama je
  \[
       #h# = \sum_{i=1}^\infty I_{#r#} \enspace .
  \]
  Upoštevajte, da  $I_{#r#}$ ni nikoli večji kot dolžina, $|L_{#r#}|$, od $L_{#r#}$, zato
  \[
     \E[I_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
 Zato imamo
  \begin{align*}
       \E[#h#] &= \E\left[\sum_{r=1}^\infty I_{#r#}\right] \\
        &= \sum_{#r#=1}^{\infty} E[I_{#r#}] \\
        &= \sum_{#r#=1}^{\lfloor\log #n#\rfloor} E[I_{#r#}]
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} E[I_{#r#}]  \\
        &\le \sum_{#r#=1}^{\lfloor\log #n#\rfloor} 1
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} #n#/2^{#r#} \\
        &\le \log #n#
                 + \sum_{#r#=0}^\infty 1/2^{#r#} \\
        &= \log #n# + 2 \enspace . \qedhere
  \end{align*}
\end{proof}

\begin{lem}\lemlabel{skiplist-size2}
  Pričakovano število vozlišč v preskočnem seznamu ki vsebuje $#n#$ elementov,
  z vsemi pojavitvami staržarja, je $2#n#+O(\log #n#)$.
\end{lem}

\begin{proof}
  Po \lemref{skiplist-size1}, sledi da je pričakovano število vozlišč, brez stražarja
 $2#n#$.  Število pojavitev stražarja je enako višini, $#h#$, preskočnega seznama, torej je po 
  \lemref{skiplist-height} pričakovano število pojavitev
  stražarja največ $\log #n#+2 = O(\log #n#)$.
\end{proof}



\begin{lem}
Pričakovana dolžina iskalne poti v preskočnem seznamu je največ $2\log #n# + O(1)$.
\end{lem}

\begin{proof}
  Najlažje dokažemo hipotezo tako da uporabimo \emph{vzvratno iskanje poti} za vozlišče, #x#.  Ta pot se začne pri predhodniku #x#-a
  v $L_0$. Če gre lahko pot v kateremkoli primeru en nivo višje, potem to tudi stori. V kolikor nemore iti en nivo višje, gre levo. Če nekaj trenutkov premišljujemo o tem nas bo prepričalo da je vzvratna iskalna pot za  #x# enaka iskalni poti za #x#, z razliko da je vzvratna.

  Število vozlišč, ki jih obišče vzvratna pot na nekem nivoju
  , #r#, je povezana z naslednjim eksperimentom:  Vržimo kovanec.
  Če pade glava,se premakni navzgor, nato ustavi. V nasprotnem primeru se premakni levo in ponovi eksperiment. Številov metov kovanca, preden pade glava predstavlja število korakov v levo, ki ki jih vzvratna iskalna pot porabi v nekem nadstropju. footnote{Bodite pozorni da lahko pride do 
“overcounta” števila korakov na levo, saj se mora  eksperiment končati. Končati mora ob prvi glavi  ali ko iskalna pot doseže stražarja, kateri pride prvi. To ne predstavlja problema saj leži hipoteza na  zgornji meji.} \lemref{coin-tosses} nam prikazuje da je pričakovano število metov kovanca preden pade prva “glava”, 1.

  Naj $S_{#r#}$ označuje število korakov ki jih porabi iskalna pot naprej na nivoju
  $#r#$ ki gre levo.   Pravkar smo trdili da  $\E[S_{#r#}]\le
  1$.  Poleg tega, $S_{#r#}\le |L_{#r#}|$, ker nemoremo narediti več korakov v  $L_{#r#}$  kot je dolžina $L_{#r#}$, zato
  \[
    \E[S_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
 Sedaj lahko dokončamo dokaz \lemref{skiplist-height}.
  Naj bo $S$ dolžina iskalne poti nekega vozlišča, #u#, v preskočnem seznamu  in naj bo $#h#$ višina preskočnega seznama. Sledi
  \begin{align*}
      \E[S]
         &= \E\left[ #h# + \sum_{#r#=0}^\infty S_{#r#} \right] \\
         &= \E[#h#] + \sum_{#r#=0}^\infty \E[S_{#r#}]  \\
         &= \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} \E[S_{#r#}]
              + \sum_{#r#=\lfloor\log #n#\rfloor+1}^\infty \E[S_{#r#}] \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{r=\lfloor\log #n#\rfloor+1}^\infty #n#/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \log #n# + 3 \\
         &\le 2\log #n# + 5  \enspace . \qedhere
  \end{align*}
\end{proof}


Sledeči teorem povzema rezultat sekcije:
\begin{thm}
Preskočni senam, ki vsebuje $#n#$ elementov je pričakoval velikost $O(#n#)$ in pričakovana dolžina iskalne poti nekega elementa je največ:
$2\log #n# + O(1)$.
\end{thm}



%\section{Iteration and Finger Search}

%TODO: Napiši to sekcijo

\section{Discussion and Exercises}

