\chapter{Kopice}
\chaplabel{Kopice}
\translatedby{David Zavodnik, Grega Vertovšek, Luka Vabič, Luka Florjančič, Jure Žvelc, Rok Komatar}{sl}

V tem poglavju si bomo pogledali 2 implementacije zelo uporabne podatkovne strukture
#Polje# s prednostjo. Obe od teh dveh struktur sta posebne oblike Dvojiškega drevesa imenovani \emph{Kopica}, 
\index{Kopica}%
\index{Binarna Kopica}%
\index{Kopica!Binarna}%
kar pomeni ''neorganizirana kopica''. To je v nasprotju z dvojiškimi iskalnimi drevesi 
pri katerih pomislimo na zelo urejeno kopico.

Prva izvedba kopic uporablja polje, da simuliramo popolno dvojiško drevo. Ta zelo hitra implementacija je osnova za enega izmed najhitrejših znanih sortirnih algoritmov, in sicer kopično urejanje (glej \secref{heapsort}).
Druga implementacija je bazirana na bolj fleksiblinih dvojiških drevesih, ki podpirajo #meld(h)# operacijo, ki omogoča vrsti s prednostjo, da obsorbira elemente druge vrste s prednostjo #h#.

\section{#BinaryHeap#: implicitno dvojiško drevo}
\seclabel{binaryheap}

\index{BinarnaKopica@#BinaryHeap#}%
Naša prva implementacija #Queue# (s prednostjo) temelji na tehniki, 
ki je stara preko 400 let. \emph{Eytzingerjeva metoda}
\index{Eytzingerjeva metoda}%
nam omogoča, da predstavimo popolno dvojiško drevo kot polje, v katerem imamo vozlišča 
postavljena v vrsto iz leve proti desni (glej \secref{bintree:traversal}).
Na ta način je koren drevesa shranjen na poziciji 0, njegov levi otrok je shranjen na poziciji 0, 
njegov desni otrok na pozciji 1, levi otrok na 2, levi otrok otroka na poziciji 3 in tako naprej.
Glej \figref{eytzinger}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/eytzinger}
  \end{center}
  \caption{Eytzingerjeva metoda predstavlja popolno dvojiško drevo kot polje.}
  \figlabel{eytzinger}
\end{figure}

Če uporabimo Eytzingerjevo metodo na dovolj velikih drevesih se za-čnejo pojavljati vzorci.
Levi otrok vozlišča pri indexu #i# je na indexu $#left(i)#=2#i#+1$ 
in desni otrok vozlišča pri indexu #i# je na indexu $#right(i)#=2#i#+2$.
Starš vozlišča pri indexu #i# pa je na $#parent(i)#=(#i#-1)/2$.
\codeimport{ods/BinaryHeap.left(i).right(i).parent(i)}

#BinaryHeap# uporablja to tehniko, da implicitno predstavi popolno dvojiško drevo
v katerem so elementi \emph{kopično urejeni}:
\index{heap-ordered binary tree}%
\index{binary tree!heap-ordered}%
\index{heap order}%
Vrednost shranjena na katerem koli indexu #i# ni manjša kot vrednost shranjena
na katerem koli indexu #parent(i)#, razen izjeme vrednosti korena $#i#=0$. To nam 
o-mogoča, da je najmanjša vrednost #Queue# s prednostjo tako shranjena na poziciji 0 (koren).

V #BinaryHeap#,  je #n# elementov shranjenih v tabeli #a#:
\codeimport{ods/BinaryHeap.a.n}

Implementacija operacije #add(x)# je preprosta. Kot vse strukture bazirane na polju
najprej pogledamo, če je #a# poln (preverimo $#a.length#=#n#$) in če je, povečamo #a#. Nato #x# zapišemo na mesto #a[n]# in povečamo #n#. Na tej točki je potrebno storiti samo še to, da zagotovimo lastnost kopice.
To storimo tako, da zamenjujemo #x# z njegovim staršem, dokler ni #x# manjši od svojega starša.
Glej \figref{heap-insert}.
\codeimport{ods/BinaryHeap.add(x).bubbleUp(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-4} \\
  \end{center}
  \caption[Adding to a BinaryHeap]{Dodajanje elementa 6 v #BinaryHeap#.}
  \figlabel{heap-insert}
\end{figure}

Implementacija #remove()# operacije, katera odstrani najmanjšo vred-nost
v kopici, je nekoliko težja. Vemo, kje je najmanjši element (v korenu), vendar ga moramo po odstranitvi nadomestiti in zagotoviti, da ohranjamo
lastnosti kopice.

Najlažji način, da to naredimo je, da koren nadomestimo z vrednostjo #a[n-1]#, 
zbrišemo vrednost in zmanjšamo #n#. Na žalost novi koren najverjetneje ni najmanjši element, zato ga  moramo prestaviti po kopici navzdol. To naredimo tako, da rekurzivno primerjamo element z njegovimi otroki. V primeru, da je element v kopici najmanjši smo končali, v nasprotnem primeru ga zamenjamo z najmanjšim izmed otrok in nadaljujemo ta postopek rekurzivno.
\codeimport{ods/BinaryHeap.remove().trickleDown(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-4} \\
  \end{center}
  \caption[Odstranjevanje iz dvojiške kopice]{Odstranjevanje najmanjšega elementa, 4, iz #BinaryHeap#.}
  \figlabel{heap-remove}
\end{figure}


Kot ostale implementirane strukture polja, bomo mi ignorirali porabljen čas
v celicah za funkcijo #resize()#, ker se to lahko obračunava na amortizacijskem argumentu iz Lemma
\lemref{arraystack-amortized}. Pretečeni čas za #add(x)# in #remove()# je odvisen
od višine (implicitnega) dvojiškega drevesa. Na srečo je to \emph{polno}
\index{dvojiško drevo!Popolno}%
\index{popolno Dvojiško drevo}%
Dvojiško drevo;  vsak nivo, razen zadnjega ima največje možno število vozlišč. Tako, je
višina drevesa enaka $h$ in ima najmanj $2^h$ vozlišč. Začnimo na ta način
\[
  #n# \ge 2^h \enspace .
\]  
Če logaritmiramo, dobimo na obeh straneh enačbe
\[
   h \le \log #n# \enspace .
\]
Tako obe, #add(x)# in #remove()# operaciji tečeta v $O(\log #n#)$ času.

\subsection{Povzetek}

Naslednji teorem povzame uspešnost #BinaryHeap#.

\begin{thm}\thmlabel{binaryheap}
  #BinaryHeap# implementira #Queue# (s prednostjo). Ignoriramo ceno 
  polja da se poveča #resize()#, #BinaryHeap# podpira operaciji 
  #add(x)# in #remove()# v času $O(\log #n#)$ na operacijo.

  Poleg tega, začnimo s prazno #BinaryHeap#, katero koli zaporedje $m$
  #add(x)# in #remove()# je rezultat skupaj $O(m)$ čas enak
  porabljen za vse klice funkcije #resize()#.
\end{thm}

\section{#MeldableHeap#: Naključna zlivalna kopica}
\seclabel{Zlivalna kopica}

\index{ZlivalnaKopica@#MeldableHeap#}%
V poglavju bomo opisali #MeldableHeap#, implementacijo prioritetne vrste #Queue#, shranjeno 
v kopičasto urejenem dvojiškem drevesu. Za razliko od #BinaryHeap#, pri katerem dvojiško drevo
definira število elementov, dvojiško drevo #MeldableHeap# nima omejitev glede oblike.

The #add(x)# and #remove()# operations in a #MeldableHeap# sta blablablala ok to je delal.. ššščččžžž
implemented in terms of the #merge(h1,h2)# operation.  This operation
takes two heap nodes #h1# and #h2# and merges them, returning a heap
node that is the root of a heap that contains all elements in the subtree
rooted at #h1# and all elements in the subtree rooted at #h2#.

Operacijo #merge(h1,h2)# lahko implementiramo rekurzivno. Glej \figref{meldable-merge}.
Če je vozlišče #h1# oz. #h2# #nil#, zlivamo s prazno množico in vrnemo vozlišče #h1# ali #h2#,
ki ni #nil#. V nasprotnem primeru zamenjamo vlogi #h1# in #h2# glede na velikost
vrednosti vozlišča tako, da večje od obeh vozlišč postane koren nove kopice. V primeru, da je v korenu
vrednost #h1.x#, potem lahko #h2# lahko rekurzivno zlijemo z #h1.left# ali #h1.right#, odvisno od
naključne vrednosti meta kovanca. 

\codeimport{ods/MeldableHeap.merge(h1,h2)}

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/meldable-merge}}
  \caption[Zlivanje v zlivalni kopici]{Zlivanje #h1# in #h2# opravimo z združitvijo #h2# in #h1.left# oz. #h1.right#.}
  \figlabel{meldable-merge}
\end{figure}

V naslednjem delu poglavja pokažemo, da ima operacija #merge(h1,h2)# pričakovano časovno zahtevnost $O(\log #n#)$,
kjer je #n# končno število elementov v #h1# in #h2#.


S pomočjo operacije #merge(h1,h2)# je vstavljanje #add(x)# enostavno. Ustvarimo novo vozlišče #u# z vrednostjo #x# in
zlijemo vozlišče s korenom kopice:
\codeimport{ods/MeldableHeap.add(x)}
Operacija ima pričakovano časovno zahtevnost $O(\log (#n#+1)) = O(\log #n#)$.

Podobno je z operacijo #remove()#. Odstranjujemo korensko vozlišče, ki ga zamenja rezultat
zlivanja njegovih otrok:
\codeimport{ods/MeldableHeap.remove()}
Tudi #remove()# ima pričakovano časovno zahtevnost $O(\log #n#)$.

#MeldableHeap# lahko implementira tudi mnogo ostalih operacij s časovno zahtevnostjo
$O(\log #n#)$, npr.:
\begin{itemize}
\item #remove(u)#: iz kopice odstranimo vozlišče #u# (in pripadajoč ključ #u.x#).
\item #absorb(h)#: vse elemente #MeldableHeap# #h# dodamo kopici, kjer v postopku praznimo #h#.
\end{itemize}
Vsaka operacija lahko vsebuje konstantno število #merge(h1,h2)# operacij s časovno zahtevnostjo
$O(\log #n#)$.

\subsection{Analiza #merge(h1,h2)#}

Analiza operacije #merge(h1,h2)# je osnovana na analizi naključnega sprehoda v dvojiškem drevesu.
V dvojiškem drevesu se \emph{naključni sprehod} začne v korenu drevesa. V vsakem koraku naključnega sprehoda
vržemo kovanec, ki določa smer sprehoda (levi ali desni otrok trenutnega vozlišča).
Ko trenutno vozlišče postane #nil# se sprehod konča.

Sledeča lema je zanimiva, ker ni odvisna od oblike dvojiškega drevesa:

\begin{lem}\lemlabel{tree-random-walk}
Pričakovana dolžina naključnega sprehoda v dvojiškem drevesu z #n# vozlišči je največ #\log (n+1)#.
\end{lem}

\begin{proof}
Trditev lahko dokažemo z indukcijo. Za osnovo izberimo $#n#=0$ in dolžino sprehoda $0=\log (#n#+1)$.
Trditev drži za vsa pozitivna števila $#n#'< #n#$.

Let $#n#_1$ denote the size of the root's left subtree, so that
$#n#_2=#n#-#n#_1-1$ is the size of the root's right subtree.  Starting at
the root, the walk takes one step and then continues in a subtree of
size $#n#_1$ or $#n#_2$.  By our inductive hypothesis, the expected
length of the walk is then
\[
    \E[W] = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1)  \enspace , 
\] 
since each of $#n#_1$ and $#n#_2$ are less than $#n#$.  Since $\log$
is a concave function, $\E[W]$ is maximized when $#n#_1=#n#_2=(#n#-1)/2$.
%To maximize this,
%over all choices of $#n#_1\in[0,#n#-1]$, we take the derivative and obtain
%\[
%    (\E[W])' = \frac{1}{2}(c/#n#_1 - c/(#n#-#n#_1-1)) \enspace , 
%\]
%which is equal to 0 when $#n#_1 = (#n#-1)/2$.  We can establish that
%this is a maximum fairly easily, so
Therefore,
 the expected number of steps taken by the random walk is 
\begin{align*}
    \E[W] 
    & = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1) \\
   & \le  1 + \log ((#n#-1)/2+1) \\
   & =  1 + \log ((#n#+1)/2) \\
   & =  \log (#n#+1)  \enspace . \qedhere 
\end{align*}
\end{proof}

Za bralce s pomanjkljivim poznavanjem informacijske teorije lahko dokaz za \lemref{tree-random-walk}
izrazimo s pomočjo entropije.
\begin{proof}[Informaciski teoretični dokaz za \lemref{tree-random-walk}]
Naj $d_i$ označuje globino $i$-tega zunanjega vozlišča. Spomnimo se, da
ima dvojiško drevo z #n# vozlišči #n+1# zunanjih vozlišč. Verjetnost, da bo
naključni sprehod dosegel $i$-to zunanje vozlišče je natančno 
$p_i=1/2^{d_i}$. Tako je pričakovana dolžina naključnega sprehoda
\[
   H=\sum_{i=0}^{#n#} p_id_i
    =\sum_{i=0}^{#n#} p_i\log\left(2^{d_i}\right)
    = \sum_{i=0}^{#n#}p_i\log({1/p_i})
\]
Desna stran enačbe je prepoznavna kot entropija verjetnostne distribucije na $#n#+1$ 
elementih, katera nikoli ne preseže $\log(#n#+1)$, kar dokazuje lemo. 

\end{proof}


S tem tudi enostavno dokažemo, da je čas izvajanja operacije #merge(h1,h2)# $O(\log #n#)$.


\begin{lem}
  Če sta #h1# in #h2# korena dveh kopic z vozliščema $#n#_1$ in $#n#_2$ je pričakovan
  čas izvajanja operacije #merge(h1,h2)# največ $O(\log #n#)$, kjer je $#n#=#n#_1+#n#_2$.
\end{lem}

\begin{proof}
  Vsak korak algoritma za zlivanje zavzame en korak v naključnem sprehodu,
  bodisi v kopici s korenom #h1# bodisi v kopici s korenom #h2#.
  Algoritem se zaključi ko katerikoli izmed dveh naključnih sprehodov doseže
  konec drevesa. Pričakovano število korakov zlivalnega algoritma je največ 
  \[
     \log (#n#_1+1) + \log (#n#_2+1) \le 2\log #n# \enspace . \qedhere
  \]
\end{proof}

\subsection{Povzetek}

Sledeči teorem povzame zmogljivost #MeldableHeap#:

\begin{thm}\thmlabel{meldableheap}
  #MeldableHeap# implementira (prioritetni) #Queue# vmesnik.
  #MeldableHeap# podpira operaciji #add(x)# in #remove()#.
  $O(\log #n#)$ je pričakovan čas izvajanja posamezne operacije.
\end{thm}

\section{Diskusije in vaje}

Izgleda, da je implicitno predstavitev polnega dvojiškega drevesa s tabelo ali seznamom 
prvič predlagal Eytzinger \cite{e1590}.
Implicitno predstavitev je v svojih knjigah uporabil na primeru družinskih drevesih plemiških družin
\index{pedigree family tree}%
Podatkovno strukturo #BinaryHeap# opisano v tej knjigi je prvič predstavil Williams \cite{w64}.

Naključno podatkovno strukturo #MeldableHeap# sta prvič predlagala Gambin in Malinowski \cite{gm98}.
Obstajajo tudi druge implementacije zlivalnih kopic vključno z
levo poravnane kopice \cite[Section~5.3.2]{c72,k97v3},
\index{leftist heap}%
\index{heap!leftist}%
binomske kopice \cite{v78},
\index{binomial heap}%
\index{heap!binomial}%
Fibonaccijeve kopice \cite{ft87}, 
\index{Fibonacci heap}%
\index{heap!Fibonacci}%
parne kopice \cite{fsst86},\
\index{pairing heap}%
\index{heap!pairing}%
 in samoprilagoditvene kopice \cite{st83}, 
\index{skew heap}%
\index{heap!skew}%
Čeprav niso tako enostavne kot je struktura #MeldableHeap#.

Some of the above structures also support a #decreaseKey(u,y)# operation
\index{decreaseKey@#decreaseKey(u,y)#}%
in which the value stored at node #u# is decreased to #y#.  (It is a
pre-condition that $#y#\le#u.x#$.)  In most of the preceding structures,
this operation can be supported in $O(\log #n#)$ time by removing node
#u# and adding  #y#.  However, some of these structures can implement
#decreaseKey(u,y)# more efficiently.  In particular, #decreaseKey(u,y)#
takes $O(1)$ amortized time in Fibonacci heaps and $O(\log\log #n#)$
amortized time in a special version of pairing heaps \cite{e09}.
This more efficient #decreaseKey(u,y)# operation has applications in
speeding up several graph algorithms, including Dijkstra's shortest path
algorithm \cite{ft87}.

\begin{exc}
  Illustrate the addition of the values 7 and then 3 to the #BinaryHeap#
  shown at the end of \figref{heap-insert}.
\end{exc}

\begin{exc}
  Illustrate the removal of the next two values (6 and 8) on the
  #BinaryHeap# shown at the end of \figref{heap-remove}.
\end{exc}

\begin{exc}
  Implement the #remove(i)# method, that removes the value stored in
  #a[i]# in a #BinaryHeap#.  This method should run in $O(\log #n#)$ time.
  Next, explain why this method is not likely to be useful.
\end{exc}

\begin{exc}\exclabel{general-eytzinger}
  \index{tree!$d$-ary}%
  A $d$-ary tree is a generalization of a binary tree in which each
  internal node has $d$ children.  Using Eytzinger's method it is also
  possible to represent complete $d$-ary trees using arrays.  Work out
  the equations that, given an index #i#, determine the index of #i#'s
  parent and each of #i#'s $d$ children in this representation.
\end{exc}

\begin{exc}
  \index{DaryHeap@#DaryHeap#}%
  Using what you learned in \excref{general-eytzinger}, design and
  implement a \emph{#DaryHeap#}, the $d$-ary generalization of a
  #BinaryHeap#. Analyze the running times of operations on a #DaryHeap#
  and test the performance of your #DaryHeap# implementation against
  that of the #BinaryHeap# implementation given here.
\end{exc}



\begin{exc}
  Illustrate the addition of the values 17 and then 82 in the
  #MeldableHeap# #h1# shown in \figref{meldable-merge}.  Use a coin to
  simulate a random bit when needed.
\end{exc}

\begin{exc}
  Illustrate the removal of the next two values (4 and 8) in the
  #MeldableHeap# #h1# shown in \figref{meldable-merge}.  Use a coin to
  simulate a random bit when needed.
\end{exc}

\begin{exc}
  Implement the #remove(u)# method, that removes the node #u# from
  a #MeldableHeap#.  This method should run in $O(\log #n#)$ expected time.
\end{exc}

\begin{exc}
  Show how to find the second smallest value in a #BinaryHeap# or
  #MeldableHeap# in constant time.
\end{exc}

\begin{exc}
  Show how to find the $k$th smallest value in a #BinaryHeap# or
  #MeldableHeap# in $O(k\log k)$ time.  (Hint: Using another heap
  might help.)
\end{exc}

\begin{exc}
  Suppose you are given #k# sorted lists, of total length #n#.  Using
  a heap, show how to merge these into a single sorted list in $O(n\log
  k)$ time.  (Hint: Starting with the case $k=2$ can be instructive.)
\end{exc}








