\chapter{Kopice}
\chaplabel{Kopice}
\translatedby{¿an Pecar}{sl}

V tem poglavju si bomo pogledali 2 implementacije zelo uporabne podatkovne strukture
#Polje# s prednostjo. Obe od teh dveh struktur sta posebne oblike Binarnega drevesa imenovani \emph{Kopica}, 
\index{Kopica}%
\index{Binarna Kopica}%
\index{Kopica!Binarna}%
kar pomeni ``neorganizirana kopica''. To je v nasprotju z binarnimi iskalnimi drevesi 
pri katerih pomislimo na zelo urejeno kopico.

Prva izvedba kup uporablja polje, da simuliramo popolno binarno 
drevo.
To zelo hitra implementacija je osnova za enega izmed najhitrejsih 
znanih sortirnih algoritmov, in sicer Kopicno urejanje. (see \secref{Kopicno urejanje}).

Druga implementacija je bazirana na bolj fleksiblinih binarnih drevesih, ki 
podpira #meld(h)# operacijo, ki omogoca vrsti s prednostjo da obsorbira elemente druge vrste s prednostjo #h#.

\section{#BinarnaKopica#: inplicitno binarno drevo}
\seclabel{BinarnaKopica}

\index{BinarnaKopica@#BinarnaKopica#}%
Nasa prva implementacije #Vrste# (s prednostjo) temelji na tehniki, 
ki je stara preko 400 let. \emph{Eytzingerjeva metoda}
Our first implementation of a (priority) #Queue# is based on a technique
that is over four hundred years old.  \emph{Eytzinger's method}
\index{Eytzingerjeva metoda}%
nam omogoca da predstavimp popolno binarno drevo kot polje, v katerem imamo vozlisca 
postavlna v vrsto iz leve proti desni.
(glej \secref{bintree:traversal}).
Na ta nacin je koren drevesa spravljen na pozociji 0, njegov levi otrok je shranjen na poziciji 0, 
njegov desni otrok na pozciji 1, levi otrok na 2, levi otrok otroka na poziciji 3 in tako naprej.
Glej \figref{eytzinger}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/eytzinger}
  \end{center}
  \caption{Eytzingerjeva meroda predstavlja poplno binarno drevo kot polje.}
  \figlabel{eytzinger}
\end{figure}

ce uporabimo Eytzingerjevo metodo na zadosti velikih drevesih se
zacnejo pojavljati vzroci.
Levi otrok vozlica pri indexu #i# je na indexu $#left(i)#=2#i#+1$ 
in desni otrok vozlisca pri indexu #i# je na indexu $#right(i)#=2#i#+2$
Stars vozlisca pri indexu #i# pa je na $#parent(i)#=(#i#-1)/2$.
\codeimport{ods/BinaryHeap.left(i).right(i).parent(i)}

#Binarna Kopica# uporablja to tehniko da implicitno predstavi popolno binarno drevo
v katerem so elementi \emph{Kopicno urejeni}:
\index{heap-ordered binary tree}%
\index{binary tree!heap-ordered}%
\index{heap order}%
Vrednost shranjena na kateremkoli indexu #i# ni manjpa kot vrednost shranjena
na kateremkoli indexu #parent(i)# razen izjeme vrednosti korena $#i#=0$. To nam 
omogoca da je najmanjsa vrednost #vrste# s prednostjo tako na shranjena na poziciji 0(koren).

V #Binarna Kopici#,  je #n# elementov shranjenih v vrsti #a#:
\codeimport{ods/BinaryHeap.a.n}

Implementacija operacije #Dodaj(x)# je preprosta. Kot vse strukture bazirane na polju
najprej pogledamo ce je #a# pol (preverimo $#a.length#=#n#$) in ce le povecamo #a#
#a[n]# in increment #n#. Na tej poti je samo se kar nam ostane, da zagotovimo lastnost kopice.
To delamo tako da premescamo #x# z njegovim starsem dokler ni #x# manjsi od svojega starsa.
Implementing the #add(x)# operation is fairly straightforward.  As with
See \figref{Kopica-vstavi}.
\codeimport{ods/BinaryHeap.add(x).bubbleUp(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-4} \\
  \end{center}
  \caption[Adding to a BinaryHeap]{Adding the value 6 to a #BinaryHeap#.}
  \figlabel{heap-insert}
\end{figure}

Implementavija #remove()# operacije, katera odstarani najmanjso vrednost
v kopici, je malo tesje. Vemo kje je najmanjsi element (v korenu), ampak 
ga moramo nademstiti potem ko ga odstranimi in zagotoviti to ohranjamo
lastnosti kopice.

Najlasji nacin da to naredimo da koren nadomestimo v vrednostjo #a[n-1]#, 
zbrisemo vrednost  in decrement "n". Na salost novi koren najverjetneje ni najmanjsi
element, zato ga  moramo prestaviti dol v kopici. To naredimo tako da ponavljajoce
primerjamo ta element z njegovimi otroki. ce je najmanjsi v kopici smo kocali, 
v nasprotnem primeru ga zamenjamo z najmanjsim od njegovih otrok in nadaljujemo 
z primerjavo.
\codeimport{ods/BinaryHeap.remove().trickleDown(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-4} \\
  \end{center}
  \caption[Odstranjevanje iz binarne kopice]{Odstranjevanje 4 najmanjsega elementa, iz #Binarne Kopice#.}
  \figlabel{heap-remove}
\end{figure}


Kot ostali iz polja implementirane strukture, bomo mi ignorirali cas porabljen
v celicah za #povecaj()#, ker se to lahko obracunava na amortizacijskem argumentu iz
\lemref{arraystack-amortized}. Pretekli cas za #Dodaj()# in #remove()# je odvisen
od visine (implicitnega) binarnega drevesa. Na sreco je to \emph{popolno}
\index{Binarno drevo!Popolno}%
\index{Popolno Binrano drevo}%
Binarno drevo;  vsako nivo razen zadnje ima maximalno stevilo vozlisc. Tako, je
visina drevesa enaka $h$ in ima najmanj $2^h$ vizlisc.

zacnimo na ta nacin:
\[
  #n# \ge 2^h \enspace .
\]  
Algoritem da na obeh straneh enacbe
\[
   h \le \log #n# \enspace .
\]
teko obe #add(x)# in #remove()# operaciji teceta v$O(\log #n#)$ casu.

\subsection{Summary}

Naslednji teorem povzame uspesnost #Binarne kopice#

\begin{thm}\thmlabel{binaryheap}
  #Binarna Kopica# implementira #Polje# (s prednostjo). Ignoriramo ceno 
  polja da se poveca#resize()#, Binarna Kopica podpira oberaciji 
  #add(x)# in #remove()# v casu $O(\log #n#)$ na operacijo.

  Tako naprej, zacetek z prazno #Binarno kopico#, katerokoli zapredje $m$
  #add(x)# in #remove()# opraciji je rezultat skupaj $O(m)$ cas enak
  porabljen za povecanje #resize()#.
\end{thm}

\section{#MeldableHeap#: Naklju?na zdru?evalna kopica}
\seclabel{Zdru?evalna kopica}

\index{Zdruzevalnakopica@#MeldableHeap#}%
V poglavju bomo opisali #MeldableHeap#, implementacijo prioritetne #Queue#, shranjeno 
v kopi?asto urejenem binarnem drevesu. Z razliko od #BinaryHeap#, pri katerem binarno drevo
definira ?tevilo elementov, binarno drevo #MeldableHeap# nima omejitev glede oblike.

Operaciji #add(x)# in #remove()# v #MeldableHeap# sta implementirani z uporabo
operacije #merge(h1,h2)#. Operacija #merge(h1,h2)# zdru?i vozli??i kopice #h1# in #h2# in vrne
korensko vozli??e nove kopice, ki vsebuje vse elemente poddreves vozli?? #h1# in #h2#.

Operacijo #merge(h1,h2)# lahko implementiramo rekurzivno. Glej \figref{meldable-merge}.
?e je vozli??e #h1# oz. #h2# #nil#, zdru?ujemo s prazno mno?ico in vrnemo vozli??e #h1# ali #h2#,
ki ni #nil#. V nasprotnem primeru zamenjamo vlogi #h1# in #h2# glede na velikost
vrednosti vozli??a tako, da ve?je od obeh vozli?? postane koren nove kopice. V primeru, da je v korenu
vrednost #h1.x#, potem lahko #h2# lahko rekurzivno zdru?imo z #h1.left# ali #h1.right#, odvisno od
naklju?ne vrednosti meta kovanca. 
\codeimport{ods/MeldableHeap.merge(h1,h2)}

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/meldable-merge}}
  \caption[Zdru?evanje v zdru?evalni kopici]{Zdru?evanje #h1# in #h2# opravimo z zdru?itvijo #h2# in #h1.left# oz. #h1.right#.}
  \figlabel{meldable-merge}
\end{figure}

V naslednjem delu poglavja poka?emo, da ima operacija #merge(h1,h2)# pri?akovano ?asovno zahtevnost $O(\log #n#)$,
kjer je #n# kon?no ?tevilo elementov v #h1# in #h2#.

S pomo?jo operacije #merge(h1,h2)# je vstavljanje #add(x)# enostavno. Ustvarimo novo vozli??e #u# z vrednostjo #x# in
zdru?imo vozli??e s korenom kopice:
\codeimport{ods/MeldableHeap.add(x)}
Operacija ima pri?akovano ?asovno zahtevnost $O(\log (#n#+1)) = O(\log #n#)$.

Podobno je z operacijo #remove()#. Odstranjujemo korensko vozli??e, ki ga zamenja rezultat
zdru?evanja njegovih otrok:
\codeimport{ods/MeldableHeap.remove()}
Tudi remove ima pri?akovano ?asovno zahtevnost $O(\log #n#)$.

#MedlableHeap# lahko implementira tudi mnogo ostalih operacij s ?asovno zahtevnostjo
$O(\log #n#)$, npr.:
\begin{itemize}
\item #remove(u)#: iz kopice odstranimo vozli??e #u# (in pripadajo? klju? #u.x#).
\item #absorb(h)#: vse elemente #MeldableHeap# #h# dodamo kopici, kjer v postopku praznimo #h#.
\end{itemize}
Vsaka operacija lahko vsebuje konstantno ?tevilo #merge(h1,h2)# operacij s ?asovno zahtevnostjo
$O(\log #n#)$.

\subsection{Analiza #merge(h1,h2)#}

Analiza operacije #merge(h1,h2)# je osnovana na analizi naklju?nega sprehoda v binarnem drevesu.
V binarnem drevesu se \emph{random walk} za?ne v korenu drevesa. V vsakem koraku naklju?nega sprehoda
vr?emo kovanec, ki dolo?a smer sprehoda (levi ali desni otrok trenutnega vozli??a).
Ko trenutno vozli??e postane #nil# se sperhod kon?a.

Slede?a lema je zanimiva, ker ni odvisna od oblike binarnega drevesa:

\begin{lem}\lemlabel{tree-random-walk}
Pri?akovana dol?ina naklju?nega sprehoda v binarnem drevesu z #n# vozli??i je najve? #\log (n+1)#.
\end{lem}

\begin{proof}
Trditev lahko doka?emo z indukcijo. Za osnovo izberimo $#n#=0$ in dol?ino sprehoda $0=\log (#n#+1)$.
Trditev dr?i za vsa ne negativna ?tevila $#n#'< #n#$.


Dol?ino korenskega levega poddrevesa ozna?imo z $#n#_1$, da bo $#n#_2=#n#-#n#_1-1$ velikost
korenskega desnega poddrevesa. Sprehod se za?ne v korenu, zavzame en korak in nato nadaljuje v
poddrevesu velikosti $#n#_1$ ali $#n#_2$.
Po na?i induktivni hipotezi je pri?akovana dol?ina sprehoda 
\[
    \E[W] = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1)  \enspace , 
\] 
saj je vsako od $#n#_1$ ali $#n#_2$ manj?e od $#n#$. Ker je $\log$ funkcija konkavne
oblike $\E[W]$ dose?e maksimum, ko je $#n#_1=#n#_2=(#n#-1)/2$. 
%To maximize this,
%over all choices of $#n#_1\in[0,#n#-1]$, we take the derivative and obtain
%\[
%    (\E[W])' = \frac{1}{2}(c/#n#_1 - c/(#n#-#n#_1-1)) \enspace , 
%\]
%which is equal to 0 when $#n#_1 = (#n#-1)/2$.  We can establish that
%this is a maximum fairly easily, so
Potemtakem je pri?akovano ?tevilo korakov
\begin{align*}
    \E[W] 
    & = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1) \\
   & \le  1 + \log ((#n#-1)/2+1) \\
   & =  1 + \log ((#n#+1)/2) \\
   & =  \log (#n#+1)  \enspace . \qedhere 
\end{align*}
\end{proof}

Za bralce s pomankljivim poznavanjem informacijske teorije lahko dokaz za \lemref{tree-random-walk}
izrazimo s pomo?jo entropije.
\begin{proof}[Informaciski teoreti?ni dokaz za \lemref{tree-random-walk}]
Naj $d_i$ ozna?uje globino $i$-tega zunanjega vozli??a. Spomnimo se, da
ima binarno drevo z #n# vozli??i #n+1# zunanjih vozli??. Verjetnost, da bo
naklju?ni sprehod dosegel $i$-to zunanje vozli??e je natan?no 
$p_i=1/2^{d_i}$. Tako je pri?akovana dol?ina naklju?nega sprehoda
\[
   H=\sum_{i=0}^{#n#} p_id_i
    =\sum_{i=0}^{#n#} p_i\log\left(2^{d_i}\right)
    = \sum_{i=0}^{#n#}p_i\log({1/p_i})
\]
Desna stran ena?be je prepoznavna kot entropija verjetnostne distribucije na $#n#+1$ 
elementih, katera nikoli ne prese?e $\log(#n#+1)$, kar dokazuje lemo. 
S tem tudi enostavno doka?emo, da je ?as izvajanja operacije #merge(h1,h2)# $O(\log #n#)$.

With this result on random walks, we can now easily prove that the
running time of the #merge(h1,h2)# operation is $O(\log #n#)$.

\begin{lem}
  ?e sta #h1# in #h2# korena dveh kopic z vozli??ema $#n#_1$ in $#n#_2$ je pri?akovan
  ?as izvajanja operacije #merge(h1,h2)# najve? $O(\log #n#)$, kjer je $#n#=#n#_1+#n#_2$.
\end{lem}

\begin{proof}
  Vsak korak algoritma za zdru?evanje zavzame en korak v naklju?nem sprehodu,
  bodisi v kopici s korenom #h1# bodisi v kopici s korenom #h2#.
  Algoritem se zaklju?i ko katerikoli izmed dveh naklju?nih sprehodov dose?e
  konec drevesa. Pri?akovano ?tevilo korakov zdru?evalnega algoritma je najve? 
  \[
     \log (#n#_1+1) + \log (#n#_2+1) \le 2\log #n# \enspace . \qedhere
  \]
\end{proof}

\subsection{Povzetek}

Slede?i teorem povzame zmogljivost #MeldableHeap#:

\begin{thm}\thmlabel{meldableheap}
  #MeldableHeap# implementira (prioritetni) #Queue# vmesnik.
  #MeldableHeap# podpira operaciji #add(x)# in #remove()#.
  $O(\log #n#)$ je pri?akovan ?as izvajanja posamezne operacije.
\end{thm}

\section{Diskusije in vaje}

Izgleda, da je implicitno predstavitev polnega binarnega drevesa s tabelo ali seznamom 
prvi? predlagal Eytzinger \cite{e1590}.
Implicitno predstavitev je v svojih knjigah uporabil na primeru plemi?kih dru?inskih drevesih
\index{pedigree family tree}%
Podatkovno strukturo #BinaryHeap# opisano v tej knjigi je prvi? predstavil Williams \cite{w64}.

Naklju?no podatkovno strukturo #MeldableHeap# sta prvi? predlagala Gambin in Malinowski \cite{gm98}.
Obstajajo tudi druge implementacije zdru?evalnih kopic vklju?no z
levo poravnane kopice \cite[Section~5.3.2]{c72,k97v3},
\index{leftist heap}%
\index{heap!leftist}%
binomske kopice \cite{v78},
\index{binomial heap}%
\index{heap!binomial}%
Fibonaccijeve kopice \cite{ft87}, 
\index{Fibonacci heap}%
\index{heap!Fibonacci}%
parne kopice \cite{fsst86},\
\index{pairing heap}%
\index{heap!pairing}%
 in samoprilagoditvene kopice \cite{st83}, 
\index{skew heap}%
\index{heap!skew}%
?eprav niso tako enostavne kot je struktura #MeldableHeap#.

Nekaj zgoraj navedenih struktur podpira tudi operacijo #decreaseKey(u,v)#
\index{decreaseKey@#decreaseKey(u,y)#}%
v kateri se vrednost vozli??a #u# zni?a na vrednost vozli??a #y# (ob predpogoju $#y#\le#u.x#$). 
V ve?ini strukturah lahko opracijo #decreaseKey(u,v)# izvajamo s ?asovno zahtevnostjo
$O(\log #n#)$ z odstranjanjem vozli??a #u# in dodajanjem vozli??a #t#. Nekatere strukture
lahko implementirajo operacijo bolj u?inkovito. V Fibonaccijevih kopicah ima amortizirano ?asovno 
zahtevnost $O(1)$ in amortizirano $O(\log\log #n#)$ v posebni razli?ici parnih kopic \cite{e09}.
Omenjena u?inkovitej?a razli?ica operacije #decreaseKey(u,y)# se uporablja pri 
pohitritvi grafov, vklju?no z Dijkstra algoritmom za iskanje najkraj?e poti \cite{ft87}.

\begin{exc}
  Illustrate the addition of the values 7 and then 3 to the #BinaryHeap#
  shown at the end of \figref{heap-insert}.
\end{exc}

\begin{exc}
  Illustrate the removal of the next two values (6 and 8) on the
  #BinaryHeap# shown at the end of \figref{heap-remove}.
\end{exc}

\begin{exc}
  Implement the #remove(i)# method, that removes the value stored in
  #a[i]# in a #BinaryHeap#.  This method should run in $O(\log #n#)$ time.
  Next, explain why this method is not likely to be useful.
\end{exc}

\begin{exc}\exclabel{general-eytzinger}
  \index{tree!$d$-ary}%
  A $d$-ary tree is a generalization of a binary tree in which each
  internal node has $d$ children.  Using Eytzinger's method it is also
  possible to represent complete $d$-ary trees using arrays.  Work out
  the equations that, given an index #i#, determine the index of #i#'s
  parent and each of #i#'s $d$ children in this representation.
\end{exc}

\begin{exc}
  \index{DaryHeap@#DaryHeap#}%
  Using what you learned in \excref{general-eytzinger}, design and
  implement a \emph{#DaryHeap#}, the $d$-ary generalization of a
  #BinaryHeap#. Analyze the running times of operations on a #DaryHeap#
  and test the performance of your #DaryHeap# implementation against
  that of the #BinaryHeap# implementation given here.
\end{exc}



\begin{exc}
  Illustrate the addition of the values 17 and then 82 in the
  #MeldableHeap# #h1# shown in \figref{meldable-merge}.  Use a coin to
  simulate a random bit when needed.
\end{exc}

\begin{exc}
  Illustrate the removal of the next two values (4 and 8) in the
  #MeldableHeap# #h1# shown in \figref{meldable-merge}.  Use a coin to
  simulate a random bit when needed.
\end{exc}

\begin{exc}
  Implement the #remove(u)# method, that removes the node #u# from
  a #MeldableHeap#.  This method should run in $O(\log #n#)$ expected time.
\end{exc}

\begin{exc}
  Show how to find the second smallest value in a #BinaryHeap# or
  #MeldableHeap# in constant time.
\end{exc}

\begin{exc}
  Show how to find the $k$th smallest value in a #BinaryHeap# or
  #MeldableHeap# in $O(k\log k)$ time.  (Hint: Using another heap
  might help.)
\end{exc}

\begin{exc}
  Suppose you are given #k# sorted lists, of total length #n#.  Using
  a heap, show how to merge these into a single sorted list in $O(n\log
  k)$ time.  (Hint: Starting with the case $k=2$ can be instructive.)
\end{exc}








