\translatedby{Toma\v z Sabadin}{sl}

\chapter{Povezani seznam}
\chaplabel{linkedlists}

\index{linked list}%
V tem poglavju nadaljujemo z implementacijo #Seznama#, s to razliko, da bomo uporabli podatkovne strukture, ki delujejo na osnovi kazalcev namesto polj. Strukture v tem poglavju so sestavljene iz vozlišč, ki vsebujejo elemente seznama. Z uporabo referenc (kazalcev) so vozlišča povezana zaporedoma med seboj. Najprej bomo pogledali enostransko povezane sezname, s katerimi lahko implementiramo operacije #Sklada# in (FIFO) #Vrste#, ki se izvedejo v konstantnem času. Nato si bomo pogledali še obojestransko povezani seznam, s katerim lahko implementiramo #Deque# operacije tako, da se izvedejo v konstantnem času (Deque - vrsta pri kateri lahko dodajamo ter odstranjujemo elemente na začetku ali na koncu).

Povezani seznami imajo prednosti in slabosti v primerjavi z implementacijo #Seznama# z uporabo polja. Največja slabost je ta, da izgubimo zmožnost, da lahko v konstantem času dostopamo do kateregakoli elementa z uporabo metod #get(i)# ali #set(i,x)#. Namesto tega, se moramo sprehoditi po celotenem seznam, element po element, dokler ne pridemo do #i#-tega elementa. Največja prednost pa je dinamičnost: z uporabo referenc vsakega vozlišča seznama #u#, lahko izbrišemo #u# ali vstavimo sosednje vozlišče vozlišču #u# v konstantnem času. To je vedno res ne glede na to, kje se nahaja vozlišče #u# v seznamu.



\section{#SLList#: Enostransko povezani seznam}
\seclabel{sllist}

\index{SLList@#SLList#}%
\index{linked list!singly-}%
\index{singly-linked list}%
Enostransko povezani seznam #SLList# (singly-linked list) je zaporedje #Vozlisc#. Vsako vozlišče #u# hrani vrednost #u.x# ter referenco #u.next# na naslednje vozlišče. Zadnje vozlišče #w# ima $#w.next# = #null#$


% TODO: Remove constructors from SLList.Node
\codeimport{ods/SLList.Node}

Za boljšo učinkovitost delovanja #SLList# uporablja spremnljivki #head# in #tail# za beleženje prvega ter zadnjega vozlišča. Za beleženje dolžine seznama, pa hrani celoštevilsko spremenljivko #n#: 
\codeimport{ods/SLList.head.tail.n}
Zaporedje ukazov #Sklada# in #Vrste# nad enostransko povezanim seznamom je prikazana na \figref{sllist}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/sllist}
  \end{center}
  \caption[Zaporedje ukazov Sklada in Vrste nad enostransko povezanim seznamom]{Zaporedje ukazov #Vrste# (#add(x)# in #remove()#) ter #Sklada# (#push(x)# in #pop()#) nad enostransko povezanim seznamom.}
  \figlabel{sllist}
\end{figure}

Enostransko povezani seznam lahko učinkovito implementira operaciji #Sklada#, to sta #push(x)# in #pop()#, s katerima dodajamo ter odstranjujemo elemente iz začetka seznama. Operacija #push(x)# kreira novo vozlišče #u# z vrednostjo #x#, nastavi #u.next# tako, da kaže na stari začetek seznama, novi začetek seznama pa postane #u#. Na koncu še povečamo vrednost #n#, saj se je velikost seznama povečala za 1.

\codeimport{ods/SLList.push(x)}

Operacija #pop()# najprej preveri, ali je enostransko povezani seznam prazen. Če ni prazen, odstrani začetno vozlišče tako, da nastavi spremenljivko, ki kaže na začetek vozišča na $#head#=#head.next#$ in zmanjša spremenljivko #n# za 1. Poseben primer je, če odstranimo zadnje vozlišče, v tem primeru postavimo #tail# na #null#:


\codeimport{ods/SLList.pop()}

Časovna zahtevnost operacij #push(x)# in #pop()# je $O(1)$.

\subsection{Operacije Vrste}

Enostransko povezani seznam lahko implementira tudi operaciji FIFO vrste, to sta #add(x)# in #remove()#, obe se izvedeta v konstantnem času. Operacija odstranjevanja vozlišča je identična operaciji #pop()#, odstrani se torej vozlišče na začetku seznama:


\codeimport{ods/SLList.remove()}

Dodajanje pa je izvedeno tako, da se novo vozlišče pripne na konec seznama. V večini primerov to naredimo tako, da postavimo $#tail.next#=#u#$, kjer je #u# novo nastalo vozlišče in vsebuje vrednost #x#.Paziti je treba na poseben primer, ki se zgodi, kadar je seznam prazen,  $#n#=0$. To pomeni, da je $#tail#=#head#=#null#$. V tem primeru #tail# in #head# kažeta na #u#.


\codeimport{ods/SLList.add(x)}

Obe operaciji #add(x)# in #remove()# se izvedeta v konstantnem času.

\subsection{Povzetek}

Sledeči izrek povzame zmožnosti enostransko povezanega seznama #SLList#:

\begin{thm}\thmlabel{sllist}
  Enostransko povezani seznam #SLList# implementira operacije vmesnika #Sklada# in (FIFO) #Vrste#. Operacije #push(x)#, #pop()#, #add(x)# in #remove()# se izvedejo v $O(1)$. 
\end{thm}

Enostransko povezani seznam #SLList# implementira skoraj vse operacije #Degue# vrste. Edina manjkajoča operacija je odstranjevanje elementov iz konca enostransko povezanega seznama. Brisanje iz konca enojno povezanega seznama je težavno, saj moramo posodobiti vrednost #tail#, tako da kaže na vozlišče #w#, ki je predhodnik našega vozlišča #tail#. Naše vozlišče #w# izgleda tako $#w.next#=#tail#$. Na žalost pa je edina možnost da pridemo do vozlišča #w# ta, da se še enkrat sprehodimo čez celoten seznam, od začetka v vozlišču #head#, za kar pa potrebujemo $#n#-2$ korakov. 



\translatedby{Klemen Lorenčič}{sl}

\section{#DLList#: Obojestransko povezan seznam}
\seclabel{dllist}

\index{DLList@#DLList#}%
\index{doubly-linked list}%
\index{linked list!doubly-}%
#DLList# (obojestransko povezan seznam) je zelo podoben #SLList# le, da ima vsako vozlišče #u# v #DLList# referenco na dve vozlišči, #u.next#, ki mu sledi ter vozlišče #u.prev#, ki je pred njim.


\codeimport{ods/DLList.Node}


Pri implementaciji #SLList#, smo ugtovili, da imamo kar nekaj posebnih primerov, na katere moramo paziti. Na primer, pri odstranjevanju zadnjega elementa
iz #SLList# ali pa dodajanju elementa v praznen #SLList# moramo zagotoviti, da se #glava# in #rep# pravilno posodobita. V # DLList#
se število teh posebnih primerov znatno poveča. Morda najboljši način, da poskrbimo za vse te posebne primere v #DLList# je, da uvedemo #dummy# (navidezno) vozlišče.
\index{dummy node}%
To je vozlišče, ki ne vsebuje nobenih podatkov,
ampak deluje kot ograda,tako da ni posebnih vozlišč; vsako vozlišče ima tako #next# kot #prev#, z #dummy#, ki deluje kot navidezno vozlišče, ki sledi zadnjemu vozlišču v seznamu in je predhodnik prvega vozlišča v seznamu. Na ta način so vozlišča v seznamu obojestransko povezana v cikel, kot je prikazano na       \figref{dllist}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/dllist2}
  \end{center}
  \caption[A DLList]{A #DLList# containing a,b,c,d,e.}
  \figlabel{dllist}
\end{figure}


%TODO: Remove constructors from class Node

\codeimport{ods/DLList.n.dummy.DLList()}

Iskanje vozlišče z določenim indeksom v #DLList# je enostavno; lahko bodisi začnemo pri glavi seznama (# dummy.next #) in se pomikamo naprej, ali pa začnemo pri repu seznama (#dummy.prev#) in se pomikamo nazaj. To nam omogoča, da dosežemo #i#-to vozlišče v času $O(1+\min\{#i#,#n#-#i#\})$:

\codeimport{ods/DLList.getNode(i)}

#get(i)# in #set (i, x)# operacije so prav tako enostavne. Najprej moramo najti #i#-to vozlišče, nato pa dobimo ali nastavimo njegovo vrednost #x#:

\codeimport{ods/DLList.get(i).set(i,x)}

Čas izvajanja teh operacij je določen z strani časa, ki potrebujemo, da bi našli #i#-to vozlišče in je zato $O(1+\min\{#i#,#n#-#i#\})$..


\subsection{Dodajanje in odstranjevanje}

Če imamo referenco na vozlišče #w# v #DLList# in želimo vstaviti vozlišče #u# pred #w#, potem je potrebno le nastaviti $#u.next#=#w#$, 
$#u.prev#=#w.prev#$ ter #u.prev.next# in #u.next.prev#. (Glej \figref{dllist-addbefore}.) 
Zahvaljujoč navideznem vozlišču nam ni treba skrbeti, ali vozlišči #w.prev# in #w.next# sploh obstajata.

\codeimport{ods/DLList.addBefore(w,x)}

\begin{figure}
   \begin{center}
      \includegraphics[scale=0.90909]{figs/dllist-addbefore}
   \end{center}
   \caption[Adding to a DLList]{Dodajanje vozlišča #u# pred vozlišče #w#
     v #DLList#.}
   \figlabel{dllist-addbefore}
\end{figure}

Operacija seznama #add (i, x)# je trivialna za implementacijo. Najti moramo #i#-to vozlišče v #DLList# in nato vstavimo novo vozlišče #u#, ki vsebuje #x#, tik pred njim.

\codeimport{ods/DLList.add(i,x)}

Edini nekonstantni del časa izvajanja časa izvajanja #add(i, x)#, je čas, ki ga potrebujemo, da najdemo #i#-to vozlišče (z #getNode(i)#). Tako se #add(i, x)# izvede v času $O(1+\min\{#i#, #n#-#i#\})$. 

Odstranjevanje vozlišča #w# iz #DLList# je enostavno. Potrebujemo samo nastaviti kazalec #w.next# in #w.prev# tako, da preskočijo vozlišče #w#. Uporaba navideznega vozlišča odpravi potrebo po upoštevanju posebnih primerov:

\codeimport{ods/DLList.remove(w)}

Operacija #remove(i)# je prav tako enostavna. Najdemo vozlišče z indeksom #i# in ga odstranimo:

\codeimport{ods/DLList.remove(i)}

Edini dragi del te operacije je iskanje #i#-tega vozlišča 
z uporabo #getNode(i)# , #remove(i)# se torej izvede v času $O(1+\min\{#i#, #n#-#i#\})$.

\subsection{Povzetek}

Naslednji izrek povzema uspešnost #DLList#:

\begin{thm}\thmlabel{dllist}
  #DLList# implementira vmesnik #List# (seznam). V tej izvedbi, je časovna zahtevnost operacij #get(i)#, #set(i,x)#, #add(i,x)# in #remove(i)# $O(1+\min\{#i#,#n#-#i#\})$.
\end{thm}

Treba je omeniti, da če odmislimo ceno operacije #getNode(i)#, se vse operacije v #DLList# izvedejo v konstantem času.  Edina draga operacija v #DLList# je torej iskanje ustreznega vozlišča. Ko imamo dostop do ustreznega vozlišča, se dodajanje, odstranjevanje ali dostop do podatkov v tem vozlišču se izvede v konstantnem času.


To je v popolnem nasprotju z implementacijami #seznama# na osnovi polja \chapref{arrays}; v teh izvedbi, lahko ustrezen element najdemo v konstantnem času. Vendar pa dodajanje ali odstranjevanje zahteva premikanje elementov v polju, kar pa načeloma ni operacija, ki se bi izvedla v konstantnem času.

Iz tega razloga, so povezani seznami primerni za primere, kjer lahko reference vozlišč pridobimo iz zunanjih virov. 
\javaonly {Primer za to je #LinkedHashSet# v Java Collection Framework, v kateri je sklop elementov shranjen v obojestransko povezani seznam in vozlišča obojestransko povezanega seznama se hranijo v razpršeni tabeli (obravnavano v \chapref {hashing}). Pri odstranjevanju iz #LinkedHashSet# se razpršena tabela uporabi pri iskanju ustreznega vozlišča v konstantnem času in nato se vozlišče izbriše (tudi v konstantnem času)} 
\cpponly{Na primer kazalci na vozlišča povezanega seznama bi lahko bili shranjeni v #USet#. Za odstranitev elementa #x# iz povezanega seznama, lahko vozlišče, ki vsebuje #x#, hitro najdemo z uporabo #Uset# in vozlišče lahko odstranimo s seznama v konstantnem času.}


\section{Razprave in vaje}

Tako enosmerno-povezani kot dvosmerno-povezani seznami so uveljavljene tehnike,
uporabljene v programih že več kot 40 let. O njih naprimer razpravlja Knuth \cite[Sections~2.2.3--2.2.5]{k97v1}.
Tudi podatkovna struktura #SEList# je uveljavljena kot dobro poznana vaja podatkovnih struktur.
#SEList# včasih imenujemo tudi \emph{unrolled linked list} \cite{sra94}.
\index{unrolled linked list|seealso{#SEList#}}%
\index{linked list!unrolled|seealso{#SEList#}}%

Na prostoru v dvosmerno-povezanem seznamu lahko prihranimo z uporabo t.i. XOR-seznamov.
\index{XOR-list}%
V XOR-seznamu vsako vozlišče #u# vsebuje samo en kazalec, imenovan #u.naslednjiprejsnji#, ki vsebuje 
bitni ekskluzivni OR kazalcev #u.prejsnji# in #u.naslednji#. Seznam potrebuje za delovanje dva kazalca, 
eden kaže na #prazen# vozlišče, drug pa na #prazen.naslednji# (prvo vozlišče, ali #prazen# vozlišče, če je seznam prazen).
Ta tehnika izrablja dejstvo, da če imamo dva kazalca na #u# in #u.prejsnji#, lahko izluščimo #u.naslednji# s pomočjo naslednje formule
\[
   #u.naslednji# = #u.prejsnji# \verb+^+ #u.naslednjiprejsnji# \enspace .
\]

(Tukaj nam operator \verb+^+ izračuna bitni XOR dveh argumentov.) Ta tehnika programsko kodo zakomplicira in implementacija v vseh programskih jezikih, kot je naprimer Java ali Python, ki imajo mehanizme za sproščanje pomnilnika (garbage collector) ni možna. Tukaj podamo dvosmerno-povezan seznam, ki za delovanje potrebuje samo en kazalec na vozlišče.
Za referenco o podrobnejši razpravi XOR seznamo si poglej članek Sinhe \cite{s04}..

\begin{exc}
  Zakaj ni možna uporaba praznega vozlišča v #SLList# za izogib posebih primerov, ki se zgodijo pri operacijah #push(x)#, #pop()#, #add(x)# in #remove()#?
\end{exc}

\begin{exc}
  Napišite #SLList# (enosmerno-povezan seznam) metodo #predzadnjiEl()#, ki vrne predzadnji element v #SLList#. 
Metodo implementirajte brez uporabe članovske spremenljivke #n#, ki skrbi za velikost seznama.
\end{exc}

\begin{exc}
  Na enosmerno-povezanem seznamu implementirajte naslednje #List# operacije: get(i)#, #set(i,x)#,
  #add(i,x)# in #remove(i)#. Vse metode se naj izvedejo v  $O(1+#i#)$ časovni zahtevnosti.

\end{exc}


\begin{exc}
  Na enosmerno-povezanem seznamu implementirajte metodo #obrni()#, ki obrne vrstni red elementov v seznamu. Metoda naj teče v $O(#n#)$ časovni zahtevnosti. Ni dovoljena uporaba rekurzije in implementacija z drugimi časovnimi strukturami. Prav tako ni dovoljeno ustvarjati nova vozlišča.
\end{exc}



\begin{exc}
   Napišite metodo za enosmerno in dvosmerno-povezan seznam #preveriVelikost()#. Metoda naj se sprehodi skozi seznam in prešteje število vozlišč. Če se prešteto število vozlišč ne ujema z vrednostjo shranjeno v spremenljivki #n#, naj metoda vrže izjemo. V primeru da se števila ujemata, metoda ne vrača ničesar.
\end{exc}


\begin{exc}
  Ponovno napišite kodo za #addBefore(w)# operacijo, ki ustvari novo vozlišče #u# in ga doda v dvosmerno-povezan seznam tik pred vozliščem #w#. Tudi, če se vaša koda ne popolnoma ujema s kodo iz te knjige, je metoda še vseeno lahko pravilna. Najbolje, da metodo stestirate in preverite.
\end{exc}

Z naslednjimi vajami bomo izvajali manipulacije na dvosmerno-povezanih seznamih. Vse vaje morate dokončati brez dodeljevanja novih vozlišč ali začasnih seznamov. Vse naloge se lahko rešijo s spreminjanjem vrednosti #prejsnji# in #naslednji# v že obstoječih vozliščih.

\begin{exc}
  Napišite metodo za dvosmerno-povezan seznam #jePalindrom()#, ki vrne #true#, če je seznam \emph{palindrom},
\index{palindrome}%
npr., element na poziciji #i# je enak elementu na poziciji $#n#-i-1$ za vsak $i\in\{0,\ldots,#n#-1\}$.
Metoda se naj izvede v $O(#n#)$ časovni zahtevnosti.
\end{exc}

\begin{exc}
  Napišite novo metodo #rotiraj(r)#, ki ''obrne'' dvosmerno-povezan seznam tako, da element na poziciji #i# postane element $(#i#+#r#)\bmod #n#$.
Ta metoda se običajno izvaja v $O(1+\min\{#r#,#n#-#r#\})$ časovni zahtevnosti in ne spreminja vozlišč v seznamu.
\end{exc}

\begin{exc}\exclabel{linkedlist-truncate}
  Napišite metodo #odsekaj(i)#, ki odseka dvojno-povezan seznam na poziciji #i#. Po izvedbi metode naj bo velikost seznama #i#, vsebuje pa naj samo elemente do indeksa  $#i#,\ldots,#n#-1$. Metoda naj se izvede v $O(\min\{#i#,#n#-#i#\})$ časovni zahtevnosti.
\end{exc}



\begin{exc}
   Napišite metodo dvojno-povezanega seznama #absorbiraj(l2)#, ki za vhodni parameter prejme dvojno-povezan seznam #l2#, ter sprazni njegovo vsebino in jo pripne na konec svojega seznama. Naprimer, če #l1# vsebuje $a,b,c$ in #l2# vsebuje $d,e,f$, po klicu #l1.absorbiraj(l2)# #l1# vesbuje $a,b,c,d,e,f$, #l2# pa bo prazen.
\end{exc}

\begin{exc}
Napišite metodo #sprosti()#, ki iz dvojno-povezanega seznama
odstrani vse elemente z lihimi indeksi in vrne dvojno-povezan seznam, 
ki vsebuje izbrisane elemente. Naprimer, če #l1# vsebuje $a,b,c,d,e,f$, 
potem bo po klicu #l1.sprosti()# vseboval $a,c,e$, metoda pa bo vrnila seznam , 
ki vsebuje elemente $b,d,f$.
\end{exc}

\begin{exc}
Napišite metodo #obrni()#, ki obrne vrstni red elementov v dvojno-povezanem seznamu.
\end{exc}

\begin{exc}\exclabel{dllist-sort}
\index{merge-sort}%
V tej vaji boste implementirali urejanje dvojno-povezanega 
seznama z zlivanjem, kot je opisano v poglavju \secref{merge-sort}. 
\javaonly{Da bo končna implementacija sposobna urediti katerikoli dvojno-povezan seznam z elementi, 
ki implementirajo #Comparable#, primerjavo med elementi v vaši implementaciji izvedite z metodo #compareTo(x)#.}
\begin{enumerate}
\item Napišite metodo dvojno-povezanega seznama #vzemiPrvega(l2)#, 
ki odstrani prvo vozlišče iz #l2# ter ga doda na konec seznama, 
nad katerim je bila metoda klicana. Metoda je enakovredna klicu 
#dodaj(velikost(), l2.odstrani(0))#, vendar pri tem ne ustvari novega 
vozlišča.
\item Napišite statično metodo dvojno-povezanega seznama #zdruzi(l1, l2)#,
 ki kot argument dobi dva urejena seznama #l1# in #l2#, ju združi ter vrne nov 
 urejen seznam. Seznama #l1# ter #l2# se v metodi izpraznita. Naprimer, če #l1# 
 vsebuje $a,c,d$ in #l2# vsebuje $b,e,f$ , metoda vrne nov seznam, ki vsebuje 
 $a,b,c,d,e,f$.
\item Napišite metodo dvojno-povezanega seznama #uredi()#, ki uredi elemente 
v seznamu z uporabo urejanja z zlivanjem. Ta rekurzivni algoritem deluje tako:
	\begin{enumerate}
		\item Če je velikost seznama 0 ali 1, je seznam urejen. V nasprotnem primeru…
		\item Z uporabo metode #odsekaj(velikost()/2)#, razdeli seznam v dva seznama #l1# in #l2#
		, ki sta približno enake velikosti.
		\item Rekurzivno uredi #l1#.
		\item Rekurzivno uredi #l2#.
		\item Združi #l1# in #l2# v en urejen seznam.
	\end{enumerate}
\end{enumerate}
\end{exc}


Naslednje  vaje so naprednejše ter zahtevajo jasno razumevanje kaj se dogaja z 
najmanjšo vrednostjo shranjeno v skladu ali vrsti, ko dodajamo ter odstranjujemo elemente.

\begin{exc}
\index{MinStack@#MinStack#}%
Zasnuj ter implementiraj podatkovno strukturo #MinSklad#, ki hrani primerljive elemente 
in podpira skladovne operacije #potisni(x)#, #snemi()# ter #velikost()#. 
Poleg tega podpira tudi operacijo #min()#, ki vrne trenutno najmanjšo vrednost v skladu.
Vse operacije naj se izvedejo v konstantnem času.
\end{exc}

\begin{exc}
  \index{MinQueue@#MinQueue#}%
  Zasnuj ter implementiraj podatkovno strukturo #MinVrsta#, ki hrani
  primerljive elemente in podpira operacije vrste: #dodaj(x)#, #odstrani()# in #velikost()#.
  Poleg tega vsebuje tudi operacijo #min()#, ki vrne trenutno najmanjšo vrednost v vrsti.
  Vse operacije naj se izvedejo v konstantnem amortiziranem času.
\end{exc}

\begin{exc}
\index{MinDeque@#MinDeque#}%
Zasnuj ter implementiraj podatkovno strukturo #MinOSVrsta#, 
ki hrani primerljive elemente in podpira operacije obojestranske vrste: 
#dodajPrvega(x)#, #dodajZadnjega(x)#, #odstraniPrvega()#, #odstraniZadnjega()# in #velikost()#. 
Poleg tega vsebuje tudi operacijo #min()#, ki vrne trenutno najmanjšo vrednost v obojestranski vrsti. 
Vse operacijo nase se izvedejo v konstantnem amortiziranem času.
\end{exc}


Naslednje vaje preverijo razumevanje implementacije in analize prostorsko učinkovitega povezanega seznama(#PUSeznam#).

\begin{exc}
Dokaži, da se operacije prostorsko učinkovitega seznama uporabljenega kot sklad (prost. učinkovit seznam spreminjata
le operaciji $#push(x)#\equiv#add(size(),x)#$ in $#pop()#\equiv #remove(size()-1)#$)),
izvedejo v konstantnem amortiziranem času neodvisno od vrednosti b.
\end{exc}

\begin{exc}
Zasnuj ter implementiraj različico prostorsko učinkovitega seznama, ki izvede vse operacije obojestranske vrste v 
konstantnem amortiziranem času na vsako operacijo, neodvisno od vrednosti b.
\end{exc}

\begin{exc}
Kako bi uporabil bitno operacijo ekskluzivni ali(XOR) za zamenjavo vrednosti dveh celoštevilskih(#int#) 
spremenljivk brez, da bi uporabil tretjo spremenljivko?
\end{exc}