\translatedby{Anej Marušič}{sl}
\chapter{Podatkovne strukture za cela števila}

V tem poglavju se bomo vrnili k problemu implementiranja #SSet#-a. Razlika v implementaciji je ta, da zdaj privzamemo, da so elementi shranjeni v #SSet#-u,
#w#-bitna cela števila. To pomeni da hočemo implementirati metode #add(x)#, #remove(x)# in #find(x)#, kjer velja da $#x#\in\{0,\ldots,2^{#w#}-1\}$. Če malo pomislimo obstaja veliko aplikacij, kjer imamo podatke, oziroma vsaj ključe za sortiranje podatkov, ki so cela števila.

Govorili bomo o treh podatkovnih strukturah, vsaka izmed njih bo temeljila na idejah že prej omenjenih podatkovnih strukturah. Prva struktura, #BinaryTrie#, lahko izvrši vse tri #SSet# operacije v času $O(#w#)$. To sicer ni tako zelo impresivno, saj ima vsaka podmnožica $\{0,\ldots,2^{#w#}-1\}$ velikost $#n#\le 2^{#w#}$, tako da je $\log #n# \le #w#$.  Vse ostale #SSet# implementacije, s katerimi imamo opravka v tej knjigi lahko izvedejo vse operacije v $O(\log #n#)$ času, torej so vse vsaj toliko hitre kot #BinaryTrie#.

Druga struktura, #XFastTrie#, pohitri iskanje v
#BinaryTrie# z uporabo razpršenja. S to pohitritvijo se #find(x)#
operacija izvede v $O(\log #w#)$ času, vendar pa #add(x)# in #remove(x)#
operaciji v #XFastTrie# še vedno potrebujeta $O(#w#)$ časa. Prostor, ki ga #XFastTrie# potrebuje pa je $O(#n#\cdot#w#)$.

Tretja podatkovna struktura,  #YFastTrie#, uporablja #XFastTrie# za shranjevanje le vzorca enega oz. okoli enega, od vsakih $#w#$ elementov in preostale elemente shranjuje v standardno #SSet# strukturo. Ta trik zmanjša čas izvajanja operacij #add(x)# in #remove(x)# na $O(\log #w#)$ in zmanjša prostorsko zahtevnost na $O(#n#)$.

Implementacije uporabljene kot primeri v tem poglavju lahko shranjujejo katerikoli tip podatkov, dokler je lahko ta podatek nekako predstavljen tudi kot celo število. V primerih programske kode, predstavlja spremenljivka #ix# vedno, vrednost celega števila, ki pripada #x#. Metoda \javaonly{#in.#}#intValue(x)# pa pretvori #x# v njegovo pripadajoče celo število. V besedilu bomo enostavno uporabljali #x# kot celo število.

\section{#BinaryTrie#: digitalno iskalno drevo}
\seclabel{binarytrie}

\index{BinaryTrie@#BinaryTrie#}%
#BinaryTrie# zakodira niz #w#-bitnih celih števil v binarno drevo. Vsi listi v drevesu imajo globino #w# in vsako celo število je prikazano kot pot od korena do lista. Pot za celo število #x# na nivoju #i# nadaljuje pot proti levemu poddrevesu, če je #i#-ti najpomembnejši bit (most significant bit)  #x# enak 0 oz. nadaljuje pot proti desnemu poddrevesu, če je ta bit enak 1.  \figref{binarytrie-ex} prikazuje primer, ko je $#w#=4$,
in trie shranjuje cela števila 3(0011), 9(1001), 12(1100),
in 13(1101).
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/binarytrie-ex-1}
  \end{center}
  \caption{Cela števila shranjena v binary trie so zakodirana kot poti od korena do lista.}
  \figlabel{binarytrie-ex}
\end{figure}

Ker iskalna pot za vrednost
\index{search path!in a #BinaryTrie#}%
#x# odvisi od bitov #x#-a, nam bo koristilo, če otroka vozlišča poimenujemo #u#, #u.child[0]# (#left#)
in #u.child[1]# (#right#).  Tile kazalci na otroke bodo pravzaprav služili dvema namenoma. Ker listi v binary trie nimajo nobenega otroka, so kazalci uporabljeni za povezavo listov v dvojno povezan seznam. Za list v binary trie je #u.child[0]# (#prev#) je vozlišče, ki je pred #u#-jem v seznamu in #u.child[1]# (#next#) je vozlišče, ki sledi #u#-ju v seznamu.  Posebno vozlišče #dummy#, je uporabljeno pred prvim vozliščem in za zadnjim vozliščem v seznamu. (glej \secref{dllist}).
\cpponly{V primerih kode se #u.child[0]#, #u.left#, in #u.prev# nanašajo na enako polje v vozlišču #u#, kot #u.child[1]#, #u.right#, i #u.next#.}

Vsako vozlišče, #u#, vsebuje tudi dodatni kazalec #u.jump#.  Če je #u#
brez svojega levega otroka, potem #u.jump# kaže na najmanjši list v 
#u#-jevem poddrevesu.  Če pa je #u# brez svojega desnega otroka potem #u.jump# kaže na največji list v #u#-jevem poddrevesu.  Primer #BinaryTrie#,
ki prikazuje #jump# kazalce in dvojno povezan seznam na nivoju listov, je prikazan na \figref{binarytrie-ex2}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/binarytrie-ex-2}
  \end{center}
  \caption[A BinaryTrie]{ #BinaryTrie# z #jump# kazalci, prikazanami kot prekinjene ukrivljene povezave.}
  \figlabel{binarytrie-ex2}
\end{figure}


%\jxavaimport{ods/BinaryTrie.Node<Node}
%\cxppimport{ods/BinaryTrie.BinaryTrieNode<Node}

#find(x)# operacija je v #BinaryTrie# precej enostavna.
Najprej sledimo iskalni poti za #x# v trie.  Če dosežemo list, potem smo našli #x#.  Če pa naletimo na vozlišče iz katerega potem ne moremo napredovati (ker #u#-ju manjka otrok), potem sledimo #u.jump# kazalcu, ki nam kaže ali na najmanjši list, ki je še večji od #x# ali na največji list, ki je še manjši od #x#. Kateri od teh dveh primerov se zgodi odvisi od tega ali #u#-ju manjka njegov levi ali desni otrok. V prvem primeru  (#u#-ju manjka njegov levi otrok), smo že prišli do vozlišča do katerega hočemo. V kasnejšem primeru (#u#-ju manjka njegov desni otrok), pa lahko uporabimo povezan seznam, da pridemo do vozlišča do katerega hočemo. Vsak od teh primerov je prikazan na \figref{binarytrie-find}.
\codeimport{ods/BinaryTrie.find(x)}
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/binarytrie-ex-3}
  \end{center}
  \caption[Search paths in a BinaryTrie]{Poti po katerih gre #find(5)# in #find(8)#.}
  \figlabel{binarytrie-find}
\end{figure}
Čas izvajanja metode #find(x)# je določena z časom, ki ga struktura potrebuje, da pride po poti iz korena do lista. Torej je časovna kompleksnost $O(#w#)$.

Tudi #add(x)# operacija je v #BinaryTrie# precej enostavna,
vendar ima še vedno veliko za narediti:
\begin{enumerate}
  \item Sledi iskalni poti za #x# dokler ne doseže vozlišča #u#, kjer ne more več nadeljevati.
  \item Ustvari ostanek iskalne poti od #u# do lista, ki vsebuje #x#.
  \item Vozlišče #u'#, ki vsebuje #x#, se doda povezanemu seznamu listov (metoda ima dostop do prednika, #pred#, #u'#-ja v povezanem seznamu jump kazalca zadnjega vozlišča #u#, na katerega smo naleteli v koraku ~1.)
  \item Sledi nazaj po iskalni poti za #x# in sproti popravlja #jump# kazalce na vozliščih, kjer bi zdaj moral #jump# kazalec kazati na #x#.
\end{enumerate}
Dodajanje v strukturo je prikazano na \figref{binarytrie-add}.
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/binarytrie-add}
  \end{center}
  \caption[Adding to a BinaryTrie]{Dodajanje vrednosti 2 in 15 v #BinaryTrie# na
  \figref{binarytrie-ex2}.}
  \figlabel{binarytrie-add}
\end{figure}
\codeimport{ods/BinaryTrie.add(x)}
Ta metoda naredi en sprehod navzdol po iskalni poti #x#-a in en sprehod nazaj navzgor. Vsak korak od teh sprehodov potrebuje konstantno časa, torej je časovna zahtevnost #add(x)#
enaka $O(#w#)$.


#remove(x)# operacija razveljavi, kar naredi #add(x)# operacija.  Prav tako kot #add(x)#, ima tudi #remove(x)# veliko za postoriti:
\begin{enumerate}
  \item Najprej sledi iskalni poti za #x# dokler ne doseže lista #u#,
  ki vsebuje #x#.
  \item Izbriše #u# iz dvojno povezanega seznama.
  \item Izbriše #u# in se sprehodi nazaj navzgor po iskalni poti za #x# ter sproti briše vozlišča dokler ne doseže vozlišča #v#, ki ima otroka, ki ni del iskalne poti za #x#.
  \item Sprehodi se še navzgor od #v#-ja do korena in spreminja #jump# kazalce, ki kažejo na #u#.
\end{enumerate}
Odstranjevanje je prikazano na \figref{binarytrie-remove}.
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/binarytrie-remove}
  \end{center}
  \caption[Removing from a BinaryTrie]{Odstranjevanje vrednosti 9 iz #BinaryTrie# na
  \figref{binarytrie-ex2}.}
  \figlabel{binarytrie-remove}
\end{figure}
\codeimport{ods/BinaryTrie.remove(x)}

\begin{thm}
#BinaryTrie# implementira #SSet# vmesnik za #w#-bitna cela števila. #BinaryTrie# podpira operacije #add(x)#, #remove(x)# in #find(x)#
v časovni kompleksnosti $O(#w#)$ na operacijo.  Prostor, ki ga #BinaryTrie# uporablja za shranjevanje #n# vrednosti je $O(#n#\cdot#w#)$.
\end{thm}

\section{#XFastTrie#: Iskanje v dvojnem logaritmičnem času}
\seclabel{xfast}

\index{XFastTrie@#XFastTrie#}%
Hitrost izvajanja #BinaryTrie# strukture ni ravno impresivna.
Število elementov #n# shranjenih v podatkovi strukturi je najmanj $2^{#w#}$
torej $\log #n#\le #w#$.  Z drugimi besedami, vse primerjalne #SSet#
strukture opisane v drugih poglavnih te knjige so vsaj tako učinkovite kot #BinaryTrie# in niso omejene samo na shranjevanje celih števil.

V slednjem besedilu je opisana #XFastTrie#, ki je v osnovi #BinaryTrie# z
#w+1# razpršilnimi tabelami---ena za vsak nivo trie. Te razpršilne tabele se uporabljajo za pohitritev #find(x)# operacije na $O(\log #w#)$ čas.
#find(x)# operacija v #BinaryTrie# je skoraj končana, ko dosežemo vozlišče #u# kjer gre iskalna pot proti #x# #u.right# (oziroma #u.left#), ampak #u# nima desnega (oziroma levega) otroka. Na tej točki iskanje uporablja #u.jump# za skok do lista 
#v#, ki se nahaja v #BinaryTrie# in vrne ali #v# ali pa svojega naslednika v povezanem seznamu listov. #XFastTrie# pohitri proces iskanja z uporabo binarnega iskanja
\index{binary search}%
na nivojih trie za lociranje vozlišča #u#.

Za uporabo binarnega iskanja moramo izvedeti ali je vozlišče #u#, ki ga iščemo, nad določenim nivojem #i# 	ali pod nivojem #i#.  Ta informacija je podana prvimi #i# biti binarnega zapisa #x#; ti biti določajo iskalno pot, ki jo naredi #x# od korena do nivoja #i#. Na primer sklicujoč na \figref{xfast-path}; na sliki je zadnje vozlišče #u# na iskalni poti za število 14 (katerga binarni zapis je 1110) označeno z $11{\star\star}$ na nivoju 2, ker na nivoju tri ni nobenega vozlišča označenega z
$111{\star}$.  Tako lahko označimo vsako vozlišče na nivoju #i#
z #i#-bitnim celim številom. Tako bi bilo vozlišče #u#, ki ga iščemo, na nivoju ali nižje od nivoja #i#, če in samo če obstaja vozlišče na nivoju #i#
čigar oznaka se sovpada z prvimi #i# biti binarnega zapisa #x#.
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/xfast-path}
  \end{center}
  \caption{Ker na sliki ni vozlišča označenega z $111\star$ se iskalna pot za 14 (1110) konča pri vozlišču  $11{\star\star}$ .}
  \figlabel{xfast-path}
\end{figure}

Pri #XFastTrie# za vsak $#i#\in\{0,\ldots,#w#\}$ shranjujemo vsa vozlišča na nivoju #i# v #USet# #t[i]#, ki je implementiran kot razpršilna tabela (\chapref{hashing}). Uporaba #USet# nam omogoča preverjanje v konstantnem času, če obstaja vozlišče na nivoju #i#, ki se sovpada s prvimi #i# biti #x#. V bistvu lahko to vozlišče najdemo z uporabo
\javaonly{#t[i].find(x>>>(w-i))#}%
\cpponly{#t[i].find(x>>(w-i))#}%

Razpršilne tabele $#t[0]#,\ldots,#t[w]#$ nam omogočajo binarno iskanje za iskanje #u#. Vemo, da se #u# nahaja na nekem nivoju #i# z
$0\le #i#< #w#+1$. Tako torej inicializiramo $#l#=0$ in $#h#=#w#+1$
in ponavljajoče gledamo v razpršilno tabelo #t[i]# kjer $#i#=\lfloor
(#l+h#)/2\rfloor$. Če $#t[i]#$ vsebuje vozlišče katerega oznaka se sovpada z
 #i# prvimi biti #x# določimo #l=i# (#u# je na nivoju ali nižje od nivoja 
#i#); v nasprotnem primeru določimo #h=i# (#u# je nižje od nivoja #i#). Ta proces se konča ko $#h-l#\le 1$  , ko lahko sklepamo, da je #u# na nivoju #l#. Potem zaključimo #find(x)# operacijo z uporabo #u.jump#
in dvojno povezanega seznama listov.
\codeimport{ods/XFastTrie.find(x)}
Vsaka iteracija #while# zanke v zgornji metodi zmanjša #h-l#
za približno faktor ali dva, tako da ta zanka najde #u# po $O(\log #w#)$
iteracijah. Vsaka iteracija opravi konstantno količino dela in eno
#find(x)# operacijo v #USet#, ki porabi konstanten čas. Preostanek dela zavzame samo konstanten čas. Tako #find(x)#
methoda v #XFastTrie# potrebuje samo $O(\log#w#)$ časa.

Metodi #add(x)# in #remove(x)# za #XFastTrie# sta skoraj identični enakim metodam v #BinaryTrie#. Edina razlika je upravljanje z razpršilnimi tabelami #t[0]#,\ldots,#t[w]#. Ob izvajanju operacije
#add(x)#, ko je ustvarjeno novo vozlišče na nivoju #i#, je potem to vozlišče dodano v #t[i]#. Ob izvajanju #remove(x)# operacije, ko je vozlišče odstranjeno z nivoja #i#, je potem to vozlišče odstranjeno iz #t[i]#. Ker vstavljanje in brisanje iz razpršilne tabele traja konstanten čas, to ne poveča časa izvajanja #add(x)# in #remove(x)# za več kot konstanten faktor. Koda za #add(x)# in #remove(x)#
je izpuščena, ker je skoraj identična (dolgi) kodi, ki se nahaja v implementaciji operacij za #BinaryTrie#.

Sledeči teorem povzame delovanje #XFastTrie#:

\begin{thm}
#XFastTrie# implementira #SSet# vmesnik za #w#-bitna cela števila. 
#XFastTrie# podpira operacije
\begin{itemize}
\item #add(x)# in #remove(x)# v času $O(#w#)$ na operacijo in
\item #find(x)# v času $O(\log #w#)$ na operacijo
\end{itemize}
Prostorska zahtevnost #XFastTrie#, ki shrani #n# vrednosti je $O(#n#\cdot#w#)$.
\end{thm}

\section{#YFastTrie#: Dvokratni-Logaritmični Čas #SSet#}
\seclabel{yfast}

#XFastTrie# je velika, celo eksponentna, izboljšava #BinaryTrie# 
v kategoriji poizvedbenega časa, vendar operaciji #add(x)# in #remove(x)# še
nista veliko hitrejši. Poleg tega je poraba prostora $O(#n#\cdot#w#)$
večja kot pri drugih #SSet# implementacijah, predstavljenih v tej knjigi, ki 
uporabljajo $O(#n#)$ prostora. Možno je, da sta ta dva problema med sabo povezana; če #n#
#add(x)# operacij gradi strukturo velikosti $#n#\cdot#w#$, potem operacija #add(x)# potrebuje vsaj #w# časa (in prostora) na operacijo.

\index{YFastTrie@#YFastTrie#}%
#YFastTrie#, o katerem bomo govorili naprej, izboljša hkrati porabo prostora in hitrosti #XFastTrie#. #YFastTrie# uporablja #XFastTrie#, #xft#,
a le shranjuje $O(#n#/#w#)$ vrednosti v #xft#. Na ta način #xft#
v celoti uporabi samo $O(#n#)$ prostora. Poleg tega je samo ena od vseh
#w# operacij #add(x)# ali #remove(x)# v #YFastTrie# enaka operaciji #add(x)# ali
#remove(x)# v #xft#. Na tak način je povprečna zahtevnost nastalih
klicev na #xft# operacije #add(x)# in #remove(x)# konstantna.

Tako se lahko vprašamo: če #xft# shranjuje samo #n#/#w# elementov, kam gre
preostalih $#n#(1-1/#w#)$ elementov? Ti elementi se shranijo v 
\emph{secondary structures},
\index{secondary structure}%
v tem primeru je to podaljšana verzija
treaps (\secref{treap}). Obstaja približno #n#/#w# takšnih pomožnih 
struktur -- tako v povprečju vsaka shranjuje $O(#w#)$ primerov. Treaps so podprte z operacijami v logaritmičnem času #SSet#, tako pa bodo operacije treaps
delale s časom $O(\log #w#)$, kot je to potrebno.

Če govorimo bolj konkretno, #YFastTrie# vsebuje #XFastTrie#, #xft#, ki vsebuje naključne 
primere podatkov, kjer se vsak element pojavi v primerih neodvisno z verjetnostjo
$1/#w#$. Zaradi prikladnosti je vrednost $2^{#w#}-1$ vedno vsebovana v #xft#. Naj 
$#x#_0<#x#_1<\cdots<#x#_{k-1}$ označuje elemente, ki so vsebovani v #xft#.
Povezan z vsakem elementom $#x#_i$ je treap $#t#_i$, ki shranjuje vse vrednosti
v dosegu $#x#_{i-1}+1,\ldots,#x#_i$. To je ilustrirano na \figref{yfast}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/yfast}
  \end{center}
  \caption[A YFastTrie]{A #YFastTrie# containing the values 0, 1, 3, 4,
  6, 8, 9, 10, 11, and 13.}
  \figlabel{yfast}
\end{figure}

#find(x)# operacija v #YFastTrieX# je dokaj enostavna. V #xft# iščemo #x# in
najdemo nekaj vrednosti $#x#_i$ povezanih z treap $#t#_i$. Potem uporabimo metodo treap 
#find(x)# na $#t#_i$ za odgovor na poizvedbo. Ta metoda se lahko v celoti
zapiše v eni vrstici:
\codeimport{ods/YFastTrie.find(x)} 
Prva #find(x)# operacija (na #xft#) vzame $O(\log#w#)$ časa.
Druga #find(x)# operacija (nad treap) vzame $O(\log r)$ časa, kjer je
$r$ velikost treap.  Kasneje v tem razdelku, bomo pokazali,da
je pričakovana velikost treap $O(#w#)$ torej ta operacija vzame
$O(\log #w#)$ časa.\footnote{To je aplikacija \emph{Jensenove neenakosti}: If $\E[r]=#w#$, then $\E[\log r]
\le \log w$.}

Dodajanje elementa v  #YFastTrie# je tudi dokaj preprosto---večino
časa. #Add(x)# metoda pokliče  #xft.find(x)# ta alocira treap,
#t#, v katerega bo #x# lahko vstavljen.  Ta potem pokliče #t.add(x)# za
dodajanje #x# k #t#.  Pri tej točki, meče nepristranski kovanec katerih
glave pridejo z verjetnostjo $1/#w#$ in tudi repi z verjetnostjo $1-1/#w#$.
Če na kovancu dobimo glave, potem bo #x# dodan k #xft#.

Tukaj stvari postanejo malce bolj zapletene.  Ko je #x# dodan k
#xft#, mora biti treap #t# razdeljeno na dva treaps, #t1# in #t'#.
Treaps #t1# vsebuje vse vrednosti manjše ali enake od #x#;
#t'# je prvotno treap, #t#, z vsemi odstranjenimi elementi #t1#.
Ko je to narejeno, dodamo par #(x,t1)# k #xft#.  \figref{yfast-add}
prikazuje primer.
\codeimport{ods/YFastTrie.add(x)}
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/yfast-add}
  \end{center}
  \caption[Adding to a YFastTrie]{Dodajanje vrednosti 2 in 6 v  #YFastTrie#. Pri metu kovanca
    za 6 pridejo glave, torej je bila 6 dodana k #xft# in treap, ki je vsebovalo
    $4,5,6,8,9$ je bilo razdeljeno.}
  \figlabel{yfast-add}
\end{figure}
Dodajanje #x# k #t# vzame $O(\log #w#)$ časa. \excref{treap-split} prikazuje, da
je razdelitev #t# v #t1# in #t'# lahko narejena v $O(\log #w#)$
pričakovanem času. Dodajanje para (#x#,#t1#) k #xft# vzame $O(#w#)$ časa,
ampak se zgodi samo z verjetnostjo $1/#w#$.  Zato je, pričakovan 
čas poteka #add(x)# operacije
\[
    O(\log#w#) + \frac{1}{#w#}O(#w#) = O(\log #w#) \enspace .
\]

#Remove(x)# metoda razveljavi delo,ki se izvede z #add(x)#.
#xft# uporabimo, da najdemo list #u#, in #xft#, ki vsebuje odgovor
za #xft.find(x)#.  Iz #u#, dobimo treap, #t#, ki vsebuje #x#
in ta #x# odstrani iz #t#.  Če je bil #x# shranjen v #xft# (in #x#
ni enak $2^{#w#}-1$) potem odstranimo #x# iz #xft# in dodamo 
elemente iz #x#-tega treap v treap, #t2#, ki je shranjen v #u#-tem
nasledniku v povezanem seznamu.   To je prikazano v 
\figref{yfast-remove}.
\codeimport{ods/YFastTrie.remove(x)}
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/yfast-remove}
  \end{center}
  \caption[Removing from a YFastTrie]{Odstranjevanje vrednosti 1 in 9 iz #YFastTrie# in \figref{yfast-add}.}
  \figlabel{yfast-remove}
\end{figure}
Iskanje člena #u# in #xft# vzame $O(\log#w#)$ pričakovanega časa.
Odstranjevanje #x# iz #t# vzame $O(\log#w#)$ pričakovanega časa.  Spet,
 \excref{treap-split} prikazuje, da je združevanje vseh elementov #t# v
#t2# lahko storjena v $O(\log#w#)$ času.  Če je potrebno, odstranjevanje #x#
iz #xft# vzame $O(#w#)$ časa, toda #x# je vsebovan v #xft# z
verjetnostjo $1/#w#$.  Zato je pričakovan čas odstranjevanja elementa iz #YFastTrie# enak $O(\log #w#)$.

Prej v razpravi smo prestavili debato o velikosti poddreves znotraj te strukture. Pred zaključkom poglavja smo dokazali potreben rezultat.

\begin{lem}\lemlabel{yfast-subtreesize}
Naj bo #x# celo število shranjeno v #YFastTrie#, spremenljivka $#n#_#x#$
pa naj predstavlja število elementov v poddrevesu #t#, ki vsebuje #x#.
Velja $\E[#n#_#x#] \le 2#w#-1$.
\end{lem}

\begin{proof}
Omenjeno v \figref{yfast-sample}. Naj
$#x#_1<#x#_2<\cdots<#x#_i=#x#<#x#_{i+1}<\cdots<#x#_#n#$ opisuje
elemente shranjene
v #YFastTrie#. Poddrevo #t# vsebuje nekatere elemente večje kot,
ali enake #x#. Ti elementi so $#x#_i,#x#_{i+1},\ldots,#x#_{i+j-1}$,
kjer je $#x#_{i+j-1}$ edini od teh elementov, pri katerem je met kovanca izveden v metodi #add(x)# vrnil grb.
Z drugimi besedami, $\E[j]$ je pričakovano število metov kovanca, ki jih potrebujemo, da pridobimo prvi grb.
\footnote{Ta analiza ignorira
dejstvo, da $j$ nikoli ne preseže $#n#-i+1$. Kakorkoli, to zgolj zmanjša vrednost
$\E[j]$, zgornja meja pa je še vedno enaka.} Vsak met kovanca je neodvisen, grb se pojavi z vrjetnostjo $1/#w#$, velja $\E[j]\le#w#$.
(Oglej si \lemref{coin-tosses} za analizo primera $#w#=2$.)

Podobno, elementi #t#, ki so manjši kot #x# so 
$#x#_{i-1},\ldots,#x#_{i-k}$, kjer se je v vseh $k$ metov kovanca pojavila cifra, in met kovanca $#x#_{i-k-1}$ predstavlja grb.  Torej velja,
$\E[k]\le#w#-1$, ker je to isto metanje kovanca glede na prejšnji odstavek, vendar v tem primeru zadnji met ni bil štet.
V povzetku $#n#_#x#=j+k$, torej velja
\[  \E[#n#_#x#] = \E[j+k] = \E[j] + \E[k] \le 2#w#-1 \enspace .  \qedhere \]
\end{proof}
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/yfast-sample}
  \end{center}
  \caption[The query time in a YFastTrie]{Število elementov v poddrevesu #t#, ki vsebujejo #x# je določeno z metanjem dveh kovancev.}
  \figlabel{yfast-sample}
\end{figure}
%Surprisingly, the bound in \lemref{yfast-subtreesize} is tight.  (If this
%isn't surprising to the reader, they can stop reading this paragraph now.)
%This is counterintuitive because #xft# contains any particular element
%with probability $1/#w#$ so it contains about $n/#w#$ elements.  In other
%words, the average number of elements assigned to one treap is #w#.
%\lemref{yfast-subtreesize} says that the expected size of the treap that
%contains #x# is about twice as large as the average.  This seeming
%discrepancy comes from the fact that larger subtrees contain more elements
%and therefore #x# is more likely to be in a larger subtree than a smaller
%one.

\lemref{yfast-subtreesize} Je zadnji del v dokazu teorema, ki povzema učinkovitost #YFastTrie#:

\begin{thm}
#YFastTrie# impelementira #SSet# vmestnik za #w#-bitna cela števila.
#YFastTrie# podpira operacije #add(x)#, #remove(x)#, in #find(x)#
v pričakovanem času $O(\log #w#)$ na operacijo. Prostor, ki ga 
#YFastTrie# porabi za hrambo #n# vrednosti je $O(#n#+#w#)$.
\end{thm}

Dodaten člen w pri prostorski zahtevnosti prihaja iz dejstva, da #xft# vedno hrani vrednost $2^#w#-1$. Implementacija je lahko drugačna (v zakup moramo vzeti dodajanje kode) in ni potrebno hraniti te vrednosti. V tem primeru prostorska zahtevnost teorema postane $O(#n#)$.

\section{Razprava in vaje}

Prvo podaktovno strukturo, ki zagotavlja časovno zahtevnost $O(\log#w#)$ za operacije #add(x)#,
#remove(x)#, in #find(x)# je predlagal van~Emde~Boas in
je od takrat poznana kot \emph{van~Emde~Boas}
\index{van Emde Boas drevo}%
(or \emph{razslojeno})
\index{razslojeno drevo}%
\emph{drevo} \cite{e77}.  Prvotna van~Emde~Boas struktura je imela velikost
$2^{#w#}$ in je bila zato nepraktična za večja cela števila.

Podatkovni strukturi #XFastTrie# in #YFastTrie# je odkril Willard \cite{w83}.  
Struktura #XFastTrie# je močno povezana z drevesom
van~Emde~Boas; na primer, razpršene tabele v #XFastTrie#
nadomestijo matrike v drevesu van~Emde~Boas. To pomeni, da drevo van~Emde~Boas hrani 
matriko dolžine $2^{#i#}$ namesto razpršene tabele #t[i]#.

Druga struktura za hranitev celih števil so Fredman in Willardova fuzijska
drevesa \cite{fw93}.
\index{fuzijsko drevo}%
Ta struktura lahko hrani #n# #w#-bitnih števil v prostoru
$O(#n#)$ tako, da se operacija #find(x)# izvede v času $O((\log #n#)/(\log
#w#))$.  S kombinacijo fuzijskih dreves, ko je $\log #w# > \sqrt{\log #n#}$ in
#YFastTrie#, ko je $\log #w# \le \sqrt{\log #n#}$, pridobimo prostorno podatkovno strukturo
 $O(#n#)$, ki lahko implementira operacijo #find(x)# v času
$O(\sqrt{\log #n#})$.  Nedavni rezultati spodnje meje P\v{a}tra\c{s}cu
in Thorup \cite{pt07} kažejo na to, da so ti rezultati bolj ali manj optimalni, 
vsaj kar se tiče struktur, ki porabijo le $O(#n#)$ prostora.

\begin{exc}
  Sestavi in implementiraj poenostavljeno različico #BinaryTrie#, ki
  nima kazalcev povezanega seznama ali skakalnih kazalcev, operacija #find(x)# 
  pa teče v $O(#w#)$ času.
\end{exc}

\begin{exc}
  Sestavi in izpelji poenostavljeno implementacijo #XFastTrie#,
  ki ne uporablja dvojiškega drevesa. Namesto tega naj vaša implementacija 
  vse hrani v dvojno povezanem seznamu in v $#w#+1$
  razpršenih tabelah.
\end{exc}

\begin{exc}
  #BinaryTrie# si lahko predstavljamo kot strukturo, ki hrani bitne nize
  dolžine #w# na tak način, da je vsak bitni niz predstavljen kot pot, od 
  korena do lista.  Uporabite to idejo pri izvedbi #SSet#, ki hrani
  nize spremenljive dolžine in implementira #add(s)#, #remove(s)#,
  in #find(s)# v času sorazmernem dolžini #s#.

  \noindent Namig: Vsako vozlišče v vaši podatkovni strukturi naj hrani
  razpršeno tabelo, ki je indeksirana z vrednostjo znaka.
\end{exc}

\begin{exc}
  Za število $#x#\in\{0,\ldots2^{#w#}-1\}$, kjer $d(#x#)$ pomeni
  razliko med #x# in vrednostjo, ki jo vrne #find(x)#
  [če #find(x)# vrne #null#, potem določi $d(#x#)$ kot $2^#w#$].
  Na primer, če #find(23)# vrne 43, potem $d(23)=20$.
  \begin{enumerate}
    \item Sestavi in implementiraj spremenjeno različico operacije #find(x)#
      v #XFastTrie#, ki se izvaja v času $O(1+\log d(#x#))$. 
      Nasvet: Razpršena tabela $t[#w#]$ vsebuje vse
      vrednosti, #x#, kot so $d(#x#)=0$, torej bi bilo tu najbolje začeti.
    \item Sestavi in implementiraj spremenjeno različico operacije #find(x)#
      v #XFastTrie#, ki se izvaja v času $O(1+\log\log d(#x#))$.
  \end{enumerate}
\end{exc}


