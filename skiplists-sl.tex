\translatedby{Hristijan Vasileski}{sl}
\translatedby{Jan Štrekelj}{sl}
\chapter{Preskočni seznami}

\chaplabel{skiplists}

V tem poglavju bomo razpravljali o lepi podatkovni strukturi: preskočnem seznamu, ki ima različne možnosti uporabe.  Uporaba preskočnega seznama lahko  izvajamo
#List# ki ima $O(\log n)$ časovno implementacijo #get(i)#, #set(i,x)#,
#add(i,x)#, and #remove(i)#. Prav tako lahko izvaja #SSet# v katerem so vsi postopki vodijo v $O(\log #n#)$ pričakovanega časa.
%Nazadnje je preskočni seznam lahko uporabljen za implementacijo #Rope# kjer se vse operacije izvedejo v
%operations run in $O(\log #n#)$ time.

Učinkovitost preskočnega seznama je povezana z njegovo naključnostjo.  Ko je nov element dodan preskočnemu seznamu , preskočni seznam  uporabi metodo metanja kovanca,  da se določi višino novim elementom. Uspešnost preskočnega seznama je odvisna od pričakovanih izvajanj  in dolžine poti. To pričakovanje pa je povezano z uporabo metode meta kovanca. Implementacija metode meta kovanca se simulira z uporabo namenskega generatorja.

\section{Osnovna struktura}

\index{preskočni seznam}%
Konceptualno je preskočni seznam  sekvenca  posamezno povezanih seznamov
$L_0,\ldots,L_h$. Vsak seznam $L_r$ vsebuje podniz elementov v
 $L_{r-1}$.  Začnimo z vhodnim seznamom $L_0$ ki vsebuje #n#
elementov in naredimo $L_1$ iz $L_0$, $L_2$ iz $L_1$, in tako naprej.
Elementi v $L_r$ so pridobljeni z metanjem kovanca za vsak element, #x#,
v $L_{r-1}$ in dodajo #x# v $L_r$ če kovanec "pokaže" glavo.
Ta postopek se ponavlja, dokler ne naredimo praznega seznama $L_r$.  
Primer preskočnega seznama je prikazan na sliki \figref{skiplist}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist}
  \end{center}
  \caption{Preskočni seznam s sedmimi elementi.}
  \figlabel{skiplist}
\end{figure}

Za vsak element, #x#, v preskočnem seznamu imenujemo \emph{višina}
\index{height!of a skiplist}%
of #x# največjo 
vrednost $r$ kjer se #x# pojavi v $L_r$.  Tako na primer 
imajo elementi, ki se pojavljajo samo v $L_0$ višino $0$.  Če pomislimo, 
ugotovimo, da je višina #x# ustreza naslednjemu eksperimentu:
  Mečimo kovanec večkrat dokler pada cifra.
  Kolikokrat je pokazal glavo?  Odgovor, ne presenetljivo, je, 
  da je pričakovana višina vozlišča enaka 1.
  Pričakovali smo, da bomo kovanec vrgli dvakrat, da dobimo cifro, vendar nismo šteli zadnjega meta.) 
  The \emph{Višina} preskočnega seznama je višina njegovega najvišjega vozlišča.

Na koncu vsakega seznama je posebno vozlišče, imanovano \emph{stražar},
\index{sentinel node}
ki predstavlja statista za seznam. Glavna lastnost preskočnega seznama je, 
da obstaja kratka pot, imanovana \emph{pot iskanja}, 
\index{search path!in a skiplist}
od stražarja v
 $L_h$ do vsakega vozlišča v $L_0$.  Narediti pot iskanja za posamezno vozlišče,
 #u#, je preprosto (pogledaj \figref{skiplist-searchpath})
:  Začnemo v zgornjem levem kotu preskočnega seznama (stražar je v $L_h$)
in se premikamo desno toliko časa, dokler ne gremo preko vozlišča #u#, 
nato pa se premaknemo korak nižje v spodnji seznam.

Natančneje, za izdelati pot iskanja za vozlišče #u# v $L_0$,
začnemo pri stražarju, #w#, v $L_h$.  Nato izvedemo #w.next#.
Če #w.next# vsebuje element, ki se pojavi pred #u# v $L_0$, nastavimo $#w#=#w.next#$.  sicer se premaknemo navzdol in nadaljujemo iskanje pojavitve
 #w# v seznamu $L_{h-1}$.  Postopek ponavljamo dokler na dosežemo predhodnika od
 #u# v $L_0$. 
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-searchpath}
  \end{center}
  \caption{Iskanje poti za vozlišče, ki vsebuje $4$ v preskončnem seznamu.}
  \figlabel{skiplist-searchpath}
\end{figure}

Rešitev, ki si jo bomo podrobneje pogledali v \secref{skiplist-analysis},
am pokaže, da je pot iskanja dokaj kratka:

\begin{lem}\lemlabel{skiplist-searchpath}
Pričakovana dolžina poti iskanja  za vsako vozlišče, #u#, v $L_0$ je največ
 $2\log #n# + O(1) = O(\log #n#)$.
\end{lem}

Prostorsko učinkovit način za implementacijo preskočnega seznama je ta, da definiramo #Vozlisce#,
#u#, ki je sestavljen iz podatka, #x#, in polja kazalcev, #next#, kjer
 #u.next[i]# pokaže na naslednika #u#'ja v seznamu
$L_{#i#}$.  Na ta način je podatek, #x#, v vozlišču
\javaonly{referenced}\cpponly{stored} 
samo enkrat, čeprav se #x# pojavlja v različnih seznamih.

\javaimport{ods/SkiplistSSet.Node<T>}
\cppimport{ods/SkiplistSSet.Node}

V naslednjih dveh podpoglavjih tega poglavja bomo govorili o dveh različnih uporabah preskočnih seznamov.
  Pri obeh je, $L_0$ shranjena glavna 
  struktura (seznam elementov ali sortiran niz elementov).
Glavna razlika med temi dvemi strukturami je v načinu premikanja po poti iskanja; drugače povedano, 
razlikujeta se v tem, kako se odločajo, 
ali gre pot iskanja do $L_{r-1}$ ali le do $L_r$.

\section{#SkiplistSSet#: Učinkovit #SSet#}
\seclabel{skiplistset}

\index{SkiplistSSet@#SkiplistSSet#}%
  #SkiplistSSet# uporablja preskočni seznam za implementirati #SSet#
vmesnik.   Ko ga uporabljamo na ta način, so v seznamu $L_0$ shranjeni elementi
 #SSet#-a v urejenem vrstnem redu.  Metoda #find(x)# deluja tako, da sledi poti iskanja za najmanjšo vrednostjo
 #y# kjer je $#y#\ge#x#$:

\codeimport{ods/SkiplistSSet.find(x).findPredNode(x)}

Sledenje poti iskanja za #y# je preprosto:  ko se nahajamo v določenem vozlišču, 
#u#, v  $L_{#r#}$, pogledamo v desno z #u.next[r].x#.
Če je $#x#>#u.next[r].x#$, se premaknemo za eno mesto v desno v
$L_{#r#}$; sicer se premaknemo navzdol v $L_{#r#-1}$.  Vsak korak (desno ali navzdol) v takem iskanju potrebuje konstanten čas; 
potemtakem, po
\lemref{skiplist-searchpath}, je pričakovani čas izvajanja #find(x)#
enak $O(\log #n#)$.

Preden lahko dodamo element v #SkipListSSet#, potrebujemo metodo, ki nam bo simulirala met kovanca za določitev višine,
 #k#, novega vozlišča.
To naredimo tako, da si izberemo poljubno število, #z#, in štejemo število zaporednih enic $1$s v binarnem zapisu števila
   #z#:\footnote{Ta metoda
   ne ponazarja popolnoma eksperiment metanja kovanca saj bo vrednost
#k# vedno manjša od števila bitov v #int#.  However,
Kakorkoli, to bo imelo malenkosten vpliv dokler ne bo število elementov v strukturi veliko 
večje kot $2^{32}=4294967296$.}

\codeimport{ods/SkiplistSSet.pickHeight()}

Za implementirati metodo #add(x)# v #SkiplistSSet# smo najprej poiskali #x#
in ga nato dodali v več seznamov  $L_0$,\ldots,$L_{#k#}$, kjer je #k#
izbran  s pomočjo #pickHeight()# metode. Najlažji način za narediti 
to je s pomočjo polja, #stack#, ki hrani sled vozlišč, kjer se je pot iskanja spustila iz seznama
 $L_{#r#}$ v $L_{#r#-1}$.
Natančneje, #stack[r]# je vozlišče v $L_{#r#}$ kjer se je pot iskanja nadaljevala en nivo nižje, v seznamu $L_{#r#-1}$.  
Vozlišča, ki smo jih prilagodili za vstaviti #x#
so točno vozlišča $#stack[0]#,\ldots,#stack[k]#$.  Koda 
v nadaljevanju prikazuje implementacijo algoritma za #add(x)#:
\label{pg:skiplist-add}
\codeimport{ods/SkiplistSSet.add(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-add}
  \end{center}
  \caption[Adding to a skiplist]{Dodajanje vozlišča $3.5$ v preskočni seznam.  Vozlišča shranjena v #stack#
  so označena.}
  \figlabel{skiplist-add}
\end{figure}

Brisanje elementa, #x#, je podobno vstavljanju, e da pri tej metodi
 ni potrebe po #stack# za hranjenje poti iskanja.  Brisanje
 je lahko opravljeno s sledenjem poti iskanja.  Ko iščemo #x#
vedno ko se premaknemo korak navzdol iz vozlišča #u#, preverimo, če je
$#u.next.x#=#x#$ in če je, odstranimo #u# iz seznama:
\codeimport{ods/SkiplistSSet.remove(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-remove}
  \end{center}
  \caption{Brisanje vozlišča $3$ iz preskočnega seznama.}
  \figlabel{skiplist-remove}
\end{figure}

\subsection{Povzetek}

Naslednji teorem povzema uporabnost preskočnega seznama, 
ko ga uporabljamo za implementacijo sortiranih nizov:

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet# je uporabljen za implementacijo #SSet# vmesnika.  #SkiplistSSet# opravi  
operacije #add(x)# (dodaj), #remove(x)# (odstrani), and #find(x)# (najdi) v $O(\log #n#)$
pričakovanega časa za operacijo.
\end{thm}

\section{#SkiplistList#: Učinkovit naključni dostop #List# (seznam)}
\seclabel{skiplistlist}

\index{SkiplistList@#SkiplistList#}%
 #SkiplistList# implementira vmesnik #List# z uporabo preskočnega seznama.
 V  #SkiplistList#, $L_0$ vsebuje elemente seznama v istem zaporedju, kot so ti razvrščeni v seznamu.
 Tako kot v 
#SkiplistSSet#, lahko elemente dodajamo, brišemo ali do njih dostopamo v $O(\log
#n#)$ časa.

Da to lahko dosežemo, je potrebno najti iskalno pot do 
 #i#-tega  elementa v $L_0$.  Najlažji način je opredeliti pojem
 \emph{dolžine} nivoja v nekem seznamu $L_{#r#}$.
Vsak nivo v seznamu $L_{0}$ definiramo kot 1.  Dolžina nivoja, #e#,
v $L_{#r#}$, $#r#>0$, je definirana kot vsota dolžin nivojev, ki so pod #e#
v $L_{#r#-1}$.  Dolžina #e#-ja je ekvivalenčna
številu nivojev v $L_0$, ki so pod #e#.  Poglej \figref{skiplist-lengths} za
 primer preskočnega seznama z dolžino njegovih nivojev.  Ker so nivoji preskočnega seznama shranjeni v tabelah, lahko na enak način      shranjujemo tudi dolžino:

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-lengths}
  \end{center}
  \caption{Dolžine robov v preskočni seznam.}
  \figlabel{skiplist-lengths}
\end{figure}

\codeimport{ods/SkiplistList.Node}

Uporabna lastnost opredelitve dolžin je, da če smo trenutno v vozlišču, 
ki se nahaja na poziciji #j# v $L_0$ in sledimo nivoju 
dolžine $\ell$, se potem premaknemo v vozlišče, ki se nahaja na mestu $#j#+\ell$ v seznamu $L_0$.
Tako lahko, ko sledimo iskalni poti, ohranjamo
vrednost pozicije, #j#, trenutnega vozlišča v $L_0$.  Ko smo v vozlišču,
 #u#, v $L_{#r#}$, gremo desno če #j# plus dolžina nivoja
#u.next[r]# manj kot #i#. V nasprotnem primeru, se pomaknemo navzdol v $L_{#r#-1}$.

\codeimport{ods/SkiplistList.findPred(i)}
\codeimport{ods/SkiplistList.get(i).set(i,x)}

Ker je najtežji del operacij #get(i)# in #set(i,x)# iskanje
 #i#-tega vozlišča v $L_0$, se operacije izvedejo v
$O(\log #n#)$ časa.

Dodajanje elementa v #SkiplistList# na pozicijo, #i#, je enostavno.
  Za razliko dodajanje od #SkiplistSSet#, vemo da bo vozlišče
dejansko dodano, zato lahko hkrati dodajamo in iščemo lokacijo za  novo  
vozlišče. Najprej izberemo višino, #k#,
novega vozlišča, #w#, nato sledimo iskalni poti #i#.
Vsakič ko se iskalna pot premakne navzdol od $L_{#r#}$ z $#r#\le #k#$, spojimo #w# v $L_{#r#}$.  Dodatno moramo biti pozorni, da se dolžina nivojev
pravilno osvežuje.  Poglej \figref{skiplist-addix}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-addix}
  \end{center}
  \caption[Adding to a SkiplistList]{Adding an element to a #SkiplistList#.}
  \figlabel{skiplist-addix}
\end{figure}

Pozorni moramo biti, da vsakič ko se iskalna pot v vozlišču premakne nivo nižje, #u#, v $L_{#r#}$,
se dolžina nivoja #u.next[r]# poveča za ena, ker dodajamo element pod nivo na poziciji #i#.
  Spoj vozlišča #w# med vozlišča,
#u# in#z#, deluje kot je prikazano v \figref{skiplist-lengths-splice}. Ko sledimo iskalni poti, shranjujemo tudi pozicijo,
#j#, od #u# v $L_0$.  Zato, vemo da je dolžina nivoja od
#u# do #w# enaka $#i#-#j#$.  Sklepamo lahko da je dolžina nivoja 
od #w#  do #z# iz dolžine, $\ell$, od nivoja  #u# do #z#.
Potemtakem, lahko spojimo v #w# in osvežimo dolžine nivojev v konstantnem času.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/skiplist-lengths-splice}
  \end{center}
  \caption[Adding to a SkiplistList]{Posodabljanje dolžine nivojev, med spajanjem vozlišča  
   #w# v preskočni seznam.}
  \figlabel{skiplist-lengths-splice}
\end{figure}

Postopek izgleda veliko bolj kompleksen kot v resnici je. Koda je pravzaprav zelo enostavna:

\codeimport{ods/SkiplistList.add(i,x)}
\codeimport{ods/SkiplistList.add(i,w)}


Do sedaj bi vam morala biti implementacija #remove(i)# operacije v #SkiplistList# jasna. Sledimo iskalni poti vozlišča na poziciji #i#.  Vsakič ko se iskalna pot zmanjša za ena od vozlišča, #u#, na nivoju #r# zmanjšamo dolžino nivoja, ki izstopa iz #u#-ja na tistem nivoju.  Pregledati moramo tudi, da je #u.next[r]# element ranga #i# in v kolikor drži, ga premaknemo iz seznama na tisti nivo.   Primer si lahko ogledate tukaj \figref{skiplist-removei}.
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-removei}
  \end{center}
  \caption[Removing an element from a SkiplistList]{Brisanje elementa iz #SkiplistList#.}
  \figlabel{skiplist-removei}
\end{figure}
\codeimport{ods/SkiplistList.remove(i)}

\translatedby{Tadej Dragutinovič}{sl}
\subsection{Summary}

Naslednji teorem povzema učinkovitost podatkovne strukture #SkiplistList#:

\begin{thm}\thmlabel{skiplistlist}
   #SkiplistList# izvede vmesnik #List#.  #SkiplistList#
  podpira operacije #get(i)#, #set(i,x)#, #add(i,x)#, ter
  #remove(i)# v $O(\log #n#)$ pričakovanem času na operacijo.
\end{thm}

%\section{Skiplists as Ropes}
%TODO: A section on ropes

\section{Analiza preskočnega seznama}
\seclabel{skiplist-analiza}

V sledečem delu bomo analizirali pričakovano višino, velikost ter dolžino
Iskalne poti v  preskočnem seznamu.  Za razumevanje potrebujemo osnovno ozadnje 
verjetnosti.  Nekateri dokazi  so osnovani na metu kovanca.


\begin{lem}\lemlabel{met kovanca}
  \index{coin toss}%
  Naj bo $T$ število, kadar se pošten kovanec obrne navzgor, vključno s primerom kadar kovanec pade z glavo navzgor. Takrat $\E[T]=2$.
\end{lem}

\begin{proof}
  Recimo da nehamo metati kovanec prvič kadar pade z glavo navzgor.
 Definirajmo indikacijsko spremenljivko
  \[ I_{i} = \left\{\begin{array}{ll}
     0 & \mbox{če je kovanec vržen navzgor $i$ kar} \\
     1 & \mbox{če je kovanec vržen $i$ ali več krat} 
     \end{array}\right.
  \]
  Upoštevajte da $I_i=1$ če in samo če edini $i-1$ met kovanca postane rep,
  torej $\E[I_i]=\Pr\{I_i=1\}=1/2^{i-1}$.  Opazimo da $T$, vse mete kovanca
  lahko zapišemo kot $T=\sum_{i=1}^{\infty} I_i$.
  Sledi,
  \begin{align*}
    \E[T] & =  \E\left[\sum_{i=1}^\infty I_i\right] \\
     & =  \sum_{i=1}^\infty \E\left[I_i\right] \\
     & =  \sum_{i=1}^\infty 1/2^{i-1} \\
     & =  1 + 1/2 + 1/4 + 1/8 + \cdots \\
     & =  2 \enspace .   \qedhere
  \end{align*} 
\end{proof}

Naslednji hipotezi nam pokažeta da ima preskočni seznam linearno velikost:

\begin{lem}\lemlabel{skiplist-size1}
  Pričakovano število vozlišč v preskočnem seznamu vsebuje $#n#$ elementov,
  če ne upoštevamo kontrolnih pojavljanj,  je $2#n#$.
\end{lem}

\begin{proof}
  Verjetnost, da je  kateri koli element, #x#, vsebovan v seznamu
  $L_{#r#}$ je $1/2^{#r#}$, pričakovano število vozlišč v $L_{#r#}$
  je $#n#/2^{#r#}$.\footnote{Poglej \secref{randomization} za obrazložietv kako pridemo do rezultata z uporabo indikatorja spremenljivk in linearnosti pričakovanja.}
  Sledi, da je skupno število pričakovanih vozlišč v seznamu
  \[ \sum_{#r#=0}^\infty #n#/2^{#r#} = #n#(1+1/2+1/4+1/8+\cdots) = 2#n# \enspace . \qedhere \]
\end{proof}

\begin{lem}\lemlabel{skiplist-height}
  Pričakovana višina preskočnega seznama, ki vsebuje #n# elementov je največ
  $\log #n# + 2$.
\end{lem}

\begin{proof}
  Za vsak $#r#\in\{1,2,3,\ldots,\infty\}$, 
  Definiramo indicator naključnih  spremenljivk
  \[ I_{#r#} = \left\{\begin{array}{ll}
     0 & \mbox{if $L_{#r#}$ je prazen} \\
     1 & \mbox{if $L_{#r#}$ ni prazen}
     \end{array}\right.
  \]
  Višina, #h#, preskočnega seznama je
  \[
       #h# = \sum_{i=1}^\infty I_{#r#} \enspace .
  \]
  Upoštevajte, da $I_{#r#}$ ni nikoli večji kot dolžina, $|L_{#r#}|$, od $L_{#r#}$, zato 
  \[
     \E[I_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
  Zato imamo
  \begin{align*}
       \E[#h#] &= \E\left[\sum_{r=1}^\infty I_{#r#}\right] \\
        &= \sum_{#r#=1}^{\infty} E[I_{#r#}] \\
        &= \sum_{#r#=1}^{\lfloor\log #n#\rfloor} E[I_{#r#}]
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} E[I_{#r#}]  \\
        &\le \sum_{#r#=1}^{\lfloor\log #n#\rfloor} 1
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} #n#/2^{#r#} \\
        &\le \log #n#
                 + \sum_{#r#=0}^\infty 1/2^{#r#} \\
        &= \log #n# + 2 \enspace . \qedhere
  \end{align*}
\end{proof}

\begin{lem}\lemlabel{skiplist-size2}
  Pričakovano število vozlišč v preskočnem seznamu vsebuje $#n#$ elementov,
  z vsemi pojavitvami “opazovalca”, je $2#n#+O(\log #n#)$.
\end{lem}

\begin{proof}
  Po \lemref{skiplist-size1}, sledi da je pričakovano število vozlišč, brez “opazovalca”
  $2#n#$.  Število pojavitev “opaovalca” je enako višini, $#h#$, preskočnega seznama,torej 	
  \lemref{skiplist-height} pričakovano število pojavitev 
   sentinel je največ $\log #n#+2 = O(\log #n#)$.
\end{proof}



\begin{lem}
Pričakovana dolžina iskalne poti v preskočnem seznamu je največ $2\log #n# + O(1)$.
\end{lem}

\begin{proof}
  Najlažje dokažemo hipotezo tako da uporabimo \emph{reverse search
  path} za vozlišče, #x#.  Ta pot začne pri predhodniku #x#
  v $L_0$.  Kadarkoli , če  grelahko  pot eno nadstropje višje takrat lahko.  V kolikor nemore iti eno nadstropje višje, 
  gre levo. Če nekaj trenutkov premišljujemo o 
  tem nas bo prepričalo da je vzvratna iskalna pot za #x# enaka iskalni poti za #x#, z razliko da je vzvratna.

  Število vozlišč, ki obiščejo vzvratno pot v nekem nadstropju,
  #r#, je povezana z naslednjim eksperimentom:  Vržimo kovanec.
  Če pade glava,se premakni navzgor, nato ustavi.
  V nasprotnem primeru se premakni levo in ponovi eksperiment.
  Številov metov kovanca, preden pade glava predstavlja število
  korakov v levo, ki ki jih vzvratna iskalna pot porabi v nekem nadstropju.
  footnote{Bodite pozorni da lahko pride do 
“overcounta” števila korakov na levo, saj se mora  
eksperiment končati. Končati mora ob prvi glavi  
ali ko iskalna pot doseže “opazovalca”,kateri pride prvi.
 To ne predstavlja problema saj leži hipoteza na  zgornji meji.} \lemref{coin-tosses} nam prikazuje da je 
 pričakovano število metov kovanca preden pade prva “glava”, 1.

  Naj $S_{#r#}$ označuje število korakov ki jih porabi iskalna pot naprej na nadstropju
  $#r#$ ki gre desno.   Pravkar smo trdili da $\E[S_{#r#}]\le
  1$.  Poleg tega, $S_{#r#}\le |L_{#r#}|$, ker nemoremo narediti več korakov v
  $L_{#r#}$ kot je dolžina $L_{#r#}$, zato
  \[
    \E[S_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
  Sedaj lahko dokončamo dokaz \lemref{skiplist-height}.
  Naj bo $S$ dolžina iskalne poti nekega vozlišča, #u#, v preskočnem seznamu,  in naj bo  $#h#$ višina preskočnega seznama.  Sledi
  \begin{align*}
      \E[S] 
         &= \E\left[ #h# + \sum_{#r#=0}^\infty S_{#r#} \right] \\
         &= \E[#h#] + \sum_{#r#=0}^\infty \E[S_{#r#}]  \\
         &= \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} \E[S_{#r#}] 
              + \sum_{#r#=\lfloor\log #n#\rfloor+1}^\infty \E[S_{#r#}] \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{r=\lfloor\log #n#\rfloor+1}^\infty #n#/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \log #n# + 3 \\
         &\le 2\log #n# + 5  \enspace . \qedhere
  \end{align*}
\end{proof}


Sledeči teorem povzema rezultat sekcije:
\begin{thm}
Preskočni senam, ki vsebuje $#n#$ elementov je pričakoval velikost $O(#n#)$ in pričakovana dolžina iskalne poti 
nekega elementa je največ $2\log #n# + O(1)$.
\end{thm}



%\section{Ponovitev in Ročno Iskanje}

%TODO:Napiši to sekcijo

\section{Discussion and Exercises}