\chapter{Algoritmi za urejanje}
\chaplabel{sorting}

\translatedby{Rok Samsa}{sl}

Hitro urejanje ali\textit{quicksort} algoritem je še en klasični ``deli in vladaj'' algoritem. V nasprotju z algoritmom zlivanja (mergesort), kateri združuje po rešitvi dveh podproblemov, algoritem hitrega urejanja počne vse svoje delo vnaprej.

\vspace{1em}

Algoritem lahko preprosto opišemo tako: Izberemo naključni delilni element, ki ga imenujemo pivot, x. Dobimo ga iz a; Particija a je sestavljena iz sklopa elementov manjših kot x, sklopa elementov enakih kot x in niz elementov večjih od x; na koncu pa rekurzivno razvrstimo prvi in tretji sklop števil v tej particiji. Primer je prikazan na sliki 11.3.

\vspace{1em}

\centering Slika 11.3: Primer izvedbe algoritma hitrega urejanja (a, 0, 14, c)

\raggedright 

\vspace{1em}

Vse to je narejeno v enem koraku, tako da namesto ustvarjanja kopij urejenih podseznamov, quickSort(a,  i,  n,  c) metoda razvršča samo podseznam a[i],..., a[i + n - 1]. Prvotno kli čemo to metodo kot quickSort(a, 0, a.length, c). 

\vspace{1em}

V središču quicksort algoritma je algoritem delitve na mestu. Ta algoritem, brez uporabe dodatnega prostora, zamenja elemente v a in izračuna indekse p in q tako da:

$$
a[i] \left\lbrace
\begin{array}{ll}
%< x \hspace{1em} \text{č}e \enspace je \enspace 0 \leq 1 \leq p\\
%= x \hspace{1em} \text{č}e \enspace je \enspace p < 1 < q\\
%> x \hspace{1em} \text{č}e \enspace je \enspace q \leq 1 \leq n - 1\\
\end{array}
\right.
$$

\vspace{1em}

Ta delitev, ki se opravi z ``while'' zanko v sami kodi, deluje s ponavljajočim povečanjem p-ja in zmanjševanjem q-ja ob ohranjanju prvega in zadnjega od teh pogojev (p in q). V vsakem koraku element na položaju j je premaknjen levo na prvo mesto, ali pa je premaknjen na zadnje mesto. V prvih dveh primerih, je j povečan, v zadnjem primeru j ni povečan, zato ker nov element na položaju j še ni bil obdelan.

\vspace{1em}

Quicksort algoritem je zelo tesno povezan z naključnim binarnim iskalnim drevesom, opisan v poglavju 7.1. Dejansko, če poženemo quicksort algoritem nad n različnimi elementi, potem je quicksort rekurzivno drevo naključno iskalno drevo. Da bi to videli, se moramo spomniti, kako gradimo naključno binarno iskalno drevo. Najprej naključno izberemo element x in ga postavimo za koren drevesa. Takoj za tem, vsak naslednji element primerjamo z x-om. Manjše elemente postavljamo v levo stran poddrevesa in večje elemente v desno stran poddrevesa.

\vspace{1em}

S tem algoritmom, izberemo nakjučni element x in takoj za tem primerjamo vse s tem x-om. Najmanjše elemente postavimo na začetek polja in večje elemente postavimo na konec polja. Quicksort algoritem nato rekurzivno uredi začetek in konec polja, medtem ko naključno iskalno drevo rekurzivno vstavi manjše elemente v levo poddrevo korena in večje elemente v desno poddrevo korena.

\vspace{1em}

Zgornje ujemanje med naključnim binarnim iskalnim drevesom in algoritmom hitrega urejanja, lahko uporabimo za Lemo 7.1 

\vspace{1em}

\raggedright 
\textbf{Lemma 11.1.} \emph{Ko kličemo algoritem quicksort za urejanje polja, ki vsebuje cela števila} $0,..., n-1$ \emph{pričakovano število primerjav elementa s pivot elementom je} $H_{i+1}+H^{n-i}$.

\vspace{1em}

Malo seštevanja harmoničnih števil nam daje naslednji izrek o času delovanja, katerega porabi algoritem:

\vspace{1em}

\raggedright 
\textbf{Izrek 11.2.} \emph{Ko quicksort algoritem uporabimo za urejanje polja z n različnimi elementi, pričakujemo največje število opravljenih primerjav} 2nlnn +O(n).

\vspace{1em}

\emph{Proof.} Naj bo T število primerjav opravljenih z algoritmom quicksort, ko razvrš ča n razlčne elemente. Z uporabo Leme 11,1, imamo:

\vspace{1em}

Izrek 11.3 opisuje primer, kjer so razvrš čeni elementi vsi različni. Ko vhodna matrika, a, vsebuje podvojene elemente, pričakovani čas delovanja za hitro urejanje ni nič slabši, in je lahko celo boljši; vedno ko je podvojeni element x izbran kot element pivot a, vse pojavitve x-a se združijo in jih kasneje ne vključimo v enem od dveh podproblemov.

\vspace{1em}

\raggedright 
\textbf{Izrek 11.3.} \emph{Quicksort(a, c) metoda ima pričakovani čas izvedbe O ($n log n$) in pričakovano število primerjav, ki jih opravi, je v večini} $2n\ln n$ + \emph{O (}n\emph{).}

