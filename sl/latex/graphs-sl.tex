\chapter{Grafi}
\chaplabel{graphs}
\translatedby{Denis Subotić}{sl}
\translatedby{Luka Colarič}{sl}

%\textbf{Warning to the Reader:} This chapter is still being actively
%developed, meaning that the code has not been thoroughly tested and/or
%the text has not be carefully proofread.

V tem poglavju se bomo naučili dva načina predstavitve grafov in algoritmov, ki uporabljajo te predstavitve.  

Matematično, \emph{(usmerjen) graf}
\index{graph}%
\index{directed graph}%
je par $G=(V,E)$ kjer je
$V$ množica \emph{vozlišč}
\index{vertex}%
in $E$ je množica urejenih parov
vozlišč imenovanih \emph{povezave}.
\index{edge}%
Povezava #(i,j)# je \emph{usmerjena}
\index{directed edge}%
od #i# do #j#;  #i# se imenuje \emph{vir}
\index{source} množice in #j#, ki
se imenuje \emph{tarča}.
\index{target}  \emph{Pot}%
\index{path} v $G$ je zaporedje vozlišč
$v_0,\ldots,v_k$ tako, da za vsak $i\in\{1,\ldots,k\}$,
povezave $(v_{i-1},v_{i})$ so v $E$.  Pot $v_0,\ldots,v_k$ je
\emph{cikel}
\index{cycle}%
če imamo  dodatno še pot $(v_k,v_0)$, ki je v $E$.  Pot (ali
cikel) je \emph{edinstven}
\index{simple path/cycle}%
če so tudi njegova vozlišča edinstvena.  Če je pot
iz neke točke $v_i$ do neke točke $v_j$, potem pravimo, da
je $v_j$ \emph{dosegljiva}
\index{reachable vertex} iz $v_i$.  Primer grafa je prikazan na sliki
\figref{graph}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/graph}
  \end{center}
  \caption{Graf z dvanajstimi vozlišči.  Vozlišča so narisana kot oštevilčeni krogci ter povezave so narisani kot usmerjene krivulje od vira do tarče.}
  \figlabel{graph}
\end{figure}

Zaradi svoje zmogljivosti pri izdelavi modela raznih pojavov, imajo grafi 
ogromno število aplikacij. Obstajajo številni primeri. Računalniška omrežja
lahko modeliramo v nek graf, kjer vozlišča (točke) predstavljajo računalnike in
povezave predstavljajo (direktno) komunikacijsko pot med dvema računalnikoma. 
Tudi ceste v nekem mestu lahko predstavimo kot neki graf, kjer vozlišča predstavljajo
križišča ter povezave predstavljajo ulice.

Primeri, ki so malo manj očitni, se pojavijo ko spoznamo, da grafe lahko modeliramo
v pare kjer nimamo nobenih skupnih odnosov med sabo. Na primer v univerzi imamo lahko  
\emph{konfliktni graf}
\index{conflict graph}%
urnika kjer vozlišča predstavljajo predavanja na univerzi 
in povezava #(i,j)# obstaja samo v primeru, če je prisoten vsaj en študent, ki hodi na predmet 
#i# in na predmet #j#. Tako ena povezava prikaže, da izpit za predmet #i#
ne more na noben način biti načrtovan ob istem času tudi za predmet #j#.

V tem poglavju nam #n# predstavlja število vozlišč v množici $G$ in #m# število 
povezav v množici $G$.  To pomeni, da $#n#=|V|$
in $#m#=|E|$. Poleg vsega tega pa predpostavimo, da je $V=\{0,\ldots,#n#-1\}$.
Za katerekoli druge podatke, ki bi radi povezali z elementi, ki se nahajajo v množici $V$, lahko le-te
shranimo v neko tabelo dolžine $#n#$.

Značilne operacije, ki opravljamo nad grafe so:

\begin{itemize}
  \item #addEdge(i,j)#: Doda povezavo $(#i#,#j#)$ v $E$.
  \item #removeEdge(i,j)#: Zbriši povezavo $(#i#,#j#)$ iz $E$.
  \item #hasEdge(i,j)#: Poišče povezavo $(#i#,#j#)\in E$ 
  \item #outEdges(i)#: Vrne #List# (seznam) celih števil $#j#$od
  $(#i#,#j#)\in E$
  \item #inEdges(i)#: Vrne #List# (seznam) celih števil $#j#$ od
  $(#j#,#i#)\in E$
\end{itemize}

Vedeti je treba, da takšne operacije ni težko implementirati na unčikovit način. Na primer, prve tri
operacije so lahko uporabljene direktno z uporabo #USet#, na tak način, da se lahko izvajajo
v konstantnem pričakovanem času z uporabo razpršenih tabel (predstavljeni v poglavju \chapref{hashing}).
Zadnje dve operaciji pa so lahko implementirane v konstantnem času s shranjevanjem,tako da za vsako vozlišče shranimo še
seznam sosednjih vozlišč.

Vendar različne aplikacije grafov zahtevajo različna delovanja teh operacij
in v idealnem primeru lahko uporabljamo aplikacijo, ki je najbolj enostavna in zadovolji vse zahteve aplikacije.
Zaradi tega razpravljamo o dveh velikih kategorij za predstavljanje grafov.

\translatedby{Uroš Prosenik}{sl}

\section{#AdjacencyMatrix#: Predstavitev grafov z uporabo matrik}
\seclabel{adjacency-matrix}

\index{adjacency matrix}%
\emph{Matrika sosednosti} je način za predstavitev #n# vozlišč grafa
$G=(V,E)$ iz matrike $#n#\times#n#$, #a#, kjer so notranji elementi
tipa "boolean".
\codeimport{ods/AdjacencyMatrix.a.n.AdjacencyMatrix(n0)}

Vnos elemnta matrike #a[i][j]# je definiran kot
\[  #a[i][j]#= 
    \begin{cases}
      #true# & \text{if $#(i,j)#\in E$} \\
      #false# & \text{otherwise}
    \end{cases}
\]
Matrika sosednosti za graf iz slike \figref{graph}, je prikazana na sliki \figref{graph-adj}.

Tu je prikazana operacija #addEdge(i,j)#,
#removeEdge(i,j)# in #hasEdge(i,j)#, ki vrne vrednost elementa #a[i][j]# matrike:

\codeimport{ods/AdjacencyMatrix.addEdge(i,j).removeEdge(i,j).hasEdge(i,j)}
Te operacije vzamejo konstanten čas po operaciji.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/graph} \\[3ex]
    \begin{tabular}{c|cccccccccccc}
        &0&1&2&3&4&5&6&7&8&9&10&11 \\\hline
       0&0&1&0&0&1&0&0&0&0&0&0 &0\\
       1&1&0&1&0&0&1&1&0&0&0&0 &0\\
       2&1&0&0&1&0&0&1&0&0&0&0 &0\\
       3&0&0&1&0&0&0&0&1&0&0&0 &0\\
       4&1&0&0&0&0&1&0&0&1&0&0 &0\\
       5&0&1&1&0&1&0&1&0&0&1&0 &0\\
       6&0&0&1&0&0&1&0&1&0&0&1 &0\\
       7&0&0&0&1&0&0&1&0&0&0&0 &1\\
       8&0&0&0&0&1&0&0&0&0&1&0 &0\\
       9&0&0&0&0&0&1&0&0&1&0&1 &0\\
      10&0&0&0&0&0&0&1&0&0&1&0 &1\\
      11&0&0&0&0&0&0&0&1&0&0&1 &0\\
    \end{tabular} 
  \end{center}
  \caption{A graph and its adjacency matrix.}
  \figlabel{graph-adj}
\end{figure}

Izvajanje matrike sosednjosti je slabše med #outEdges(i)# in
#inEdges(i)# operacijami. Da bi jo lahko implementirali, je potrebno preveriti vse #n#
vnose v ustrezno vrstico oziroma stolpec iz #a#, in zbrati vse indekse #j#, 
kjer je #a[i][j]# oziroma #a[j][i]# vrednost enaka "TRUE".

\javaimport{ods/AdjacencyMatrix.outEdges(i).inEdges(i)}
\cppimport{ods/AdjacencyMatrix.outEdges(i,edges).inEdges(i,edges)}
Časovna zahtevnost teh operacij je $O(#n#)$.  

\translatedby{Klemen Turšič}{sl}

Druga slaba lastnost sosednostnjih matrik je, da so velike. V matriki je 
shranjeno $#n#\times #n#$ boolean vrednosti, kar pomeni, da rabimo najmanj 
$#n#^2$ bitov prostora v pomnilniku. Implementacija tu uporablja dejansko eno
matriko z vrednostjo in to na tak način, da uporablja efektivno  
vrednosti $#n#^2$ zlogov pomnilnika. Za bolj previdno implementacijo, katera zapakira 
#w# boolean vrednosti v vsako pomnilniško besedo. Tako bi zmanjšali porabo prostora in 
dobili $O(#n#^2/#w#)$.

\begin{thm}
Podatkovna struktura #AdjacencyMatrix#, ki implementira vmesnik za grafe (v angleščini: #Graph# interface).
#AdjacencyMatrix# podpira naslednje operacije
\begin{itemize}
  \item #addEdge(i,j)#, #removeEdge(i,j)#, and #hasEdge(i,j)# in constant
  time per operation; and
  \item #inEdges(i)#, and #outEdges(i)# in $O(#n#)$ time per operation.
\end{itemize}
The space used by an #AdjacencyMatrix# is  $O(#n#^2)$.
\end{thm}

Kljub visoki zahtevi po prosturu in  neučinkovitega delovanja vhoda #inEdges(i)#
in izhoda #outEdges(i)# operacije, #AdjacencyMatrix# je lahko še vedno uporabna za nekatere operacije.
Še posebaj, ko je graf $G$ gost (\emph{dense}),
kar pomeni, da ima približno $#n#^2$ povezav, potem mora zavzeti $#n#^2$ prostora kar je še vedno sprejemljivo.

Podatkovna struktura #AdjacencyMatrix# se pogosto uporablja, saj se operacije nad 
matriko #a# lahko uporabljajo za definiranje lastnosti grafa $G$. 
To je argument, ki se predela na tečaju za algoritme, ampak oglejmo si vsaj eno lastnost:
če obravnavamo vhod kot neko celo število #a# (integer: 1 za true in 0 za false)
in pomnožimo matriko #a# samo s seboj z uporabo operacije množenja matrik, potem kot rezultat
dobimo matriko $#a#^2$. Po definiciji je za množenje matrik
\[
    #a^2[i][j]# = \sum_{k=0}^{#n#-1} #a[i][k]#\cdot #a[k][j]# \enspace .
\]
Po razlagi te vsote glede na graf $G$, ta formula prešteje število vozlišč, $#k#$, tako, da $G$ vsebuje obe povezavi
#(i,k)# in #(k,j)#. Bolj natančno povedano, se šteje število poti od $#i#$ do $#j#$
(preko vmestnih vozlišč $#k#$) kjer je dolžina natanko dve.
Ta ugotovitev je fondamentalna za algoritme, ki izračunavajo najkrajšo pot med vsemi pari vozlišč
v $G$, ki uporablja samo $O(\log#n#)$ časa za množenje matrik.

\section{#AdjacencyLists#: A Graph as a Collection of Lists}
\seclabel{adjacency-list}
\translatedby{Dev Kordeš}{sl}

\index{adjacency list}%
\emph{Seznam sosednosti} - ponazoritev grafov vzame pristop bolj usmerjen 
v vozlišča. Obstaja veliko možnih izvedb seznamov sosednosti. 
V tem poglavju predstavljamo preprosto izvedbo. Na koncu odseka, 
razpravljamo o različnih možnostih. V seznamu sosednosti je graf 
$G=(V,E)$ predstavljen kot polje, #adj#, seznamov.  Seznam
#adj[i]# vsebuje seznam vseh vozlišč sosednjih vozlišču #i#.
Vsebuje vsak #j# tako, da $#(i,j)#\in E$.
\codeimport{ods/AdjacencyLists.adj.n.AdjacencyLists(n0)}
(Primer je pokazan v \figref{graph-adjlist}.)  V tej specifični implementaciji,
pokažemo vsak seznam #adj# kot \javaonly{an}\cpponly{a
subclass of} #ArrayStack#, ker želimo doseči konstanten čas dostopov
do pozicij. Mogoče so tudi drugačne opcije.  Ena opcija je 
implementiranje #adj# kot #DLList#.


\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/graph} \\[3ex]
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
        0&1&2&3&4&5&6 &7 &8&9 &10&11 \\\hline
        1&0&1&2&0&1&5 &6 &4&8 &9 &10 \\
        4&2&3&7&5&2&2 &3 &9&5 &6 &7 \\
         &6&6& &8&6&7 &11& &10&11& \\
         &5& & & &9&10&  & &  &  & \\
         & & & & &4&  &  & &  &  & \\
    \end{tabular} 
  \end{center}
  \caption{A graph and its adjacency lists}
  \figlabel{graph-adjlist}
\end{figure}



Operacija #addEdge(i,j)# doda vrednost  #j# seznamu #adj[i]#:
\codeimport{ods/AdjacencyLists.addEdge(i,j)}
To se izvede v konstantem času.

Operacija #removeEdge(i,j)# pregleda seznam #adj[i]#
dokler ne najde #j# in ga odstrani iz seznama:
\codeimport{ods/AdjacencyLists.removeEdge(i,j)}
To se izvede v  $O(\deg(#i#))$ času, kjer $\deg(#i#)$ (\emph{stopnja}
\index{degree}%
$#i#$ -ja) prešteje število robov v $E$, ki imajo $#i#$ za njihov vir.

Operacija #hasEdge(i,j)# je podobna;  pregleda seznam
#adj[i]# dokler ne najde #j# (in vrne true), ali doseže konec
seznama (in vrne false):
\codeimport{ods/AdjacencyLists.hasEdge(i,j)}
To se izvede v $O(\deg(#i#))$ času.

Operacija #outEdges(i)# je zelo preprosta;
\javaimport{ods/AdjacencyLists.outEdges(i)}
\cppimport{ods/AdjacencyLists.outEdges(i,edges)}
\javaonly{To se očitno izvede v konstantem času.}\cpponly{To se očitno izvede v $O(\deg(#i#))$ času.}

Operacija #inEdges(i)# je veliko več dela.  Operacija pogleda vsako
vozlišče $j$ če obstaja #(i,j)# in, če tako, doda #j#
v izhodni seznam:
\javaimport{ods/AdjacencyLists.inEdges(i)}
\cppimport{ods/AdjacencyLists.inEdges(i,edges)}
Operacija je zelo počasna. Pregleda seznam sosednosti vsakega vozlišča
in se izvede v $O(#n# + #m#)$ času.

Naslednji izrek povzema delovanje zgornje podatkovne strukture:

\begin{thm}
Podatkovna struktura #AdjacencyLists# implementira vmesnik #Graph#.
#AdjacencyLists# podpira operacije
\begin{itemize}
  \item #addEdge(i,j)# v konstantem času na operacijo;
  \item #removeEdge(i,j)# in #hasEdge(i,j)# v $O(\deg(#i#))$ času
    na operacijo;
  \javaonly{\item #outEdges(i)# v konstantem časi na operacijo; in}
  \cpponly{\item #outEdges(i)# v $O(\deg(#i#))$ času na operacijo; in}
  \item #inEdges(i)# v $O(#n#+#m#)$ času na operacijo.
\end{itemize}
#AdjacencyLists# porabi  $O(#n#+#m#)$ prostora.
\end{thm}

Obstaja veliko možnosti kako lahko implementiramo graf kot seznam 
sosednosti. Ena izmed vprašanj ki se nam porajajo so:
\begin{itemize}
  \item Kakšno zbirko podatkov uporabiti za shranjevanje vsakega elementa v 
  #adj#?  Lahko bi uporabili array-based list, linked-list, ali celo
  hashtable.
  \item Lahko bi uporabili drug seznam sosednosti, #inadj#, ki hrani
  za vsak #i#, seznam vozlišč #j#, tako da $#(j,i)#\in E$
  Zo lahko močno poveča učinkovitost operacije #inEdges(i)#, 
  ampak rahlo zmanjša učinkovitost dodajanja in brisanja robov.
  \item Lahko bi vpis za rob #(i,j)# v #adj[i]# bil povezan z
  referenco na ustrezni vpis v #inadj[j]#
  \item Lahko bi robovi bili prvorazredni objekti z njihovimi asociativnimi podatki
  Tako bi #adj# vseboval seznam robov namesto seznama vozlišč (integers).
\end{itemize}
Pri večini gornjih vprašanj pride do kompromisa med kompleksnostjo (in 
prosotorom) implementacije in uspešnostjo funkcij implementacije.

\section{Graph Traversal}

V tem poglavju predstavljamo dva algoritma za raziskovanje grafa,
z začetkom v eni od njegovih točk, #i#, in zaključkom v vseh točkah
ki so dosegljive iz #i#. Oba algoritma sta najbolj primerna za
grafe predstavljene s seznamom sosednosti. Zato, ko bomo analizirali
te algoritme, bomo predpostavili, da je osnova predstavitev
s seznamom sosednosti #AdjacencyLists#.

\subsection{Iskanje v širino}

\index{breadth-first-search}%
Algoritem iskanje v širino ()\emph{bread-first-search}) začne pri točki #i# in obišče
najprej sosede od #i#, nato sosede od sosedov od #i#, nato sosede od sosedov
od sosedov od #i# in tako naprej.

Algoritem je posplošitev algoritma za obhod v širino binarnih dreves (\secref{bintree:traversal}),
in je zelo podoben; uporablja vrsto, #q#, ki sprva vsebuje le #i#.
Nato ponavljajoče izloča elemente iz #q# in dodaja svoje sosede v #q#,
pod pogojem, da sosedje niso nikoli prej bili v #q#. Edina pomembna razlika
med algoritmoma za iskanje v širino za grafe in za drevesa je ta,
da algoritem za grafe mora zagotavljati, da ne doda iste točke v #q# več kot enkrat.
To naredi s pomožnim boolean poljem, #seen#, ki beleži katere točke so že bile odkrite.

\codeimport{ods/Algorithms.bfs(g,r)}
Primer poganjanja #bfs(g,0)# na grafu iz \figref{graph}
je prikazan v \figref{graph-bfs}.  V odvisnosti od seznama sosednosti
so možna različna izvajanja; \figref{graph-bfs}
uporablja seznam sosednosti v \figref{graph-adjlist}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/graph-bfs}
  \end{center}
  \caption[Breadth-first-search]{Primer iskanja v širino kjer začnemo pri vozlišču 0. Vozlišča so
  označena z redom po katerem so dodana v #q#. Povezave, ki izhajajo iz vozlišč
  dodanih v #q#, so obarvani v črno, ostale povezave pa v sivo.}
  \figlabel{graph-bfs}
\end{figure}

Analiziranje časa izvajanja algoritma  #bfs(g, i)# je precej enostavno.
Uporaba polja #seen# zagotavlja, da nobena točka ni dodana v #q# več kot enkrat.
Dodajanje (in kasneje odstranjevanje) vsake točke iz #q# vzame konstanten čas
na točko, skupno $O(#n#)$ časa. Ker je vsaka točka obdelana v notranji zanki
največ enkrat je vsak seznam sosednosti obdelan največ enkrat, torej je vsaka povezava
od $G$ obdelana največ enkrat. Ta obdelava, ki je izvedena v notranji zanki,
porabi konstanten čas na iteracijo, skupno $O(#m#)$ časa. Zato se celoten
algoritem izvede v $O(#n#+#m#)$ času.

Naslednji izrek povzema učinkovitost algoritma #bfs(g,r)#.
\begin{thm}\thmlabel{bfs-graph}
  Ko je #Graf#, #g# podan kot vhod, ki je implementiran kot
  #Seznam sosedov#, potem algoritem #dfs(g,r)# potrebuje $O(#n#+#m#)$
  časa.
\end{thm}

Breadth-first sprehod ima nekaj zelo posebnih lastnosti. Klicanje funkcije
#bfs(g,r)# bo s časoma vrinilo (in s časoma izrinilo) vsako vozljišče
#j# tako, da bo obstajala direktna pot od #r# do #j#.  Še več,
vozljišča na radalji 0 od #r# (#r# sam) bodo vstopila v #q# pred
vozljišči na razdalji 1, ki bodo vstopila v #q# pred vozljišči na razdalji 2
in tako naprej.  Torej metoda #bfs(g,r)# obišče vozljišča
v narajaščujočem vrstnem redu razdalje od #r# in vozljišča, ki ne dosežemo
od #r# niso nikoli obiskana.

Precej uporabna aplikacija breadth-first-search algoritma
je torej, v iskanjue najkrajše poti.  Da bi izračunali najkrajšo
pot od #r# do vseh ostalih vozljišč, uporabimo različne verzije #bfs(g,r)#
ki uporabljajo pomožni seznam, #p#, dolžine #n#.  Ko je novo vozljišče
#j# dodano v #q#, nastavimo #p[j]=i#.  Na ta način, #p[j]# postane
predzadnje vozljišče z najkrajšo razdaljo od #r# do #j#.  S ponavljanjem tega postopka,
če uzamemo #p[p[j]#, #p[p[p[j]]]#, in tako naprej, lahko ponovno zgradimo
(v obratnem vrstnem redu) najkrajšo pot od #r# do #j#.



\subsection{Iskanje v globino}

The \emph{depth-first-search}
\index{depth-first-search}%
algoritem je podoben standardnemu
algoritmu za sprehod binarnih dreves;  najprej razišče celotno
poddrevo, potem pa se vrne na trenutno vozlišče in nato razišče še
drugo poddrevo.  Še en način, kako si lahko predstavljamo 
depth-first-search algoritem je breadth-first search algoritem, z razliko, da
depth-first-search uporablja sklad namesto vrste.

During the execution of the depth-first-search algorithm, each vertex,
#i#, is assigned a colour, #c[i]#: #white# if we have never seen
the vertex before, #grey# if we are currently visiting that vertex,
and #black# if we are done visiting that vertex.  The easiest way to
think of depth-first-search is as a recursive algorithm.  It starts by
visiting #r#.  When visiting a vertex #i#, we first mark #i# as #grey#.
Next, we scan #i#'s adjacency list and recursively visit any white vertex
we find in this list.  Finally, we are done processing #i#, so we colour
#i# black and return.
\codeimport{ods/Algorithms.dfs(g,r).dfs(g,i,c)}
An example of the execution of this algorithm is shown in \figref{graph-dfs}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/graph-dfs}
  \end{center}
  \caption[Depth-first-search]{An example of depth-first-search starting at node 0. Nodes are
  labelled with the order in which they are processed.  Edges that
  result in a recursive call are drawn in black, other edges
  are drawn in #grey#.}
  \figlabel{graph-dfs}
\end{figure}

Although depth-first-search may best be thought of as a recursive
algorithm, recursion is not the best way to implement it. Indeed, the code
given above will fail for many large graphs by causing a stack overflow.
An alternative implementation is to replace the recursion stack with an
explicit stack, #s#.  The following implementation does just that:
\codeimport{ods/Algorithms.dfs2(g,r)} 
V zgornji kodi, ko je naslednje vozlišče #i# procesirano, se #i# obarva v #sivo# in zamenja v skladu, z njegovimi sosednjimi vozlišči. V naslednji iteraciji bo eno izmed teh vozlišč obiskano.

Kot pričakovano ,sta časovni zahtevnosti za #dfs(g,r)# in #dfs2(g,r)#
 enaki kot tista od #bfs(g,r)#:
\begin{thm}\thmlabel{dfs-graph}
Ko je #Graf#,#g# podan kot vhod, ki je implementiran kot podatkovna struktura
 #Seznam sosedov#, potem oba algoritma #dfs(g,r)# in #dfs2(g,r)#
 potrebujeta $O(#n#+#m#)$ časa.
\end{thm}

Kot pri iskanje-v-širino algoritmu, imamo temeljno drevo, ki je povezano z vsako izvedbo
 iskanje-v-globino. Ko se vozlišče $#i#\neq #r#$ obarva iz #bele# na #sivo# , to se zgodi
  ,ker  je bil #dfs(g,i,c)# rekurzivno klican med procesiranjem nekega vozlišča #i'#. 
  (V primeru #dfs2(g,r)# algoritma, je #i# eden od vozlišč ki zamenja #i'# v skladu.) 
  Če gledamo na #i'# kot starša od #i#, potem ohranimo drevo s korenom pri #r#. 
  V \figref{graph-dfs}, je to drevo pot od vozlišča 0 do vozlišča 11.

An important property of the depth-first-search algorithm is the
following: Suppose that when node #i# is coloured #grey#, there exists a path
from #i# to some other node #j# that uses only white vertices.  Then #j#
will be coloured first #grey# then #black# before #i# is coloured #black#.
(This can be proven by contradiction, by considering any path $P$ from #i#
to #j#.)

One application of this property is the detection of cycles.
\index{cycle detection}%
Refer
to \figref{dfs-cycle}.  Consider some cycle, $C$, that can be reached
from #r#.  Let #i# be the first node of $C$ that is coloured #grey#,
and let #j# be the node that precedes #i# on the cycle $C$.  Then,
by the above property, #j# will be coloured #grey# and the edge #(j,i)#
will be considered by the algorithm while #i# is still #grey#.  Thus,
the algorithm can conclude that there is a path, $P$, from #i# to #j#
in the depth-first-search tree and the edge #(j,i)# exists.  Therefore,
$P$ is also a cycle.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/dfs-cycle}
  \end{center}
  \caption[Cycle detection]{The depth-first-search algorithm can be used to detect cycles
  in $G$. The node #j# is coloured #grey# while #i# is still #grey#.  This
  implies that there is a path, $P$, from #i# to #j# in the depth-first-search
  tree, and the edge #(j,i)# implies that $P$ is also a cycle.}
  \figlabel{dfs-cycle}
\end{figure}

\section{Discussion and Exercises}

The running times of the depth-first-search and breadth-first-search
algorithms are somewhat overstated by the Theorems~\ref{thm:bfs-graph} and
\ref{thm:dfs-graph}.  Define $#n#_{#r#}$ as the number of vertices, #i#,
of $G$, for which there exists a path from #r# to #i#.  Define $#m#_#r#$
as the number of edges that have these vertices as their sources.
Then the following theorem is a more precise statement of the running
times of the breadth-first-search and depth-first-search algorithms.
(This more refined statement of the running time is useful in some of
the applications of these algorithms outlined in the exercises.)
\begin{thm}\thmlabel{graph-traversal}
  When given as input a #Graph#, #g#, that is implemented using the
  #AdjacencyLists# data structure, the #bfs(g,r)#, #dfs(g,r)# and #dfs2(g,r)#
  algorithms each run in $O(#n#_{#r#}+#m#_{#r#})$ time.
\end{thm}

Izgleda, da sta Iskanje-v-širino neodvisno odkrila 
Moore \cite{59} in Lee \cite{l61} v kontekstu raziskovanja
 labirintov in preusmerjanja tokokroga.

Predstavitev grafov kot seznam sosedov sta demonstrirala
 Hopcroft in Tarjan \cite{ht73} kot alternativo (bolj pogostim)
  predstavitvam z matrikami sosednosti.  This representation, as well as
depth-first-search, played a major part in the celebrated Hopcroft-Tarjan
planarity testing algorithm 
\index{planarity testing}%
that can determine, in $O(#n#)$ time, if
a graph can be drawn, in the plane, and in such a way that no pair of
edges cross each other \cite{ht74}.

In the following exercises, an undirected graph is one in which, for
every #i# and #j#, the edge $(#i#,#j#)$ is present if and only if the
edge $(#j#,#i#)$ is present.
\index{undirected graph}%
\index{graph!undirected}%

\begin{exc}
  Narišite seznam sosednosti ter matriko sosednosti za graf na sliki \figref{graph-example2}.
\end{exc}

\begin{figure}
  \centering{\includegraphics[scale=0.90909]{figs/graph-example2}}
  \caption{Primer grafa.}
  \figlabel{graph-example2}
\end{figure}

\begin{exc}
  \index{incidence matrix}%
  \emph{Matrika neodvisnosti} za graf,
  $G$, je $#n#\times#m#$ matrika, $A$, kjer velja
  \[
     A_{i,j} = \begin{cases}
        -1 & \text{če je točka $i$ vir množice $j$} \\
        +1 & \text{če je točka $i$ tarča množice $j$} \\
        0 & \text{sicer.}
     \end{cases}
  \]
  \begin{enumerate}
    \item Narišite incidenčno matriko za graf na sliki
      \figref{graph-example2}.
    \item Načrtajte, analizirajte ter implementirajte incidenčno matriko za dan graf. Analizirajte porabo prostora ter ceno za
      #addEdge(i,j)#, #removeEdge(i,j)#, #hasEdge(i,j)#, #inEdges(i)#
      in #outEdges(i)#.
  \end{enumerate}
\end{exc}

\begin{exc}
  Illustrate an execution of the #bfs(G,0)# and #dfs(G,0)# na grafu, $#G#$,
  na sliki \figref{graph-example2}.
\end{exc}

\begin{exc}
  \index{connected graph}%
  \index{graph!connected}%
  Naj bo $G$ neusmerjen graf. $G$ je \emph{povezan} graf,
  če za vsak par vozlišč #i# in #j# v $G$ velja, da obstaja pot iz vozlišča
  $#i#$ v vozlišče $#j#$ (dokler je $G$ neusmerjen, obstaja tudi pot iz #j# v #i#). Dokažite, da pri povezanem grafu $G$ velja časovna zahtevnost $O(#n#+#m#)$.
\end{exc}

\begin{exc}
  \index{connected components}%
  Let $G$ be an undirected graph.  A \emph{connected-component labelling}
  of $G$ partitions the vertices of $G$ into maximal sets, each of which
  forms a connected subgraph.  Show how to compute a connected component
  labelling of $G$ in $O(#n#+#m#)$ time.
\end{exc}

\begin{exc}
  \index{spanning forest}%
  Naj bo graf $G$ neusmerjen graf. \emph{Vpeto drevo} grafa $G$ je skupek dreves, kjer  povezave ter vozlišča posameznih dreves, pripadajo grafu $G$. Izračunajte vpeto drevo grafa $G$ pri časovni zahtevnosti $O(#n#+#m#)$.
\end{exc}

\begin{exc}
  \index{strongly-connected graph}%
  \index{graph!strongly-connected}%
  Rekli smo, da je graf $G$ \emph{krepko povezani}, če za vsak par vozlišč #i# in #j# v $G$, obstaja pot iz vozlišča $#i#$ v vozlišče
  $#j#$. Dokažite, da je pri krepko povezanem grafu $G$ časovna zahtevnost $O(#n#+#m#)$.
\end{exc}

\begin{exc}
  Podan je graf $G=(V,E)$ ter nekaj točk, kjer je $#r#\in V$, Izračunajte dolžino najkrajše poti iz točke $#r#$ v #i# za vsako točko, kjer je $#i#\in V$.
\end{exc}

\begin{exc}
  Podajte primer, kjer metoda #dfs(g,r)# obišče vozlišča grafa v nasprotnem vrstnem redu, kot metoda #dfs2(g,r)#.
  Napišite novo verzijo metode #dfs2(g,r)#, ki obišče vozlišča danega grafa v enakem vrstnem redu kot metoda #dfs(g,r)#. (Namig: Sledite izvršitvi vsakega algoritma na grafu kjer je #r# vir več kot 1 množice.)
\end{exc}

\begin{exc}
  \index{universal sink}%
  \index{celebrity|see{universal sink}}%
  A \emph{universal sink} v grafu $G$ je točka, ki je tarča $#n#-1$ povezav in ni vir nobene množice.\footnote{universal sink,
  #v#, včasih imenujemo tudi \emph{celebrity}: Vsi zbrani v nekem prostoru prepoznajo #v#, toda #v# ne prepozna nobenega v tem prostoru.}
  Oblikujte in implementirajte algoritem, ki preveri, če ima graf $G$, predstavljen kot #AdjacencyMatrix#, universal sink. Časovna zahtevnost vašega algoritma bi morala biti $O(#n#)$.
\end{exc}
