
\translatedby{Tadej Dragutinovič}{sl}
\subsection{Summary}

Sledeči teorem povzema uporabnost preskočnega seznama, ko ga uporabljamo pri implementaciji urejenih sklopov:

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet# implementira #SSet# vmesnik. A #SkiplistSSet# vsebuje operacije #add(x)#, #remove(x)#, and #find(x)# in $O(\log #n#)$
pričakovani čas za izvedbo operacije.
\end{thm}

\section{#SkiplistList#: An Efficient Random-Access #List#}
\seclabel{skiplistlist}

\index{SkiplistList@#SkiplistList#}%
A #SkiplistList# implementira #List# vmesnik s pomočjo(uporabo) preskočnega seznama.
V #SkiplistList#, $L_0$ vsebuje elemente seznama po vrstnem redu pojavljanja  elementov.
 Po drugi strani
#SkiplistSSet#, elemente lahko dodajamo, brišemo ali do njih dostopamo v $O(\log
#n#)$ časa.

Za doseganje tega, potrebujemo možnost iskanja poti 
#i#th elementa v $L_0$.  Najlažji način je definirati notacijo
 the \emph{length} od roba nekega seznama, $L_{#r#}$.
Vsak rob seznama definiramo $L_{0}$ kot 1.  Dolžina robu, #e#,
v $L_{#r#}$, $#r#>0$, je definiran kot vsota dolžin robov pod njim #e#
v $L_{#r#-1}$.  Ekvivalenčno, dolžina  #e# je
število robov v $L_0$ spodaj #e#.  Poglej \figref{skiplist-lengths} za primer preskočnega seznama z dolžino njegovih robov. Posledica shranjevanja robov preskočnega seznama v nizih, lahko dolžino shranjujemo na enak način:

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-lengths}
  \end{center}
  \caption{The lengths of the edges in a skiplist.}
  \figlabel{skiplist-lengths}
\end{figure}

\codeimport{ods/SkiplistList.Node}

Povzetek te opredelitve dolžin je da smo trenutno na vozlišču, ki se nahaja na poziciji
#j# v $L_0$ in sledimo robu dolžine $\ell$, nato se premaknemo na vozlišče čigar pozicija v $L_0$,
je $#j#+\ell$.  Po takem postopku, medtem ko iščemo iskalno pot lahko ohranjamo
vrednost pozicije, #j#, trenutnega vozlišča v $L_0$.  Medtem ko na vozlišču, #u#, v $L_{#r#}$, gremo desno če #j# plus dolžina  roba
#u.next[r]# je manj kakor #i#. V nasprotnem primeru, gremo navzdol v  $L_{#r#-1}$.

\codeimport{ods/SkiplistList.findPred(i)}
\codeimport{ods/SkiplistList.get(i).set(i,x)}

Ker je najtežji del operacij #get(i)# in #set(i,x)# 
iskanje #i#th vozlišča v $L_0$, se operacije izvedejo v 
$O(\log #n#)$ časa.

Dodajanje elementa v  #SkiplistList# na pozicijo, #i#, je enostavno.  
Za razliko dodajanje v  #SkiplistSSet#, smo prepričani da bo vozlišče
Dejansko dodano, zato lahko hkrati dodajamo in iščemo lokacijo za  novo  
vozlišče. Najprej izberemo višino, #k#,
novo dodanega vozlišča  #w#, nato sledimo iskalni poti #i#.
Vsakič ko se iskalna pot premakne navzdol od $L_{#r#}$ z $#r#\le #k#$, uporabimo
 spoj #w# v $L_{#r#}$.  Dodatno moremo biti pozorni da se dolžina robov
pravilno osvežuje.  Poglej \figref{skiplist-addix}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-addix}
  \end{center}
  \caption[Adding to a SkiplistList]{Adding an element to a #SkiplistList#.}
  \figlabel{skiplist-addix}
\end{figure}

Pozorni moremo biti, da vsakič ko se iskalna pot premakne za eno vozščišče navzdol, #u#, v $L_{#r#}$,
se dolžina roba #u.next[r]# poveča za ena, ker dodajamo element pod rob na poziciji #i#.  
Spojimo vozlišče #w# med vozlišča,
#u# in #z#, deluje kakor prikazano v  \figref{skiplist-lengths-splice}.  Medtem
Ko sledimo iskalni poti, tudi shranjujemo pozicijo 
#j#, od #u# v $L_0$.  Zato, vemo da je dolžina roba od 
#u# do #w#  velikosti  $#i#-#j#$.  Sklepamo lahko da je razdalja roba 
od #w#  do #z# iz dolžine, $\ell$, od roba  #u# do #z#.
Potemtakem, lahko spojimo v #w# in osvežimo dolžine od robov v konstantnem času. 

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/skiplist-lengths-splice}
  \end{center}
  \caption[Adding to a SkiplistList]{Updating the lengths of edges while splicing a node
   #w# into a skiplist.}
  \figlabel{skiplist-lengths-splice}
\end{figure}

Postopek izgleda veliko bolj zakompliciran kot v resnici je. Koda je pravzaprav zelo enostavna:

\codeimport{ods/SkiplistList.add(i,x)}
\codeimport{ods/SkiplistList.add(i,w)}


Do sedaj bi vam morala biti implementacija #remove(i)# operacije v #SkiplistList# jasna.  Iščemo iskalno pot vozlišča na poziciji #i#.  Vsakič ko se iskalna pot zmanjša za ena od vozlišča #u#, na ravni #r# zmanjšamo radaljo od roba, tako da pustimo #u# na tistem nivoju.  Pregledovati moramo tudi, da je #u.next[r]# element ranga #i# in v kolikor držži, ga premaknemo iz seznama na tisti nivo.   Primer si lahko ogledate tukaj \figref{skiplist-removei}.
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-removei}
  \end{center}
  \caption[Removing an element from a SkiplistList]{Removing an element from a #SkiplistList#.}
  \figlabel{skiplist-removei}
\end{figure}
\codeimport{ods/SkiplistList.remove(i)}

\subsection{Summary}

Naslednji teorem povzema učinkovitost podatkovne strukture #SkiplistList#:

\begin{thm}\thmlabel{skiplistlist}
  #SkiplistList# implementira  #List# -ov vmesnik.   #SkiplistList#
  podpira operacije #get(i)#, #set(i,x)#, #add(i,x)#, ter
  #remove(i)# v $O(\log #n#)$ pričakovanem času na operacijo.
\end{thm}

%\section{Skiplists as Ropes}
%TODO: A section on ropes

\section{Analysis of Skiplists}
\seclabel{skiplist-analiza}

V sledečem delu bomo analizirali pričakovano višino, velikost ter dolžino
Iskalne poti v  preskočnem seznamu.  Za razumevanje potrebujemo osnovno ozadnje 
verjetnosti.  Nekateri dokazi  so osnovani na metu kovanca.


\begin{lem}\lemlabel{met kovanca}
  \index{coin toss}%
  Naj bo  $T$ število, kadar se pošten kovanec obrne navzgor, vključno s primerom kadar kovanec pade z glavo navzgor. Takrat $\E[T]=2$.
\end{lem}

\begin{proof}
  Recimo da nehamo metati kovanec prvič kadar pade z glavo navzgor.
 Definirajmo indikacijsko spremenljivko
  \[ I_{i} = \left\{\begin{array}{ll}
     0 & \mbox{če je kovanec vržen navzgor $i$ kar} \\
     1 & \mbox{če je kovanec vržen $i$ ali več krat}
     \end{array}\right.
  \]
  Upoštevajte da  $I_i=1$ če in samo če edini $i-1$ met kovanca postane rep,
  torej $\E[I_i]=\Pr\{I_i=1\}=1/2^{i-1}$.  Opazimo da  $T$, vse mete kovanca
  lahko zapišemo kot $T=\sum_{i=1}^{\infty} I_i$.
  Sledi,
  \begin{align*}
    \E[T] & =  \E\left[\sum_{i=1}^\infty I_i\right] \\
     & =  \sum_{i=1}^\infty \E\left[I_i\right] \\
     & =  \sum_{i=1}^\infty 1/2^{i-1} \\
     & =  1 + 1/2 + 1/4 + 1/8 + \cdots \\
     & =  2 \enspace .   \qedhere
  \end{align*}
\end{proof}

Naslednji hipotezi nam pokažeta da ima preskočni seznam linearno velikost:

\begin{lem}\lemlabel{skiplist-size1}
  Pričakovano število vozlišč v preskočnem seznamu vsebuje $#n#$ elementov,
če ne upoštevamo kontrolnih pojavljanj,  je $2#n#$.
\end{lem}

\begin{proof}
 Verjetnost, da je  kateri koli element, #x#, vsebovan v seznamu
  $L_{#r#}$ is $1/2^{#r#}$, so the expected number of nodes in $L_{#r#}$
  je $#n#/2^{#r#}$.\footnote{Poglej \secref{randomization} za obrazložietv kako pridemo do rezultata z uporabo indikatorja spremenljivk in linearnosti pričakovanja.}
  Sledi, da je skupno število pričakovanih vozlišč v seznamu
  \[ \sum_{#r#=0}^\infty #n#/2^{#r#} = #n#(1+1/2+1/4+1/8+\cdots) = 2#n# \enspace . \qedhere \]
\end{proof}

\begin{lem}\lemlabel{skiplist-height}
  Pričakovana višina preskočnega seznama, ki vsebuje #n# elementov je največ
  $\log #n# + 2$.
\end{lem}

\begin{dokaz}
  Za vsak $#r#\in\{1,2,3,\ldots,\infty\}$,
  Definiramo indicator naključnih  spremenljivk
  \[ I_{#r#} = \left\{\begin{array}{ll}
     0 & \mbox{if $L_{#r#}$ je prazen} \\
     1 & \mbox{if $L_{#r#}$ ni prazen}
     \end{array}\right.
  \]
  Višina, #h#, preskočnega seznama je
  \[
       #h# = \sum_{i=1}^\infty I_{#r#} \enspace .
  \]
  Upoštevajte, da  $I_{#r#}$ ni nikoli večji kot dolžina, $|L_{#r#}|$, od $L_{#r#}$, zato
  \[
     \E[I_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
 Zato imamo
  \begin{align*}
       \E[#h#] &= \E\left[\sum_{r=1}^\infty I_{#r#}\right] \\
        &= \sum_{#r#=1}^{\infty} E[I_{#r#}] \\
        &= \sum_{#r#=1}^{\lfloor\log #n#\rfloor} E[I_{#r#}]
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} E[I_{#r#}]  \\
        &\le \sum_{#r#=1}^{\lfloor\log #n#\rfloor} 1
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} #n#/2^{#r#} \\
        &\le \log #n#
                 + \sum_{#r#=0}^\infty 1/2^{#r#} \\
        &= \log #n# + 2 \enspace . \qedhere
  \end{align*}
\end{proof}

\begin{lem}\lemlabel{skiplist-size2}
  Pričakovano število vozlišč v preskočnem seznamu vsebuje $#n#$ elementov,
  z vsemi pojavitvami “opazovalca”, je $2#n#+O(\log #n#)$.
\end{lem}

\begin{proof}
  Po \lemref{skiplist-size1}, sledi da je pričakovano število vozlišč, brez “opazovalca”
 $2#n#$.  Število pojavitev “opaovalca” je enako višini, $#h#$, preskočnega seznama,torej
  \lemref{skiplist-height} the expected number of occurrences of the
  je “opazovalec” največ $\log #n#+2 = O(\log #n#)$.
\end{proof}



\begin{lem}
Pričakovana dolžina iskalne poti v preskočnem seznamu je največ $2\log #n# + O(1)$.
\end{lem}

\begin{proof}
  Najlažje dokažemo hipotezo tako da uporabimo \emph{reverse search
  path} za vozlišče, #x#.  Ta pot začne pri predhodniku #x#
  v $L_0$.  Kadarkoli , če  grelahko  pot eno nadstropje višje takrat lahko.  V kolikor nemore iti eno nadstropje višje, gre levo. Če nekaj trenutkov premišljujemo o tem nas bo prepričalo da je vzvratna iskalna pot za  #x# enaka iskalni poti za #x#, z razliko da je vzvratna.

  Število vozlišč, ki obiščejo vzvratno pot v nekem nadstropju
  , #r#, je povezana z naslednjim eksperimentom:  Vržimo kovanec.
  Če pade glava,se premakni navzgor, nato ustavi. V nasprotnem primeru se premakni levo in ponovi eksperiment. Številov metov kovanca, preden pade glava predstavlja število korakov v levo, ki ki jih vzvratna iskalna pot porabi v nekem nadstropju. footnote{Bodite pozorni da lahko pride do 
“overcounta” števila korakov na levo, saj se mora  eksperiment končati. Končati mora ob prvi glavi  ali ko iskalna pot doseže “opazovalca”,kateri pride prvi. To ne predstavlja problema saj leži hipoteza na  zgornji meji.} \lemref{coin-tosses} nam prikazuje da je pričakovano število metov kovanca preden pade prva “glava”, 1.

  Naj $S_{#r#}$ označuje število korakov ki jih porabi iskalna pot naprej na nadstropju
  $#r#$ ki gre levo.   Pravkar smo trdili da  $\E[S_{#r#}]\le
  1$.  Poleg tega, $S_{#r#}\le |L_{#r#}|$, ker nemoremo narediti več korakov v  $L_{#r#}$  kot je dolžina $L_{#r#}$, zato
  \[
    \E[S_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
 Sedaj lahko dokončamo dokaz \lemref{skiplist-height}.
  Naj bo $S$ dolžina iskalne poti nekega vozlišča, #u#, v preskočnem seznamu  in naj bo $#h#$ višina preskočnega seznama. Sledi
  \begin{align*}
      \E[S]
         &= \E\left[ #h# + \sum_{#r#=0}^\infty S_{#r#} \right] \\
         &= \E[#h#] + \sum_{#r#=0}^\infty \E[S_{#r#}]  \\
         &= \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} \E[S_{#r#}]
              + \sum_{#r#=\lfloor\log #n#\rfloor+1}^\infty \E[S_{#r#}] \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{r=\lfloor\log #n#\rfloor+1}^\infty #n#/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \log #n# + 3 \\
         &\le 2\log #n# + 5  \enspace . \qedhere
  \end{align*}
\end{proof}


Sledeči teorem povzema rezultat sekcije:
\begin{thm}
Preskočni senam, ki vsebuje $#n#$ elementov je pričakoval velikost $O(#n#)$ in pričakovana dolžina iskalne poti nekega elementa je največ:
$2\log #n# + O(1)$.
\end{thm}



%\section{Iteration and Finger Search}

%TODO: Napiši to sekcijo

\section{Discussion and Exercises}