\translatedby{Mitja Ahlin}{sl}
\subsection{Rdeče-Črna drevesa in 2-4 Drevesa}

Sprva se morda zdi presenetljivo, da lahko rdeče-črno drevo učinkovito
posodabljamo tako, da ohranjamo višine črnih vozlišč in ne ohranjamo lastnosti rdečih vozlišč. Zdi se tudi nenavadno, da nekateri menijo, da so to koristne lastnosti. Kakorkoli, rdeče-črna drevesa so bila zasnovana za učinkovito simulirati 2-4 drevesa kot binarna drevesa.


Nanašanje na \figref{twofour-redblack}.
Vzemimo, da ima katerokoli rdeče-črno drevo, $T$, #n# vozlišč in izvaja naslednje operacije: Zbriše vsako rdeče vozlišče #n# in poveže otroka vozlišča #u# direktno na (črnega) starša vozlišča #u#. Po teji spremembi imamo drevo $T'$ z samo črnimi vozlišči.

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[scale=0.90909]{figs/24rb-3} \\
      \includegraphics[scale=0.90909]{figs/24rb-2}
    \end{tabular}
  \end{center}
  \caption{Vsako rdeče-črno drevo ima ustrezno 2-4 drevo.}
  \figlabel{twofour-redblack}
\end{figure}

Vsako notranje vozlišče v $T'$ ima dva, tri ali štiri otroke: Črno vozlišče, ki je imelo dva črna otroka bo še vedno imelo črna otroka po spremembi. Črno vozlišče, ki je imelo enega rdečega in enega črnega otroka bo imelo tri otroke po tej spremembi. Črno vozlišče, ki je imelo dva rdeča otroka bo imelo štiri otroke po teji spremembi. Poleg tega, lastnost črnih vozlišč nam garantira, da vsaka pot od korena do lista v $T'$ je enake dolžine. Z drugimi besedami, $T'$ je 2-4 drevo!

2-4 drevo $T'$ ima $#n#+1$ listov, ki ustrezajo $#n#+1$ zunanjim vozliščim rdeče-črnega drevesa. Torej, to drevo ima višino največ $\log (#n#+1)$. Vsaka pot od korena do lista v 2-4 drevesu ustreza poti od korena rdeče-črnega drevesa $T$ do zunanjega vozlišča.
Prvo in zadnje vozlišče v teji poti sta črna in največ eden na vsaka dva notranja vozlišča je rdeč, tako, da ima ta pot največ $\log(#n#+1)$ črnih in največ $\log(#n#+1)-1$ rdečih vozlišč. Torej, najdaljša pot od korena do kateregakoli \emph{notranjega} vozlišča v $T$ je največ
\[
   2\log(#n#+1) -2 \le 2\log #n# \enspace ,
\]
za kateregakoli $#n#\ge 1$. To dokaže najpomembnejšo lastnost rdeče-črnih dreves:
\begin{lem}
Višina rdeče-črnega drevesa z #n# vozlišči je največ $2\log #n#$.
\end{lem}

Sedaj, ko smo videli relacijo med 2-4 drevesi in rdeče-črnimi drevesi, ni tako težko za verjeti, da lahko učinkovito ohranjamo rdeče-črno drevo med dodajanjem in brisanjem elementov.

Videli smo že, da dodajanje elementa v #BinarnoIskanoDrevo# izvedemo z dodajanjem novega lista. Torej, za implementacijo #dodaj(x)# v rdeče-črno drevo moramo imeti metodo za simulacijo razdelitve vozlišča s petimi otroci v 2-4 drevesu. Vozlišče v 2-4 drevesu s petimi otroci je predstavljeno s črnim vozliščem, ki ima dva rdeča otroka, eden od teh ima tudi rdečega otroka. Lahko ``razdelimo'' to vozlišče s tem, da ga pobarvamo v rdeče in pobarvamo njegova dva otroka v črno. Primer prikazuje \figref{rb-split}.

\begin{figure}
  \begin{center}
   \begin{tabular}{c}
     \includegraphics[scale=0.90909]{figs/rb-split-1} \\
     \includegraphics[scale=0.90909]{figs/rb-split-2} \\
     \includegraphics[scale=0.90909]{figs/rb-split-3} \\
   \end{tabular}
  \end{center}
  \caption[Simulirano 2-4 drevo]{Simuliranje operacije deljenja 2-4 drevesa med dodajanjem v rdeče-črno drevo. (To simulira dodajanje v 2-4 drevo prikazano na \figref{twofour-add}.)}
  \figlabel{rb-split}
\end{figure}

Podobno, implementacija #izbrisi(x)# zahteva metodo za združevanje dveh vozlišč in izposojo sorodnikovega otroka. Združitev dveh vozlišč je inverz deljenja vozlišč (prikazano na \figref{rb-split}) in vključuje barvanje dveh (črnih) sorodnikov v rdeče in barvanje njegovega (rdečega) starša v črno. Izposoja od sorodnika je najboj zakompliciran postopek in vključuje obe rotacije in barvanje vozlišč.

Vsekakor, med vsem tem moramo še vedno ohranjati lastnost no-red-edge in lastnost black-height. Medtem ni več presenetljivo, da je to lahko izvedljivo, veliko je število primerov, ki jih moramo upoštevati, če poikušamo narediti ditektno simulacijo 2-4 drevesa z rdeče-črnim drevesom. Na neki točki, postane lažje če neupoštevamo osnovnih 2-4 dreves in delamo neposredno k ohranjanju lastnosti rdeče-črnih dreves.

\subsection{Levo-viseča Rdeče-Črna Drevesa}

\index{red-black tree}%
\index{left-leaning red-black tree}%
Ne obstaja nobena definicija rdeče-črnega drevesa. Namesto tega, je družina struktur, ki uspe ohranjati  lastnosti black-height in no-red-edge med operacijama #dodaj(x)# in #izbrisi(x)#. Drugačne strukture to delajo na drugačne načine. Tukaj mi implementiramo podatkovno strukturo, ki jo kličemo #RdeceCrnoDrevo#.
\index{RedBlackTree@#RedBlackTree#}%
Ta struktura implementira posebno obliko rdeče-črnega drevesa, ki zadovoljuje dodatni lastnosti.
\begin{prp}[left-leaning]\prplabel{levo-viseče}\prplabel{redblack-last}
  \index{left-leaning property}%
  Na kateremkoli vozlišču #u#, če je #u.levo# črno, potem #u.desno# je črno.
\end{prp}

Opomnimo, da rdeče-črno drevo prikazano na \figref{redblack-example} ne zadošča levo-viseči lastnosti; krši jo starš rdečega vozlišča na najbolj desni poti od korena proti listu.

Razlog za ohranjanje levo-viseče lastnosti je, da zmanjšuje število primerov soočenih pri posodabljanju drevesa med operacijama #dodaj(x)# in #izbrisi(x)#. V smuslu 2-4 dreves, to pomeni, da vsako 2-4 drevo ima edinstveno zastopanje: Vozlišče stopnje dva postane črno vozlišče z dvemi črnimi otroci. Vozlišče stopnje tri postane črno vozlišče katerega levi otrok je rdeč in desni otrok je črn. Vozlišče stopnje štiri postane črno vozlišče z dvema rdečima otrokoma.

Preden opišemo implementacijo operacij #dodaj(x)# in #izbrisi(x)# v podrobnosti, prvo predstavimo nekaj osnovnih podoperacij uporabljenih v teh metodah prikazanih v \figref{redblack-flippullpush}. Prvi dve podoperaciji so za manipulacijo barv med ohranjanjem lastnosti black-height. Operacija #pushBlack(u)# metoda vzame za vhod črno vozlišče #u#, katero ima dva rdeča otroka in pobarva #u# rdeče in njegova dva otroka črno. Operacija #pullBlack(x)# obrne to opisano operacijo:
\codeimport{ods/RedBlackTree.pushBlack(u).pullBlack(u)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/flippullpush}
  \end{center}
  \caption{Flips, pulls and pushes}
  \figlabel{redblack-flippullpush}
\end{figure}

Metoda #flipLeft(u)# zamenja barve vozlišča #u# in #u.desno# in izvede levo rotacijo nad vozliščem #u#. Ta metoda obrne barve teh dveh vozlišč tako kot tudi relacijo njihovih staršev-otrok:
\codeimport{ods/RedBlackTree.flipLeft(u)}
Operacija #flipLeft(u)# je pposebno uporabna pri povrnitvi levo-viseče lastnosti na vozlišču #u#, katero krši to lastnost (ker je #u.levo# črno in #u.desno# rdeče). V tem posebnem primeru, smo lahko zagotovi, da ta operacija ohranja obe lastnosti black-height in no-red-edge. Opreacija #flipRight(u)# je simetrična z #fliLeft(u)#, ko so vloge levega in desnega obrnjene.
\codeimport{ods/RedBlackTree.flipRight(u)}

\subsection{Dodajanje}

Za implementacijo #dodaj(x)# v #RdeceCrnoDrevo#, izvedemo standardno #BinarnoIskalnoDrevo# vstavljanje za dodajanje novega lista, #u#, z $#u.x#=#x#$ in nastavimo $#u.colour#=#red#$. Opomnimo, da to ne spremeni črne višine kateremukoli vozlišču, torej ne krši lastnosti black-height. To pa lahko krši levo-visečo lastnost (če je #u# desni otrok svojega starpa), in lahko krši no-red-edge lastnost (če je #u#jev starš #rdec#). Za povrnitev teh lastnosti, moramo klicati metodo #addFixup(u)#.
\codeimport{ods/RedBlackTree.add(x)}

Ilustrirano na \figref{rb-addfix}, metoda #addFixup(u)# vzame za vhod vozlišče #u# katerega barva je rdeča in katero bi lahko kršilo lastnost no-red-edge in/ali levo-ležečo lastnost. Slednja razprava je verjetno nemogoča za sledelje brez sklicevanja na \figref{rb-addfix} ali ponovnega ustvarjanja na kosu papirja. Dejansko, bralec bi si moral preučiti to sliko preden nadaljuje.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/rb-addfix}
  \end{center}
  \caption{Enotni postopek v procesu popravljanja Property~2 po vstavljanju.}
  \figlabel{rb-addfix}
\end{figure}

Če je #u# koren drevesa, potem lahko pobarvamo #u# v črno za pridobitev nazaj obeh lastnosti. Če je tudi #u#jev sorodnik rdeč, potem mora biti #u#jev starš črn, torej oba levo-viseča in no-red-edge lastnost že držita.
 
Če ne, najprej določimo, če je #u#jev starš, #w#, kršil levo-visečo lastnost in, če je tako, izvedemo operacijo #flipLeft(w)# in nastavimo $#u#=#w#$. To nas pusti v lepo definiranem stanju: #u# je levi otrok starša, #w#, torej #w# sedaj zadošča levi-viseči lastnosti. Vse kar nam ostane je, da zagotovimo no-red-edge lastnost na #u#. Moramo samo še skrbeti za primer v katerem je #w# rdeč, sicer v nasprotnem primeru #u# že zadošča lastnosti no-red-edge.

Glede na to, da še nismo končali, #u# je rdeč in #w# je rdeč. Lastnost no-red-edge (katero krši #u# in ne #w#) implicira, da #u#jev stari starš #g# obstaja in je črn. Če je #g#jev desni otrok rdeč, potem levo-viseča lastnost zagotavlja, da oba #g#jev otrok je rdeč in klic na #pushBlack(g)# naredi #g# rdečega in #w# črnega. To povrne no-red-edge lastnost na #u#, ampak lahko povzroči, da jo krši na #g# vozlišču, tako, da celoten proces začne z $#u#=#g#$.

Če je #g#jev otrok črn, potem klic na #flipRight(g)# nardi #w# črnega starča od #g# in naredi #w#ju dva rdeča otroka, #u# in #g#. To zagotovi, da #u# zadošča no-red-edge lastnosti in #g# zadošča levo-viseči lastnosti. V tem primeru se lahko ustavimo.
\codeimport{ods/RedBlackTree.addFixup(u)}

Metoda #insertFixup(u)# ima konstantni čas za iteracijo in vsaka iteracija ali konča ali premakne #u# bližje korenu. Zato, metoda #insertFixup(u)# konča po $O(\log #n#)$ iteracijah in po $O(\log #n#)$ času.