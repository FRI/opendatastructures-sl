\chapter{Dvojiška drevesa}
\chaplabel{binarytrees}
\translatedby{Erik Šimer}{sl}
\translatedby{Vesna Horvat}{sl}
\translatedby{Tjaša Jagodnik}{sl}
\translatedby{Anže Pratnemer}{sl}

To poglavje vpeljuje eno izmed najbolj temeljnih struktur v računalništvu: dvojiška drevesa. Uporaba besede \emph{drevo}
\index{tree}%
\index{tree!binary}%
\index{binary tree}%
prihaja iz dejstva, da je, ko jih rišemo, končna risba podobna drevesom iz gozda.
Obstaja več definicij dvojiških dreves.
 Matematično je  \emph{dvojiško drevo} povezan,
neusmerjen, končni graf brez ciklov in z vozlišči s stopnjo največ tri.

V računalništvu običajno uporabljamo dvojiška drevesa \emph{s korenskim vozliščem}:
\index{tree!rooted}%
\index{rooted tree}%
Posebno vozlišče #r#, stopnje največ $2$, se imenuje \emph{koren}
drevesa. Za vsako vozlišče $#u#\neq #r#$, se prvo vozlišče na
poti od #u# do #r# imenuje \emph{starš} vozlišča #u# .
\index{parent}%
Ostala sosednja vozlišča vozlišča #u# imenujemo \emph{otroci}
\index{child} vozlišča #u#. Večina
dvojiških dreves, ki nas zanimajo, so \emph{urejena},
\index{ordered tree}%
\index{tree!ordered}%
tako da ločimo med \emph{levim} in \emph{desnim otrokom} vozlišča #u#.
\index{left child}%
\index{child!left}%
\index{right child}%
\index{child!right}%

Dvojiška drevesa običajno rišemo obrnjena navzdol,
s korenom na vrhu slike in z levim oz.\ desnim otrokom na levi oz.\ strani
(slika \figref{bintree-orientation}). Na sliki \figref{binary-tree} je prikazano
dvojiško drevo z devetimi vozlišči.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bintree-traverse-1} 
  \end{center}
  \caption[Parent, left child, and right child]{Starš, levi otrok, desni otrok vozlišča #u#
   v dvojiškem drevesu (#BinaryTree#).}
  \figlabel{bintree-orientation}
\end{figure}


\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[width=\HalfScaleIfNeeded]{figs/bintree-1} &
      \includegraphics[width=\HalfScaleIfNeeded]{figs/bintree-2} \\
      (a) & (b)
    \end{tabular}
  \end{center}
  \caption{Dvojiško drevo (a) z devetimi dejanskimi vozlišči in (b) z desetimi navideznimi vozlišči.}
  \figlabel{binary-tree}
\end{figure}

Ker so dvojiška drevesa tako pomembna, zanje uporabljamo naslednje izrazoslovje:
 \emph{globina}
\index{globina}%
vozlišča #u#, je v dvojiškem drevesu
dolžina poti od #u# do korena drevesa. Če je vozlišče #w#
na poti od #u# do #r#, potem #w# imenujemo \emph{prednik}
\index{prednik}%
vozlišča #u#, #u# pa imenujemo \emph{potomec}
\index{potomec}%
vozlišča #w#. \emph{Poddrevo} vozlišča #u# je dvojiško drevo, ki ima koren #u# in vsebuje vse
potomce vozlišča #u#. \emph{Višina}
\index{višina!v drevesu} vozlišča #u# je dolžina
najdaljše poti od #u# do enega izmed njegovih potomcev. \emph{Višina}
\index{višina!drevesa}%
drevesa je višina njegovega korena.
Vozlišče #u# je \emph{list},
\index{leaf}%
če nima nobenega otroka.

Včasih si predstavljamo, da so drevesa dopolnjena z \emph{navideznimi
zunanjimi vozlišči}. Vsako vozlišče, ki nima levega oz.\ desnega otroka, ima zunanje
vozlišče na njunih mestih (glej \figref{binary-tree}.b). Z indukcijo lahko
enostavno pokažemo, da ima dvojiško drevo z $#n#\ge 1$ dejanskimi vozlišči
$#n#+1$ navideznih vozlišč.


\section{#BinaryTree#: Osnovno dvojiško drevo}

\index{BinaryTree@#BinaryTree#}%
Najenostavnejši način predstavitve vozlišča #u# v dvojiškem drevesu je
neposredna hramba (največ treh) sosedov vozlišča #u#:
\javaimport{ods/BinaryTree.BTNode<Node}
\cppimport{ods/BinaryTree.BTNode}
Če kateri koli od njih ni prisoten, ga nastavimo na #nil#.
Vrednosti vseh zunanjih vozlišč in starša korena je vedno #nil#.

Za predstavitev dvojiškega drevesa ni potrebna ločena podatkovna struktura, ampak lahko uporabimo kar referenco na koren dvojiškega drevesa, #r#:
\codeimport{ods/BinaryTree.r}

Globino vozlišča #u# lahko izračunamo tako, da preštejemo korake od vozlišča #u# do korena drevesa:
\codeimport{ods/BinaryTree.depth(u)}


\subsection{Rekurzivni algoritmi}

\index{recursive algorithm}%
Z rekurzivnimi algoritmi je delo z drevesi preprosto. 
Na primer, za izračun velikosti (število vozlišč)
dvojiškega drevesa s korenom #u# rekurzivno izračunamo
velikosti obeh poddreves vozlišča #u#, ju seštejemo in prištejemo $1$:

\codeimport{ods/BinaryTree.size(u)}

Za izračun višine vozlišča #u# rekurzivno izračunamo višini obeh poddreves, izberemo višino višjega in prištejemo $1$:

\codeimport{ods/BinaryTree.height(u)}

\subsection{Obhod dvojiškega drevesa}
\seclabel{bintree:traversal}

\index{obhod!dvojiškega drevesa}%
\index{obhod drevesa}%
\index{dvojiško drevo!obhod}%
Algoritma iz predhodnega razdelka za obisk vozlišč v dvojiškem
drevesu uporabljata rekurzijo. Oba obiskujeta vozlišča v vrstnem
redu, kot ga prikazuje sledeča koda:

\codeimport{ods/BinaryTree.traverse(u)}

Z uporabo rekurzije lahko pišemo kratko in enostavno kodo,
kar pa je lahko problematično. Največja globina rekurzije je določena
z globino vozlišča, to je višina preiskovanega drevesa. Če je ta
zelo velika, lahko rekurzivni klici presežejo dodeljeno velikost
sklada, kar povzroči sesutje programa.

Za obhod dvojiškega drevesa brez rekurzije lahko uporabimo algoritem, ki se 
zanaša na to, da ve, od kod je prišel in kam bo odšel. Glej kodo
\figref{bintree-traverse}.  Če pridemo v vozlišče #u# iz #u.parent#,
potem obiščemo #u.left#. Če pridemo v #u#
iz #u.left#, potem obiščemo #u.right#. Če prispemo v #u# iz
#u.right#, potem smo končali z obiskovanjem poddreves vozlišča #u#
in se vrnemo v #u.parent#. Naslednja koda prikazuje
delovanje, vključno s primeri, ko je kateri koli od #u.left#,
#u.right# ali #u.parent# #nil#:
\codeimport{ods/BinaryTree.traverse2()}


\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[scale=0.90909]{figs/bintree-traverse-2}
      \includegraphics[scale=0.90909]{figs/bintree-3}
    \end{tabular}
  \end{center}
  \caption[Traversing a BinaryTree]{Na levi strani: Trije primeri, ki se pojavijo pri nerekurzivnem obhodu drevesa za vozlišče #u#. Na desni strani: Rezultat obhoda drevesa #r#.}
  \figlabel{bintree-traverse}
\end{figure}

Vse probleme, ki jih rešujemo z rekurzivnimi algoritmi, lahko rešimo z iterativnimi algoritmi. 
Na primer, za izračun velikosti drevesa hranimo števec #n# in ga povečamo vsakič, ko obiščemo novo vozlišče.
\codeimport{ods/BinaryTree.size2()}

V nekaterih izvedbah dvojiških dreves se ne uporablja referenca na starša (#parent#).
V takih primerih lahko še vedno uporabimo iterativno metodo, vendar
potrebujemo še seznam (#List#) ali sklad (#Stack#), da beležimo pot od trenutnega vozlišča do korena.

Posebna vrsta obhoda, ki ne ustreza nobenemu od zgoraj omenjenih vzorcev, je \emph{iskanje v širino}.
\index{iskanje v širino}%
\index{obhod!v širino}%
Pri iskanju v širino vozlišča obiskujemo po nivojih.
Začnemo v korenu in nadaljujemo navzdol, kjer obiščemo vsa
vozlišča od levega proti desni (glej sliko \figref{bintree-bfs}). 
Enak pristop uporabljamo npr.\ ljudje pri branju knjige v slovenščini.
Obhod v širino je izveden z uporabo vrste #q#, ki na začetku vsebuje le koren #r#.
Na vsakem koraku vzamemo trenutno vozlišče #u# iz #q#, nato ga obdelamo in dodamo #u.left#
in #u.right# (če niso #nil#) v #q#:
\codeimport{ods/BinaryTree.bfTraverse()}

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bintree-4}
  \end{center}
  \caption{Pri obhodu v širino obiščemo vozlišča dvojiškega drevesa po nivojih, na vsakem nivoju pa z leve proti desni.}
  \figlabel{bintree-bfs}
\end{figure}



\translatedby{Matej Brlec}{sl}

\section{#BinarySearchTree#: Neuravnoteženo dvojiško iskalno drevo}
\seclabel{binarysearchtree}

\index{BinarySearchTree@#BinarySearchTree#}%
\index{dvojiško iskalno drevo}%
\index{dvojiško drevo!iskanje}%
Dvojiško iskalno drevo (#BinarySearchTree#) je posebna oblika dvojiškega drevesa, pri katerem vsako vozlišče #u# hrani tudi podatek #u.x# iz neke urejene množice. Podatki dvojiškega iskalnega drevesa upoštevajo \emph{lastnost dvojiških iskalnih dreves}:
\index{lastnost dvojiškega iskalnega drevesa}%
Za vozlišče #u# velja, da je vsaka vrednost, shranjena v poddrevesu #u.left#, manjša od #u.x# in vsaka vrednost, shranjena v poddrevesu #u.right#, večja od #u.x#. Primer dvojiškega iskalnega drevesa je prikazan na sliki \figref{bst}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bst-example}
    %\includegraphics[scale=0.90909]{figs/binary-tree-4}
  \end{center}
  \caption{Dvojiško iskalno drevo.}
  \figlabel{bst}
\end{figure}

\subsection{Iskanje}

\index{iskanje!v dvojiškem iskalnem drevesu}%
Zgoraj omenjena lastnost dvojiškega iskalnega drevesa je zelo uporabna, ker nam omogoča hitro iskanje vrednosti #x# v dvojiškem iskalnem drevesu. Iskanje vrednosti #x# začnemo v korenu #r#. Za vsako pregledano vozlišče #u# imamo tri primere:
\begin{enumerate}
\item Če je $#x#< #u.x#$, nadaljujemo z iskanjem v #u.left#;
\item Če je $#x#> #u.x#$, nadaljujemo z iskanjem v #u.right#;
\item Če je $#x#= #u.x#$, pomeni, da smo našli vozlišče #u#, ki hrani #x#.
\end{enumerate}
Iskanje se zaključi na dva načina: Bodisi smo naleteli na primer~3, kjer smo #x# našli, bodisi je #u=nil# (prazen), kar pomeni, da #x# ni v dvojiškem iskalnem drevesu.
\codeimport{ods/BinarySearchTree.findEQ(x)}

Na sliki \figref{bst-search} sta prikazana dva primera iskanj v dvojiškem iskalnem drevesu. Drugi primer prikazuje, da tudi v primeru neuspešnega iskanja #x# vseeno pridobimo nekaj pomembnih informacij. Imenujmo vozlišči #z# oz.\ #z'# zadnji vozlišči, pri katerima se je zgodil primer~1 oz.\ primer~2. Opazimo, da je #z.x# najmanjša vrednost v drevesu, ki je še večja od #x# in #z'.x# največja vrednost v drevesu, ki je še manjša od #x#. Tako lahko v #BinarySearchTree# sprogramiramo funkcijo #find(x)#, da vrne najmanjšo vrednost, shranjeno v drevesu, ki je večja ali enaka #x#:
\codeimport{ods/BinarySearchTree.find(x)}

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-2} &
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-3} \\
    (a) & (b)
    \end{tabular}
  \end{center}
  \caption{Primer (a)~uspešnega iskanja (za $6$) ter (b)~neuspešnega iskanja (za $10$) v dvojiškem iskalnem drevesu.}
  \figlabel{bst-search}
\end{figure}


\subsection{Vstavljanje}

Pri vstavljanju nove vrednosti #x# v dvojiško iskalno iskalno drevo najprej poiščemo #x# v drevesu. Če ga najdemo, potem vstavljanje ni potrebno. V nasprotnem primeru pripnemo #x# k zadnjemu vozlišču #p#, ki smo ga obiskali med iskanjem vrednosti #x#. Ali je novo vozlišče levi ali desni otrok vozlišča #p#, je odvisno od rezultata primerjave med #x# ter #p.x#.
\codeimport{ods/BinarySearchTree.add(x)}
\codeimport{ods/BinarySearchTree.findLast(x)}
\codeimport{ods/BinarySearchTree.addChild(p,u)}
Primer vstavljanja je prikazan na sliki \figref{bst-insert}. Najbolj časovno zahteven del vstavljanja je iskanje vozlišča #p#. Čas iskanja je sorazmeren z višino novo vstavljenega vozlišča #u#. V najslabšem primeru je ta enak višini drevesa.

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-4} &
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-5} 
    \end{tabular}
  \end{center}
  \caption{Vstavljanje vrednosti $8{,}5$ v dvojiško iskalno drevo.}
  \figlabel{bst-insert}
\end{figure}

% TODO: Matevž&Bojan proofreading prvič (13. 11. 2014).

\translatedby{Anže Pratnemer}{sl}
\subsection{Brisanje}

Brisanje vrednosti, ki jo hrani vozlišče #u# v strukturi #BinarySearchTree# je malce težje. Če je #u# list potem preprosto odstranimo #u# iz seznama otrok njegovega starša. V primeru, da ima #u# samo enega otroka lahko odstranimo #u# iz drevesa tako, da #u.parent# posvoji #u#-jevega otroka(glej
\figref{bst-splice}):
\codeimport{ods/BinarySearchTree.splice(u)}

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bst-splice}
  \end{center}
  \caption{Brisanje lista ($6$) ali vozlišča z enim otrokom ($9$) je preprosto.}
  \figlabel{bst-splice}
\end{figure}

Brisanje pa se zakomplicira, ko ima #u# dva otroka. V tem primeru je najlažje poiskati neko vozlišče #w#, ki ima manj kot dva otroka, ter da #w.x# lahko zamenja #u.x#. Za ohranjanje lastnosti dvojiškega iskalnega drevesa mora biti vrednost #w.x# blizu vrednosti #u.x#.  Na primer: če bi izbrali #w# tako, da je #w.x# najmanjša vrednost, ki je večja od #u.x#, bi delovalo.  Iskanje primernega vozlišča #w# je preprosto: to je najmanjša vrednost, ki se nahaja v poddrevesu #u.right#.  To vozlišče lahko brez skrbi odstranimo, ker nima levega otroka (glej \figref{bst-remove}).
\codeimport{ods/BinarySearchTree.remove(u)}

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-delete-1}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-delete-2}
    \end{tabular}
  \end{center}
  \caption[Brisanje iz dvojiškega iskalnega drevesa]{Brisanje neke vrednosti ($11$) iz nekega vozlišča #u#, ki ima dva otroka, počnemo z zamenjavo #u#-jeve vrednosti z najmanjšo vrednostjo v #u#-jevem desnem poddrevesu.}
  \figlabel{bst-remove}
\end{figure}

\subsection{Povzetek}

Vsaka izmed funkcij #find(x)#, #add(x)# ter #remove(x)# v strukturi #BinarySearchTree# vključuje sledenje neki poti od korena pa do nekega vozlišča v drevesu. Brez dodatnega znanja o obliki drevesa je težko karkoli povedati o dolžini te poti, razen tega, da je pot manjša kot #n# - število vseh vozlišč v drevesu. Sledeči izrek povzame zmožnosti podatkovne strukture #BinarySearchTree#:

\begin{thm}\thmlabel{bst}
  #BinarySearchTree# implementira #SSet# vmesnik ter podpira funkcije #add(x)#, #remove(x)# ter #find(x)# v $O(#n#)$ časa na operacijo.
\end{thm}

\thmref{bst} se slabo primerja z \thmref{skiplist}, ki prikazuje, da struktura #SkiplistSSet# lahko implementira #SSet# vmesnik z pričakovanim časom $O(\log #n#)$ na operacijo.  Problem strukture #BinarySearchTree# tiči v tem, da lahko postane \emph{neuravnoteženo}. Namesto da drevo izgleda kot na \figref{bst}, lahko izgleda kot dolga veriga z #n# vozlišči, ki imajo po točno enega otroka, razen zadnjega, ki nima nobenega.

Obstaja več načinov, kako se izogniti strukturi #BinarySearchTree#, ki je neuravnotežena. Vsi načini vodijo v podatkovne strukture, ki imajo operacije s časom $O(\log #n#)$. V \chapref{rbs} pokažemo, kako lahko dosežemo operacije z \emph{pričakovanim} časom $O(\log #n#)$ s pomočjo naključnosti. V \chapref{scapegoat} pokažemo, kako dosežemo operacije z \emph{amortiziranim} časom $O(\log #n#)$ s pomočjo delnih obnovitvenih operacij. V \chapref{redblack} pokažemo, kako dosežemo operacije z \emph{najslabšim} časom $O(\log #n#)$ s pomočjo simulacije dreves, ki niso dvojiška: eno v katerem imajo vozlišča lahko do štiri otroke.

%prevedeno po angleški verziji 0.1G z dne 2. april 2014
\section{#BinaryTree#: Razprava in vaje}
Dvojiška drevesa se že tisočletja uporabljajo za predstavitev razmerij med elementi. Med drugim se uporabljajo tudi za prikaz družinskih dreves (rodovnika).
\index{family tree}%
\index{pedigree family tree}%
Vzemimo primer, koren drevesa je oseba A. Levi in desni otrok osebe A sta njena starša in sta vozlišči drevesa; zgodba se naprej ponavlja za vsako vozlišče rekurzivno v globino. V zadnjih stoletjih se uporabljajo tudi v biologiji, natančneje za prikaz vrst v drevesni strukturi, kjer listi drevesa predstavljajo obstoječe vrste, vozlišča znotraj drevesa pa dogodke v razvoju, kjer se iz ene razvijeta dve novi vrsti (\emph{angl: speciation event}).

V petdesetih letih 19. st. so raziskovalci odkrili dvojiška iskalna drevesa. Več o dvojiških iskalnih drevesih lahko preberete v nadaljevanju.

Ko se srečamo z implementacijo dvojiških dreves, zlasti če le-te gradimo z ničle, se moramo dogovoriti za nekaj pravil. Eno izmed pravil je vprašanje: naj vozlišča drevesa vsebujejo kazalce na svoje starše ali ne? Če večina operacij na drevesu poteka od korena do listov, potem kazalcev ne potrebujemo. Po drugi strani pa to pomeni, da moramo t.i. sprehode po drevesu implementirati rekurzivno ali pa z uporabo posebnih skladov. Pomanjkanje kazalcev se pozna tudi v nekaterih drugih metodah, kot sta npr. vstavljanje in brisanje elementov iz dvojiškega drevesa, kjer se brez kazalcev njuna implementacija močno zaplete.

Drugo pravilo govori o tem kako v vozlišču hraniti kazalce na starša ter levega in desnega otroka. Ena možnost je, da so kazalci shranjeni kot spremenljivke. Druga možnost je, da jih hranimo v tabeli #p#, ki je dolžine 3 tako, da je vrednost #u.p[0]# levi otrok vozlišča #u#, vrednost #u.p[1]# je desni otrok vozlišča #u#, vrednost #u.p[2]# pa je starš vozlišča #u#. Z uporabo tabele kazalcev tudi omogočimo poenostavitev nekaterih zaporedij #if# stavkov v algebraične izraze.

Takšno poenostavitev lahko opazimo ob sprehodu po drevesu. Ko naletimo na vozlišče #u# iz tabele #u.p[i]#, je naslednje vozlišče v sprehodu $#u.p#[(#i#+1)\bmod 3]$. Podoben primer nastopi, ko v drevesu nimamo levo-desne simetrije. Npr. sorojenec (tj. brat) vozlišča #u.p[i]# je $#u.p#[(#i#+1)\bmod 2]$. Takšen trik deluje, če je vozlišče #u.p[i]# levi otrok ($#i#=0$) ali desni otrok ($#i#=1$) vozlišča #u#. S tem nam ni več potrebno pisati \emph{leve} in \emph{desne} kode (tj. dve različni kodi za urejanje leve in desne strani drevesa), temveč lahko vse združimo v en sam košček kode. Kot primer si lahko ogledate metodi #rotateLeft(u)# in #rotateRight(u)# na strani~\pageref{page:rotations}.\\[1\baselineskip]

\begin{exc}
Dokažite, da ima dvojiško drevo s številom vozlišč $#n#\ge 1$ $#n#-1$ povezav.\\[1\baselineskip]
\end{exc}

\begin{exc}
Dokažite, da ima dvojiško drevo s številom notranjih vozlišč $#n#\ge 1$ $#n#+1$ zunanjih vozlišč (listov).\\[1\baselineskip]
\end{exc}

\begin{exc}
Privzemimo, da imamo dvojiško drevo #T# z vsaj enim listom. Dokažite bodisi, da: a) ima koren drevesa največ enega otroka bodisi b), da ima drevo #T# več kot en list.\\[1\baselineskip]
\end{exc}

\begin{exc}
Implementirajte nerekurzivno metodo $size2(#u#)$, ki izračunava velikost podrevesa vozlišča u.
\end{exc}

\begin{exc}
Napišite nerekurzivno metodo $height2(#u#)$, ki izračunava višino vozlišča u v dvojiškem drevesu.
\end{exc}

\begin{exc}
Dvojiško drevo je uravnoteženo, če za vsako vozlišče $#u#$ velja, da se višina njegovih poddreves z vozliščem $#u.left#$ in $#u.right#$ razlikuje za največ ena. Napišite rekurzivno metodo $isBalanced()$ katera testira, če je drevo uravnoteženo. Metoda mora imeti časovno zahtevnost $O(#n#)$. (Priporočeno je, da kodo testirate na nekaj velikih drevesih z različnimi oblikami. Metodo s časovno zahtevnostjo veliko večjo od $O(#n#)$ je dosti lažje napisati.)

Premi pregled (pre-order) po dvojiškem drevesu je sprehod, ki obišče vsako vozlišče $#u#$ pred svojimi otroci.
Vmesni pregled (in-order) pogleda najprej levega otroka potem koren in nato še desnega otroka. Dobljeni vrstni red je sortiran.
Obratni pregled (post-order) obišče koren $#u#$ šele po tem, ko obišče vsa vozlišča v svojih poddrevesih.
Glej sliko 6.10.
\end{exc}

\begin{exc}
Ustvarite podrazred BinaryTree, čigar vozlišča imajo polja za shranjevanje števil premega, obratnega in vmesnega pregleda.
Napišite rekurzivne metode $preOrderNumber()$, $inOrderNumber()$ in $postOrderNumber()$, ki ta števila pravilno dodelijo. Vse te metode morajo imeti časovno zahtevnost $O(#n#)$.
\end{exc}

\begin{exc}\exclabel{tree-traversal}
Napišite nerekurzivno metode $nextPreOrder(#u#)$, $nextInOrder(#u#)$ in $nextPostOrder(#u#)$, ki vračajo vozlišče katero sledi $#u#$ v premem, vmesnem in obratnem pregledu. Te metode bi morale vzeti amortiziran konstanten čas.
Če začnemo pri katerem koli izbranem vozlišču, ter večkrat kličemo eno izmed teh funkcij dokler $#u#$ ni enak $null$, bi časovna zahtevnost morala biti $O(#n#)$.
\end{exc}

\begin{exc}
Recimo, da imamo dvojiško drevo s pre-, in- in post-order številkami dodeljenimi vozliščem.
Pokažite, kako se lahko te številke uporabijo za odgovor na vsako izmed naslednjih vprašanj, v konstantnem času.
\end{exc}

% slika 6.10
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/binarytree-numbering}
  \end{center}
  \caption{Pre-order, post-order, and in-order numberings of a binary tree.}
  \figlabel{binarytree-numbering}
\end{figure}
% have fun - mistakes are not our fault XD

\begin{enumerate}
  \item Ob danem vozlišču #u#, določite velikost poddrevesa, ki ima koren v #u#.
  \item Ob danem vozlišču #u#, določite globino v #u#.
  \item Ob danih dveh vozliščih #u# in #w#, določite ali je #u# prednik #w#.
\end{enumerate}


\begin{exc}
  Recimo, da imamo seznam vozlišč, ki so premo in vmesno oštevilčena. Dokažite, da obstaja največ eno 	premo/vmesno oštevilčeno drevo in pokažite, kako ga sestavimo.
\end{exc}

\begin{exc}
  Pokažite, da je lahko oblika kateregakoli dvojiškega drevesa z #n# vozlišči predstavljena z največ $2(#n#-1)$ biti. (Namig: poskusite zabeležiti, kaj se zgodi ob sprehodu, nato podatke uporabite za ponovno postavitev drevesa.)
\end{exc}

\begin{exc}
  Narišite, kaj se zgodi, ko dodamo vrednosti $3.5$ in nato 4.5 dvojiškemu iskalnemu drevesu v \figref{bst}.
\end{exc}

\begin{exc}
  Narišite, kaj se zgodi, ko odstranimo vrednosti $3$ in nato 5 iz dvojiškega iskalnega drevesa v \figref{bst}.
\end{exc}

\begin{exc}
  Izvedite #BinarySearchTree# metodo, #getLE(x)#,
  ki vrne seznam vseh členov, ki so manjši ali enaki #x#. Čas izvajanja vaše metode, bi moral biti $O(#n#'+#h#)$, kjer je $#n#'$ število členov, ki so manjši ali enaki #x# in #h#
  je višina drevesa.
\end{exc}

\begin{exc}
  Opišite, kako dodamo elemente $\{1,\ldots,#n#\}$ prvotno praznemu #BinarySearchTree# tako, da ima končno drevo višino $#n#-1$. Na koliko načinov je to mogoče narediti?
\end{exc}

\begin{exc}
  Če imamo neko #BinarySearchTree# in izvedemo operaciji #add(x)#, ki ji sledi #remove(x)# (z enako vrednostjo #x#), ali se nujno povrnemo v prvotno drevo?
\end{exc}

\begin{exc}
  Ali lahko #remove(x)# operacija poveča višino kateregakoli vozlišča v #BinarySearchTree#? In če da, za koliko?
\end{exc}

\begin{exc}
  Ali lahko #add(x)# operacija poveča višino kateregakoli vozlišča v #BinarySearchTree#? Ali lahko poveča višino drevesa? Če da, za koliko?
\end{exc}

\begin{exc}
  Oblikujte in izvedite različico #BinarySearchTree#, v kateri vsako vozlišče #u#, vzdržuje vrednosti #u.size# (velikost poddrevesa, ki ima koren v vozlišču #u#), #u.depth# (globino od #u#), in #u.height# (višino poddrevesa, s korenom v #u#).

  Te vrednosti vzdržujemo tudi ob klicu #add(x)# in #remove(x)# operacij, ampak to ne sme povečati ceno operacij za več kakor neko konstanto vrednost.
\end{exc}
