\chapter{Zgoščevalne tabele}
\chaplabel{hashtables}
\chaplabel{hashing}


\section{#LinearHashTable#: Linearno naslavljanje}
\translatedby{Igor Plavšić}{sl}

\subsection{Povzetek}
\translatedby{Igor Plavšić}{sl}
Spodnji izrek je povzetek časovnih zahtevnosti, metod, podatkovne strukture #LinearHashTable#:

\begin{thm}\thmlabel{linear-probing}
  #LinearHashTable# implementira vmesnik #USet#.  Če ignoriramo
  ceno klicev metode #resize()#, je pričakovana časovna zahtevnost metod 
  #add(x)#, #remove(x)#, in #find(x)#, podatkovne strukture #LinearHashTable#,
  enaka $O(1)$.  

  Če začenjamo z prazno #LinearHashTable#, velja, da za 
  katero koli zaporedje $m$ operacij metod #add(x)# in #remove(x)#, 
  porabimo $O(m)$ časa za klice metode #resize()#.
\end{thm}

\subsection{Tabelarno zgoščevanje}
\translatedby{Igor Plavšić}{sl}
\seclabel{tabulation}

\index{tabulation hashing}%
Med analizo podatkovne strukture #LinearHashTable#, smo naredili zelo
močno predpostavko:  Da so za katero koli množico elementov, 
$\{#x_1#,\ldots,#x_n#\}$, zgoščevalne vrednosti $#hash(x_1)#,\ldots,#hash(x_n)#$
neodvisno in uniformno razporejene po množici $\{0,\ldots,#t.length#-1\}$.  
En način, kako to doseči je, da hranimo ogromno polje, #tab#, dolžine $2^{#w#}$,
kjer je vsak zapis naključno #w#-bitno celo število, neodvisno od vseh ostalih zapisov.  
Na ta način bi lahko implementirali #hash(x)#, tako da bi izbrali #d#-bitno celo število 
iz tabele #tab[x.hashCode()]#:
\codeimport{ods/LinearHashTable.idealHash(x)}

Na žalost, je hranjenje polja velikosti $2^{#w#}$ neoptimalna rešitev, 
kar se tiče prostorke porabe.  Pristop, ki ga uporablja 
\emph{tabulation hashing} je, da #w#-bitna cela števila obravnava kot 
cela števila, ki jih sestavljajo $#w#/#r#$ celih števil, ki imajo samo
$#r#$ bitov. Tako, pri tabelarnem zgoščevanju potrebujemo samo  $#w#/#r#$ 
polj velikosti $2^{#r#}$.  Vsi zapisi v teh poljih so neodvina #w#-bitna 
cela števila.  Da pridobimo vrednost #hash(x)#, razdelimo #x.hashCode()# 
v $#w#/#r#$ #r#-bitnih celih števil ter jih uporabimo kot indekse za polja.  
Nato vse te vrednosti združimo z bitnim operatorjem izključni-ali(XOR), 
da pridobimo #hash(x)#.
Spodnja programska koda prikazuje kako to deluje za $#w#=32$ in $#r#=4$:
\codeimport{ods/LinearHashTable.hash(x)}
V temu primeru je #tab# dvodimenzionalno polje s štirimi stolpci in $2^{32/4}=256$ vrsticami.

Enostavno lahko preverimo, da je, za poljubni #x#, #hash(x)# enakomerno razporejen 
čez $\{0,\ldots,2^{#d#}-1\}$.  Z malo dodatnega dela, lahko tudi preverimo, da ima 
poljubni par vrednosti, neodvisne zgoščene vrednosti. 
To pomeni, da bi se za implementacijo #ChainedHashTable#, namesto zgoščevalne funkcije - metode množenja 
uporabilo tabelatno zgoščevanje.

Dejstvo, da ima poljubna množica #n# različnih vrednosti množico #n# neodvisnih 
zgoščenih vrednosti ne velja.  Ne glede na to, pa velja, da ko uporabljamo tabelarno zgoščevanje, 
še vedno velja meja \thmref{linear-probing}.  
Reference za to lahko najdete na koncu tega poglavja.

% Podpoglavje 5.3
\section{Zgoščevalne vrednosti}
\translatedby{Andrej Rolih}{sl}

\index{Zgoščevalne vrednosti}%
Zgoščevalne tabele, ki smo si jih pogledali v prejšnjem podpoglavju se uporabljajo za povezovanje podatkov s celoštevilskimi ključi sestavljenimi iz #w# bitov. Velikokrat pa uporabljamo ključe, ki niso cela števila. Lahko so nizi znakov, objekti, tabele ali ostale sestavljene strukture. Da lahko uporabimo zgoščevalne funkcije na takih tipih podatkov moramo prej preslikati te podatke v #w#-bitne zgoščevalne vrednosti. Preslikave zgoščevalnih funkcij morajo imeti naslednje lastnosti:

\begin{enumerate}
  \item Če sta #x# in #y# enaka, potem morata biti enaka tudi #x.hashCode()# in #y.hashCode()# .

  \item Če #x# in #y# nista enaka, potem mora biti verjetnost, da sta
  $#x.hashCode()#=#y.hashCode()#$ majhna (blizu
  $1/2^{#w#}$).
\end{enumerate}

Prva lastnost nam zagotavlja, da če v zgoščevalni tabeli hranimo #x# in kasneje iščemo vrednost #y# (ki je enaka #x# ), da bomo našli #x# . Druga lastnost pa nam preprečuje izgubo podatkov pri pretvarjanju objektov v cela števila. Zagotavlja nam, da bodo različni objekti imeli različno zgoščevalno vrednost in bodo tako zelo verjetno shranjeni na različnih mestih v naši zgoščevalni tabeli. 

\subsection{Zgoščevalne vrednosti osnovnih podatkovnih tipov}

\index{Zgoščevalne vrednosti osnovnih podatkovnih tipov}%
Za majhne osvnovne podatkovne tipe kot so #char#, #byte#, #int#, in #float# lahko ponavadi hitro najdemo zgoščevalno vrednost. Ti podatkovni tipi imajo vedno binarno predstavitev sestavljeno iz #w# ali manj bitov. \javaonly{(V Javi je, #byte# 8-bitni podatkovni tip in #float# 32-bitni.)}\cpponly{(V C++ #char# ponavadi 8-bitni in #float# 32-bitni.)} . V teh primerih te bite obravnavamo kot cela števila na intervalu $\{0,\ldots,2^#w#-1\}$ . Če sta dve vrednosti različni potem dobijo različni zgoščevalni vrednosti. Če sta vrednosti enaki pa dobita enako zgoščevalno vrednost.

Nekateri podatkovni tipi pa so sestavljeni iz več kot #w# bitov. Ponavadi $c#w#$ bitov za neko konstantno celo število $c$ . (V Javi sta #long# in #double# primera tipov pri katerih je $c=2$.) Te podatkovne tipe lahko obravnavamo kot  objekte sestavljene iz $c$ delov, kot je opisano v naslednjem podpoglavju.

\subsection{Zgoščevalne vrednosti sestavljenih podatkovnih tipov}
\seclabel{stringhash}

\index{Zgoščevalne vrednosti sestavljenih podatkovnih tipov}%
Za sestavljene objekte si želimo zgraditi zgoščevalno funkcijo, ki bi kombinirala zgoščevalne vrednosti podatkovnih tipov, ki ta objekt sestavljajo. Vendar pa to ni tako enostavno kot zveni. Kljub temu, da lahko najdemo kar nekaj bljižnic s katerimi to lahko naredimo (na primer sestavljanje zgoščevalnih vrednosti z operacijo XOR) pa to ni rešitev problema, saj lahko hitro pridemo do primerov kjer take bljižnice odpovedo (glej naloge ~\ref{exc:hash-hack-first}--\ref{exc:hash-hack-last}). A vendar obstajajo hitri in robustni načini reševanja tega problema, če si lahko privoščimo računanje z $2#w#$ bitno natančnostjo. Zamislimo si objekt sestavljen iz delov $P_0,\ldots,P_{r-1}$ katerih zgoščevalne vrednosti so $#x#_0,\ldots,#x#_{r-1}$. Potem si lahko izberemo neodvisna in naključna  #w#-bitna števila $#z#_0,\ldots,#z#_{r-1}$ in eno liho in naključno celo število #z# sestavljeno iz $2#w#$ bitov. Iz tega lahko izračunamo zgoščevalno vrednost za naš objekt na naslednji način:
\[
   h(#x#_0,\ldots,#x#_{r-1}) =  
   \left(\left(#z#\sum_{i=0}^{r-1} #z#_i #x#_i\right)\bmod 2^{2#w#}\right)
   \ddiv 2^{#w#} \enspace .
\]

%naslednji prevajalec naj nadaljuje od tu