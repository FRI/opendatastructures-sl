\translatedby{Jan Štrekelj}{sl}
\chapter{Preskočni seznami}

\chaplabel{skiplists}

V tem poglavju bomo govorili o lepi podatkovni strukturi: preskočnem seznamu, ki ima veliko možnosti uporabe. Z uporabo preskočnega seznama lahko implementiramo #List#, ki ima $O(\log n)$ časovno implementacijo #get(i)#, #set(i,x)#,
#add(i,x)#, and #remove(i)#. Prav tako lahko implementiramo #SSet#, v katerem vse operacije potrebujejo $O(\log #n#)$ pričakovanega časa.
%Nazadnje je preskočni seznam lahko uporabljen za implementacijo #Rope#, kjer se vse operacije izvedejo v
% $O(\log #n#)$.

Učinkovitost preskočnega seznama je povezana z njegovo naključnostjo. Ko je nov element dodan preskočnemu seznamu, ta uporabi metodo metanja kovanca za določitev višine novega elementa. Učinek preskočnega seznama je odvisen od pričakovanih izvajanj in dolžine poti. To pričakovanje pa je povezano z uporabo metode meta kovanca. V implementaciji je metoda meta kovanca simulirana z uporabo namenskega generatorja.


\section{Osnovna struktura}

\index{preskočni seznam}%

Konceptualno je preskočni seznam sekvenca enojno povezanih seznamov $L_0,\ldots,L_h$.Vsak seznam $L_r$ vsebuje podniz elementov v $L_{r-1}$. Začnimo z vhodnim seznamom $L_0$, ki vsebuje #n# elementov in naredimo $L_1$ iz $L_0$, $L_2$ iz $L_1$, in tako naprej.
Elementi v $L_r$ so pridobljeni z metanjem kovanca za vsak element, #x#, v $L_{r-1}$ in dodajo #x# v $L_r$, če kovanec "pokaže" glavo. To delamo, dokler ne naredimo praznega seznama $L_r$. Primer preskočnega seznama je prikazan na sliki \figref{skiplist}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist}
  \end{center}
  \caption{Preskočni seznam s sedmimi elementi.}
  \figlabel{skiplist}
\end{figure}

Za vsak element #x#, v preskočnem seznamu imenujemo \emph{višina}
\index{height!of a skiplist}%
 #x# največjo vrednost $r$, kjer se #x# pojavi v $L_r$.  Tako imajo na primer elementi, ki se pojavijo samo v $L_0$, višino $0$. Če pomislimo, ugotovimo, da je višina #x# ustreza naslednjemu eksperimentu:  Mečimo kovanec tako dolgo, dokler ne bo pokazal cifre. Kolikokrat je pokazal glavo? Odgovor, ne presenetljivo, je, da je pričakovana višina vozlišča enaka 1. (Pričakovali smo, da bomo kovanec vrgli dvakrat, da dobimo cifro, vendar nismo šteli zadnjega meta). \emph{Višina} preskočnega seznama je višina njegovega najvišjega vozlišča.

Na koncu vsakega seznama je posebno vozlišče, imanovano \emph{stražar} \index{sentinel node}%, ki predstavlja statista za seznam. Glavna lastnost preskočnega seznama je, da obstaja kratka pot, imanovana \emph{pot iskanja}, 
\index{search path!in a skiplist}%
od stražarja v $L_h$ do vsakega vozlišča v $L_0$.  Narediti pot iskanja za posamezno vozlišče #u#je preprosto (glej \figref{skiplist-searchpath})
: Začnemo v zgornjem levem kotu preskočnega seznama (stražar je v $L_h$) in se premikamo desno toliko časa, dokler ne gremo preko vozlišča #u#, nato pa se premaknemo korak nižje v spodnji seznam.

Natančneje, za izdelati pot iskanja za vozlišče #u# v $L_0$, začnemo pri stražarju #w# v $L_h$. Nato izvedemo #w.next#. Če #w.next# vsebuje element, ki se pojavi pred #u# v $L_0$, nastavimo $#w#=#w.next#$, sicer se premaknemo navzdol in nadaljujemo iskanje pojavitve #w# v seznamu $L_{h-1}$.  Postopek ponavljamo dokler na dosežemo predhodnika od #u# v $L_0$. 
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-searchpath}
  \end{center}
  \caption{The search path for the node containing $4$ in a skiplist.}
  \figlabel{skiplist-searchpath}
\end{figure}

Rešitev, ki si jo bomo podrobneje pogledali v \secref{skiplist-analysis},
nam pokaže, da je pot iskanja dokaj kratka:

\begin{lem}\lemlabel{skiplist-searchpath}
Pričakovana dolžina poti iskanja  za vsako vozlišče #u# v $L_0$ je največ $2\log #n# + O(1) = O(\log #n#)$.
\end{lem}

Prostorsko učinkovit način za implementacijo preskočnega seznama je ta, da definiramo #Vozlisce#,
#u#, ki je sestavljen iz podatka #x# in polja kazalcev #next#, kjer #u.next[i]# kaže na naslednika #u#-ja v seznamu $L_{#i#}$.  Na ta način je podatek #x# v vozlišču \javaonly{referenciran}\cpponly{stored} samo enkrat, čeprav se #x# pojavlja v različnih seznamih.

\javaimport{ods/SkiplistSSet.Node<T>}
\cppimport{ods/SkiplistSSet.Node}

V naslednjih dveh podpoglavjih tega poglavja bomo govorili o dveh različnih uporabah preskočnih seznamov. Pri obeh je $L_0$ shranjena glavna struktura (seznam elementov ali sortiran niz elementov). Glavna razlika med temi dvemi strukturami je v načinu premikanja po poti iskanja; drugače povedano, razlikujeta se v tem, kako se odločajo, ali gre pot iskanja do $L_{r-1}$ ali le do $L_r$.

\section{#SkiplistSSet#: Učinkovit #SSet#}
\seclabel{skiplistset}

\index{SkiplistSSet@#SkiplistSSet#}%
#SkiplistSSet# uporablja preskočni seznam za implementirati #SSet# vmesnik. Ko ga uporabljamo na ta način, so v seznamu $L_0$ shranjeni elementi #SSet#-a v urejenem vrstnem redu. Metoda #find(x)# deluja tako, da sledi poti iskanja za najmanjšo vrednostjo #y#, kjer je $#y#\ge#x#$:

\codeimport{ods/SkiplistSSet.find(x).findPredNode(x)}

Sledenje poti iskanja za #y# je preprosto: ko se nahajamo v določenem vozlišču #u# v $L_{#r#}$, pogledamo v desno z #u.next[r].x#. Če je $#x#>#u.next[r].x#$, se premaknemo za eno mesto v desno v $L_{#r#}$; sicer se premaknemo navzdol v $L_{#r#-1}$. Vsak korak (desno ali navzdol) v takem iskanju potrebuje konstanten čas; potemtakem, po \lemref{skiplist-searchpath}, je pričakovani čas izvajanja #find(x)# enak $O(\log #n#)$.

Preden lahko dodamo element v #SkipListSSet#, potrebujemo metodo, ki nam bo simulirala met kovanca za določitev višine #k# novega vozlišča. To naredimo tako, da si izberemo poljubno število #z# in štejemo število zaporednih enic v binarnem zapisu števila  #z#:\footnote{Ta metoda ne ponazarja popolnoma eksperiment metanja kovanca saj bo vrednost #k# vedno manjša od števila bitov v #int#. Kakorkoli, to bo imelo malenkosten vpliv dokler ne bo število elementov v strukturi veliko večje kot $2^{32}=4294967296$.}

\codeimport{ods/SkiplistSSet.pickHeight()}

Za implementirati metodo #add(x)# v #SkiplistSSet# smo najprej poiskali #x# in ga nato dodali v več seznamov $L_0$,\ldots,$L_{#k#}$, kjer je #k# izbran  s pomočjo #pickHeight()# metode. Najlažji način za narediti to je s pomočjo polja, #sklad#, ki hrani sled vozlišč, kjer se je pot iskanja spustila iz seznama $L_{#r#}$ v $L_{#r#-1}$. Natančneje, #sklad[r]# je vozlišče v $L_{#r#}$ kjer se je pot iskanja nadaljevala  en nivo nižje, v seznamu $L_{#r#-1}$. Vozlišča, ki smo jih prilagodili za vstaviti #x# so točno vozlišča $#stack[0]#,\ldots,#stack[k]#$. Koda v nadaljevanju prikazuje implementacijo algoritma za #add(x)#:
\label{pg:skiplist-add}
\codeimport{ods/SkiplistSSet.add(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-add}
  \end{center}
  \caption[Adding to a skiplist]{Dodajanje vozlišča $3.5$ v preskočni seznam.  Vozlišča shranjena v #sklad#
  so označena.}
  \figlabel{skiplist-add}
\end{figure}

Brisanje elementa #x# je podobno vstavljanju, le da pri tej metodi ni potrebe po #skladu# za hranjenje poti iskanja. Brisanje je lahko opravljeno s sledenjem poti iskanja. Ko iščemo #x#, vedno ko se premaknemo korak navzdol iz vozlišča #u#, preverimo, če je $#u.next.x#=#x#$ in če je, odstranimo #u# iz seznama:
\codeimport{ods/SkiplistSSet.remove(x)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-remove}
  \end{center}
  \caption{Brisanje vozlišča $3$ iz preskočnega seznama.}
  \figlabel{skiplist-remove}
\end{figure}

\subsection{Povzetek}

Naslednji teorem povzema uporabnost preskočnega seznama, ko ga uporabljamo za implementacijo sortiranih nizov:

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet# je uporabljen za implementacijo #SSet# vmesnika. #SkiplistSSet# opravi  operacije #add(x)# (dodaj), #remove(x)# (odstrani) in #find(x)# (najdi) v $O(\log #n#)$ pričakovanega časa za operacijo.
\end{thm}

\translatedby{Tadej Dragutinovič}{sl}
\subsection{Summary}

Sledeči teorem povzema uporabnost preskočnega seznama, ko ga uporabljamo pri implementaciji urejenih sklopov:

\begin{thm}\thmlabel{skiplist}
#SkiplistSSet# implementira #SSet# vmesnik. A #SkiplistSSet# vsebuje operacije #add(x)#, #remove(x)#, and #find(x)# in $O(\log #n#)$
pričakovani čas za izvedbo operacije.
\end{thm}

\section{#SkiplistList#: Učinkovit naključni dostop #List#}
\seclabel{skiplistlist}

\index{SkiplistList@#SkiplistList#}%
A #SkiplistList# implementira #List# vmesnik s pomočjo(uporabo) preskočnega seznama.
V #SkiplistList#, $L_0$ vsebuje elemente seznama po vrstnem redu pojavljanja  elementov.
 Po drugi strani
#SkiplistSSet#, elemente lahko dodajamo, brišemo ali do njih dostopamo v $O(\log
#n#)$ časa.

Za doseganje tega, potrebujemo možnost iskanja poti 
#i#th elementa v $L_0$.  Najlažji način je definirati notacijo
 the \emph{length} od roba nekega seznama, $L_{#r#}$.
Vsak rob seznama definiramo $L_{0}$ kot 1.  Dolžina robu, #e#,
v $L_{#r#}$, $#r#>0$, je definiran kot vsota dolžin robov pod njim #e#
v $L_{#r#-1}$.  Ekvivalenčno, dolžina  #e# je
število robov v $L_0$ spodaj #e#.  Poglej \figref{skiplist-lengths} za primer preskočnega seznama z dolžino njegovih robov. Posledica shranjevanja robov preskočnega seznama v nizih, lahko dolžino shranjujemo na enak način:

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-lengths}
  \end{center}
  \caption{The lengths of the edges in a skiplist.}
  \figlabel{skiplist-lengths}
\end{figure}

\codeimport{ods/SkiplistList.Node}

Povzetek te opredelitve dolžin je da smo trenutno na vozlišču, ki se nahaja na poziciji
#j# v $L_0$ in sledimo robu dolžine $\ell$, nato se premaknemo na vozlišče čigar pozicija v $L_0$,
je $#j#+\ell$.  Po takem postopku, medtem ko iščemo iskalno pot lahko ohranjamo
vrednost pozicije, #j#, trenutnega vozlišča v $L_0$.  Medtem ko na vozlišču, #u#, v $L_{#r#}$, gremo desno če #j# plus dolžina  roba
#u.next[r]# je manj kakor #i#. V nasprotnem primeru, gremo navzdol v  $L_{#r#-1}$.

\codeimport{ods/SkiplistList.findPred(i)}
\codeimport{ods/SkiplistList.get(i).set(i,x)}

Ker je najtežji del operacij #get(i)# in #set(i,x)# 
iskanje #i#th vozlišča v $L_0$, se operacije izvedejo v 
$O(\log #n#)$ časa.

Dodajanje elementa v  #SkiplistList# na pozicijo, #i#, je enostavno.  
Za razliko dodajanje v  #SkiplistSSet#, smo prepričani da bo vozlišče
Dejansko dodano, zato lahko hkrati dodajamo in iščemo lokacijo za  novo  
vozlišče. Najprej izberemo višino, #k#,
novo dodanega vozlišča  #w#, nato sledimo iskalni poti #i#.
Vsakič ko se iskalna pot premakne navzdol od $L_{#r#}$ z $#r#\le #k#$, uporabimo
 spoj #w# v $L_{#r#}$.  Dodatno moremo biti pozorni da se dolžina robov
pravilno osvežuje.  Poglej \figref{skiplist-addix}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-addix}
  \end{center}
  \caption[Adding to a SkiplistList]{Adding an element to a #SkiplistList#.}
  \figlabel{skiplist-addix}
\end{figure}

Pozorni moremo biti, da vsakič ko se iskalna pot premakne za eno vozščišče navzdol, #u#, v $L_{#r#}$,
se dolžina roba #u.next[r]# poveča za ena, ker dodajamo element pod rob na poziciji #i#.  
Spojimo vozlišče #w# med vozlišča,
#u# in #z#, deluje kakor prikazano v  \figref{skiplist-lengths-splice}.  Medtem
Ko sledimo iskalni poti, tudi shranjujemo pozicijo 
#j#, od #u# v $L_0$.  Zato, vemo da je dolžina roba od 
#u# do #w#  velikosti  $#i#-#j#$.  Sklepamo lahko da je razdalja roba 
od #w#  do #z# iz dolžine, $\ell$, od roba  #u# do #z#.
Potemtakem, lahko spojimo v #w# in osvežimo dolžine od robov v konstantnem času. 

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/skiplist-lengths-splice}
  \end{center}
  \caption[Adding to a SkiplistList]{Updating the lengths of edges while splicing a node
   #w# into a skiplist.}
  \figlabel{skiplist-lengths-splice}
\end{figure}

Postopek izgleda veliko bolj zakompliciran kot v resnici je. Koda je pravzaprav zelo enostavna:

\codeimport{ods/SkiplistList.add(i,x)}
\codeimport{ods/SkiplistList.add(i,w)}


Do sedaj bi vam morala biti implementacija #remove(i)# operacije v #SkiplistList# jasna.  Iščemo iskalno pot vozlišča na poziciji #i#.  Vsakič ko se iskalna pot zmanjša za ena od vozlišča #u#, na ravni #r# zmanjšamo radaljo od roba, tako da pustimo #u# na tistem nivoju.  Pregledovati moramo tudi, da je #u.next[r]# element ranga #i# in v kolikor držži, ga premaknemo iz seznama na tisti nivo.   Primer si lahko ogledate tukaj \figref{skiplist-removei}.
\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/skiplist-removei}
  \end{center}
  \caption[Removing an element from a SkiplistList]{Removing an element from a #SkiplistList#.}
  \figlabel{skiplist-removei}
\end{figure}
\codeimport{ods/SkiplistList.remove(i)}

\subsection{Summary}

Naslednji teorem povzema učinkovitost podatkovne strukture #SkiplistList#:

\begin{thm}\thmlabel{skiplistlist}
  #SkiplistList# implementira  #List# -ov vmesnik.   #SkiplistList#
  podpira operacije #get(i)#, #set(i,x)#, #add(i,x)#, ter
  #remove(i)# v $O(\log #n#)$ pričakovanem času na operacijo.
\end{thm}

%\section{Skiplists as Ropes}
%TODO: A section on ropes

\section{Analiza preskočnega seznama}
\seclabel{skiplist-analiza}

V sledečem delu bomo analizirali pričakovano višino, velikost ter dolžino
Iskalne poti v  preskočnem seznamu.  Za razumevanje potrebujemo osnovno ozadnje 
verjetnosti.  Nekateri dokazi  so osnovani na metu kovanca.


\begin{lem}\lemlabel{met kovanca}
  \index{coin toss}%
  Naj bo  $T$ število, kadar se pošten kovanec obrne navzgor, vključno s primerom kadar kovanec pade z glavo navzgor. Takrat $\E[T]=2$.
\end{lem}

\begin{proof}
  Recimo da nehamo metati kovanec prvič kadar pade z glavo navzgor.
 Definirajmo indikacijsko spremenljivko
  \[ I_{i} = \left\{\begin{array}{ll}
     0 & \mbox{če je kovanec vržen navzgor $i$ kar} \\
     1 & \mbox{če je kovanec vržen $i$ ali več krat}
     \end{array}\right.
  \]
  Upoštevajte da  $I_i=1$ če in samo če edini $i-1$ met kovanca postane rep,
  torej $\E[I_i]=\Pr\{I_i=1\}=1/2^{i-1}$.  Opazimo da  $T$, vse mete kovanca
  lahko zapišemo kot $T=\sum_{i=1}^{\infty} I_i$.
  Sledi,
  \begin{align*}
    \E[T] & =  \E\left[\sum_{i=1}^\infty I_i\right] \\
     & =  \sum_{i=1}^\infty \E\left[I_i\right] \\
     & =  \sum_{i=1}^\infty 1/2^{i-1} \\
     & =  1 + 1/2 + 1/4 + 1/8 + \cdots \\
     & =  2 \enspace .   \qedhere
  \end{align*}
\end{proof}

Naslednji hipotezi nam pokažeta da ima preskočni seznam linearno velikost:

\begin{lem}\lemlabel{skiplist-size1}
  Pričakovano število vozlišč v preskočnem seznamu vsebuje $#n#$ elementov,
če ne upoštevamo kontrolnih pojavljanj,  je $2#n#$.
\end{lem}

\begin{proof}
 Verjetnost, da je  kateri koli element, #x#, vsebovan v seznamu
  $L_{#r#}$ is $1/2^{#r#}$, so the expected number of nodes in $L_{#r#}$
  je $#n#/2^{#r#}$.\footnote{Poglej \secref{randomization} za obrazložietv kako pridemo do rezultata z uporabo indikatorja spremenljivk in linearnosti pričakovanja.}
  Sledi, da je skupno število pričakovanih vozlišč v seznamu
  \[ \sum_{#r#=0}^\infty #n#/2^{#r#} = #n#(1+1/2+1/4+1/8+\cdots) = 2#n# \enspace . \qedhere \]
\end{proof}

\begin{lem}\lemlabel{skiplist-height}
  Pričakovana višina preskočnega seznama, ki vsebuje #n# elementov je največ
  $\log #n# + 2$.
\end{lem}

\begin{proof}
  Za vsak $#r#\in\{1,2,3,\ldots,\infty\}$,
  Definiramo indicator naključnih  spremenljivk
  \[ I_{#r#} = \left\{\begin{array}{ll}
     0 & \mbox{if $L_{#r#}$ je prazen} \\
     1 & \mbox{if $L_{#r#}$ ni prazen}
     \end{array}\right.
  \]
  Višina, #h#, preskočnega seznama je
  \[
       #h# = \sum_{i=1}^\infty I_{#r#} \enspace .
  \]
  Upoštevajte, da  $I_{#r#}$ ni nikoli večji kot dolžina, $|L_{#r#}|$, od $L_{#r#}$, zato
  \[
     \E[I_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
 Zato imamo
  \begin{align*}
       \E[#h#] &= \E\left[\sum_{r=1}^\infty I_{#r#}\right] \\
        &= \sum_{#r#=1}^{\infty} E[I_{#r#}] \\
        &= \sum_{#r#=1}^{\lfloor\log #n#\rfloor} E[I_{#r#}]
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} E[I_{#r#}]  \\
        &\le \sum_{#r#=1}^{\lfloor\log #n#\rfloor} 1
                 + \sum_{r=\lfloor\log #n#\rfloor+1}^{\infty} #n#/2^{#r#} \\
        &\le \log #n#
                 + \sum_{#r#=0}^\infty 1/2^{#r#} \\
        &= \log #n# + 2 \enspace . \qedhere
  \end{align*}
\end{proof}

\begin{lem}\lemlabel{skiplist-size2}
  Pričakovano število vozlišč v preskočnem seznamu vsebuje $#n#$ elementov,
  z vsemi pojavitvami “opazovalca”, je $2#n#+O(\log #n#)$.
\end{lem}

\begin{proof}
  Po \lemref{skiplist-size1}, sledi da je pričakovano število vozlišč, brez “opazovalca”
 $2#n#$.  Število pojavitev “opaovalca” je enako višini, $#h#$, preskočnega seznama,torej
  \lemref{skiplist-height} the expected number of occurrences of the
  je “opazovalec” največ $\log #n#+2 = O(\log #n#)$.
\end{proof}



\begin{lem}
Pričakovana dolžina iskalne poti v preskočnem seznamu je največ $2\log #n# + O(1)$.
\end{lem}

\begin{proof}
  Najlažje dokažemo hipotezo tako da uporabimo \emph{reverse search
  path} za vozlišče, #x#.  Ta pot začne pri predhodniku #x#
  v $L_0$.  Kadarkoli , če  grelahko  pot eno nadstropje višje takrat lahko.  V kolikor nemore iti eno nadstropje višje, gre levo. Če nekaj trenutkov premišljujemo o tem nas bo prepričalo da je vzvratna iskalna pot za  #x# enaka iskalni poti za #x#, z razliko da je vzvratna.

  Število vozlišč, ki obiščejo vzvratno pot v nekem nadstropju
  , #r#, je povezana z naslednjim eksperimentom:  Vržimo kovanec.
  Če pade glava,se premakni navzgor, nato ustavi. V nasprotnem primeru se premakni levo in ponovi eksperiment. Številov metov kovanca, preden pade glava predstavlja število korakov v levo, ki ki jih vzvratna iskalna pot porabi v nekem nadstropju. footnote{Bodite pozorni da lahko pride do 
“overcounta” števila korakov na levo, saj se mora  eksperiment končati. Končati mora ob prvi glavi  ali ko iskalna pot doseže “opazovalca”,kateri pride prvi. To ne predstavlja problema saj leži hipoteza na  zgornji meji.} \lemref{coin-tosses} nam prikazuje da je pričakovano število metov kovanca preden pade prva “glava”, 1.

  Naj $S_{#r#}$ označuje število korakov ki jih porabi iskalna pot naprej na nadstropju
  $#r#$ ki gre levo.   Pravkar smo trdili da  $\E[S_{#r#}]\le
  1$.  Poleg tega, $S_{#r#}\le |L_{#r#}|$, ker nemoremo narediti več korakov v  $L_{#r#}$  kot je dolžina $L_{#r#}$, zato
  \[
    \E[S_{#r#}] \le \E[|L_{#r#}|] = #n#/2^{#r#} \enspace .
  \]
 Sedaj lahko dokončamo dokaz \lemref{skiplist-height}.
  Naj bo $S$ dolžina iskalne poti nekega vozlišča, #u#, v preskočnem seznamu  in naj bo $#h#$ višina preskočnega seznama. Sledi
  \begin{align*}
      \E[S]
         &= \E\left[ #h# + \sum_{#r#=0}^\infty S_{#r#} \right] \\
         &= \E[#h#] + \sum_{#r#=0}^\infty \E[S_{#r#}]  \\
         &= \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} \E[S_{#r#}]
              + \sum_{#r#=\lfloor\log #n#\rfloor+1}^\infty \E[S_{#r#}] \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{r=\lfloor\log #n#\rfloor+1}^\infty #n#/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \sum_{#r#=0}^{\lfloor\log #n#\rfloor} 1
              + \sum_{#r#=0}^{\infty} 1/2^{#r#} \\
         &\le \E[#h#] + \log #n# + 3 \\
         &\le 2\log #n# + 5  \enspace . \qedhere
  \end{align*}
\end{proof}


Sledeči teorem povzema rezultat sekcije:
\begin{thm}
Preskočni senam, ki vsebuje $#n#$ elementov je pričakoval velikost $O(#n#)$ in pričakovana dolžina iskalne poti nekega elementa je največ:
$2\log #n# + O(1)$.
\end{thm}



%\section{Iteration and Finger Search}

%TODO: Napiši to sekcijo

\section{Razprava in vaje}

Preskočne sezname je predstavil Pugh \cite{p91} ki je tudi predstavil
veliko aplikacij in razširitev preskočnih seznamov \cite{p89}.  Od takrat se
jih je veliko preučevalo.  Veliko raziskovalcev je naredilo veliko
natančnih analiz pričakovane dolžine in variance dolžine iskanja poti
za #i#ti element v preskočnem seznamu \cite{kp94,kmp95,pmp92}.
Deterministične različice \cite{mps92}, pristranske različice \cite{bbg02,esss01},
in samo-prilagodljive različice \cite{bdl08} preskočnih seznamov so se
razvile.  Implementacije preskočnih seznamov so bile napisane za različne
jezike in ogrodja in so uporabljeni v odprtokodnih podatkovnih
sistemih \cite{skipdb,redis}. Različica preskočnih seznamov je uporabljena v 
strukturah upravljanja procesov jedra operacijskega sistema HP-UX \cite{hpux}.
\javaonly{Preskočni seznami so celo del Java 1.6 API \cite{oracle_jdk6}.}


\begin{exc}
  Narišite iskalne poti za 2.5 in 5.5 v preskočnem seznamu v 
  \figref{skiplist}.
\end{exc}

\begin{exc}
  Narišite dodajanje vrednosti 0.5 (z višino 1)in nato
   3.5 (z višino 2) v preskočni seznam v \figref{skiplist}.
\end{exc}

\begin{exc}
  Narišite odstranjevanje vrednosti 1 in nato 3 iz preskočnega seznama
  v \figref{skiplist}.
\end{exc}

\begin{exc}
  Narišite izvedbo #remove(2)# v #SkiplistList#
  v \figref{skiplist-lengths}.
\end{exc}

\begin{exc}
  Narišite izvedbo #add(3,x)# v #SkiplistList#
  v \figref{skiplist-lengths}.  Predpostavi, da #pickHeight()# izbere višino
  4 za novo ustvarjeno vozlišče.
\end{exc}

\begin{exc}\exclabel{skiplist-changes}
  Pokažite da je med izvajanjem #add(x)# ali #remove(x)# operacij, pričakovano
  število kazalcev v #SkiplistSet# ki se spremenijo konstanta.
\end{exc}

\begin{exc}\exclabel{skiplist-opt}
  Predpostavite da, namesto povišanja elementa iz $L_{i-1}$ v $L_i$
  na osnovi meta kovanca, element povišamo z neko verjetnostjo $p$, $0 <
  p < 1$.
  \begin{enumerate}
   \item Pokažite, da je s to modifikacijo pričakovana dolžina
     iskalne poti največ $(1/p)\log_{1/p} #n# + O(1)$.
   \item Kakšna je vrednost $p$ ki zmanjša prejšnji izraz?
   \item Kakšna je pričakovana višina preskočnega seznama? 
   \item Kakšno je pričakovano število vozlišč v preskočnem seznamu?
  \end{enumerate}
\end{exc}


\begin{exc}\exclabel{skiplist-opt-2}
  Metoda #find(x)# v #SkiplistSet# včasih izvede
  \emph{odvečne primerjave}; Te se pojavijo kadar je #x# primerjan
  z isto vrednostjo več kot enkrat.  Pojavijo se lahko za neko vozlišče, #u#,
  $#u.next[r]# = #u.next[r-1]#$.  Pokažite kako se te odvečne primerjave
  zgodijo in priredite #find(x)# tako da se jih izognete.  Analizirajte
  pričakovano število primerjav izvedenih z vašo prirejeno #find(x)# metodo.
\end{exc}

\begin{exc}
  Zasnujte in implementirajte različico preskočnega seznama, ki implementira
  #SSet# interface, pa tudi dovoljuje hiter dostop do elementov po rangu.
  To pomeni, da tudi podpira funkcijo #get(i)#, ki vrača
  element katerega rang je #i# v $O(\log #n#)$ pričakovani časovni zahtevnosti. (Rang
  elementa #x# v #SSet# je število elementov v #SSet#
  ki so manjši od #x#.)
\end{exc}

\begin{exc}
  \index{prst}%
  \index{prstno iskanje!v preskočnem seznamu}%
  \emph{prst} v preskočnem seznamu je polje ki shranjuje 
  zaporedje vozlišč v iskalni poti kjer se iskalna pot
  spušča. (Spremenljivka #stack# v #add(x)# koda na
  strani~\pageref{pg:skiplist-add} je prst;  osenčena vozlišča v
  \figref{skiplist-add} kažejo na vsebino enega prsta.)  Na prst
  lahko gledamo kot na nekaj kar kaže pot do vozlišča v najnižjem
  seznamu, $L_0$.

  \emph{finger search} implementira #find(x)# operacijo z uporabo
  prsta, s sprehajanjem po seznamu navzgor z uporabo prsta dokler ne doseže vozlišča
  #u# tako da je $#u.x# < #x#$ in $#u.next#=#null#$ ali $#u.next.x# >
  #x#$ in nato izvajanjem noramlnega iskanja #x# začenši z #u#.
  Mogoče je dokazati da je pričakovano število potrebnih korakov
  za finger search $O(1+\log r)$, kjer je $r$ število vrednosti
  v $L_0$ med #x# in vrednostjo na katero kaže prst.

  Implementirajte podrazred od #Skiplist#, ki se imenuje #SkiplistWithFinger#, ki
  implementira #find(x)# operacije z uporabo notranjega prsta.  Podrazred naj
  hrani prst, ki je uporabljen tako da je vsaka operacija #find(x)# 
  implementirana kot prstno iskanje (finger search).  Med vsako #find(x)# operacijo
  je prst posodobljen tako da vsaka operaacija #find(x)# uporabi, kot
  začtno točko, prst ki kaže na rezultat prejšnje
  #find(x)# operacije.
\end{exc}

\begin{exc}\exclabel{skiplist-truncate}
  Zapišite metodo #truncate(i)#, ki skrajša #SkiplistList#
  na poziciji #i#.  Po izvedbi metode, je velikost
  seznama #i# in vsebuje samo elemente na indexih
  $0,\ldots,#i#-1$.  Vrnjena vrednost je nek drug #SkiplistList#, ki
  vsebuje elemente na indexih $#i#,\ldots,#n#-1$.  Metoda mora imeti
  časovno zahtevnost $O(\log #n#)$ .
\end{exc}

\begin{exc}
  Napišite #SkiplistList# metodo, #absorb(l2)#, ki sprejme
  argument #SkiplistList#, #l2#, ga izprazni in pripne njegovo vsebino,
  , urejeno, prejemniku. Naprimer, če #l1# vsebuje $a,b,c$
  in #l2# vsebuje $d,e,f$, potem bo po klicu #l1.absorb(l2)#, #l1#
  vseboval $a,b,c,d,e,f$ in #l2# bo prazen. Metoda naj ima časovno
  zahtevnost $O(\log #n#)$.
\end{exc}

\begin{exc}
  Z uporabo pristopov prostorsko učinkovitega seznama #SEList#, zasnujte
  in implementirajte prostorsko učinkovit #SSet#, #SESSet#.  Da bi to stroili, shranite
  urejene podatke v #SEList#, in bloke tega #SEList#
  v #SSet#. Če prvotna implementacija #SSet# porabi $O(#n#)$
  prosotra za shranjevanje #n# elementov, potem bo #SESSet# imel dovolj prostora
  za #n# elementov plus $O(#n#/#b#+#b#)$ odvečnega prostora.
\end{exc}

\begin{exc}
  Z uporabo #SSet# kot vašo osnovno strukturo, zasnujte in implementirajte
  aplikacijo, ki prebere (veliko) besedilno datoteko in dovoljuje interaktivno iskanje,
  za katerikoli podniz vsebovan v besedilu. Ko uporabnik vnaša svojo
  iskalno zahtevo naj se kot rezultat prikazuje ujemajoč del besedila (če obstaja).

  \noindent  Namig 1: Vsak podniz je predpona neki priponi, tako da zadošča
  shraniti vse pripone besedilne datoteke.

  \noindent Namig 2:  Vsaka pripona je lahko predstavljena strnjeno kot
  samojstojna števka, ki predstavlja kje v besedilu se pripona začne.

  \noindent Preizkusite svojo aplikacijo na veleikih besedilih, kot so na primer
  knjige dostopne na Project Gutenberg \cite{gutenberg}.  If done
  correctly, your applications will be very responsive; there should be
  no noticeable lag between typing keystrokes and seeing the results.
\end{exc}

\begin{exc}
  \index{skiplist!versus binary search tree}%
  \index{binary search tree!versus skiplist}%
  (Ta vaja naj bo opravljena po branju o binarnih iskalnih drevesih.)
  in \secref{binarysearchtree}.)  Primerjajte preskočne sezname z binarnimi
  iskalnimi drevesi po naslednjih kriterijih:  
  \begin{enumerate}
     \item Razložite kako odstranjevanje robnih elementov preskočnega sezname vodi k
       strukturi ki izgleda kot binarno drevo in je enaka
       binarnemu iskalnemu drevesu.
     \item Preskočni seznami in dvojiška iskalna drevesa oboji porabijo približno enako
       število kazalcev (2 na vozlišče).  Preskočni seznami bolje uporabijo te kazalce.
       Razložite zakaj.
  \end{enumerate}
\end{exc}
\translatedby{Aleš Bokal}{sl}


