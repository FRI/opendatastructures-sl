\chapter{Dvojiška drevesa}
\chaplabel{binarytrees}
\translatedby{Erik Šimer}{sl}
\translatedby{Vesna Horvat}{sl}
\translatedby{Tjaša Jagodnik}{sl}
\translatedby{Anže Pratnemer}{sl}

To poglavje vpeljuje eno izmed najbolj temeljnih struktur v računalništvu: dvojiška drevesa. Uporaba besede \emph{drevo}
\index{tree}%
\index{tree!binary}%
\index{binary tree}%
prihaja iz dejstva da je, ko jih rišemo, končna risba podobna drevesom iz gozda.
Obstaja veliko načinov definiranja dvojiških dreves.
 Matematično je  \emph{dvojiško drevo} povezan,
neusmerjen, končni graf brez ciklov, katerih stopnja bi bila večja od tri.

Za večino aplikacij v računalništvu so dvojiška drevesa \emph{zakoreninjena:}
\index{tree!rooted}%
\index{rooted tree}%
Posebno vozlišče #r#, stopnje največ $2$, se imenuje \emph{koren}
drevesa. Za vsako vozlišče $#u#\neq #r#$, se drugo vozlišče na
poti od #u# do #r# imenuje \emph{starš} od #u# .
\index{parent}%
Vsako drugo vozlišče, ki meji na #u# imenujemo \emph{otrok}
\index{child} od #u#. Večina
dvojiških dreves, ki nas zanimajo, je \emph{urejena}
\index{ordered tree}%
\index{tree!ordered}%
 in tako lahko ločimo
med \emph{levi otrok} in  \emph{desni otrok} od #u#.
\index{left child}%
\index{child!left}%
\index{right child}%
\index{child!right}%

V ilustracijah, so dvojiška drevesa običajno narisana iz korena
navzdol, s korenom na vrhu slike in levim ter desnim otrokom tako,
da je levi otrok na levi strani, desni pa na desni strani
(\figref{bintree-orientation}). Na primer \figref{binary-tree}. kaže
dvojiško drevo z devetimi vozlišči.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bintree-traverse-1} 
  \end{center}
  \caption[Parent, left child, and right child]{Starš, levi otrok, desni otrok vozlišča  #u#
   v #BinaryTree#.}
  \figlabel{bintree-orientation}
\end{figure}


\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[width=\HalfScaleIfNeeded]{figs/bintree-1} &
      \includegraphics[width=\HalfScaleIfNeeded]{figs/bintree-2} \\
      (a) & (b)
    \end{tabular}
  \end{center}
  \caption{Dvojiško drevo (a)~devet vozlišč in (b)~deset zunanjih vozlišč.}
  \figlabel{binary-tree}
\end{figure}

Ker so dvojiška drevesa tako pomembna, so za njih razvili določeno terminologijo:
 \emph{globina}
\index{depth}%
vozlišča, #u#, je v dvojiškem drevesu
dolžina poti od #u# do korena drevesa. Če je vozlišče #w#,
na poti od #u# do #r#, potem #w# imenujemo \emph{prednik}
\index{ancestor}%
od #u# in #u# pa imenujemo \emph{naslednik}
\index{descendant}%
od #w#. \emph{poddrevo} od
vozlišča #u# je dvojiško drevo, ki ima korenine v #u#  in vsebuje vse
naslednike od #u#. \emph{višina}
\index{height!in a tree} vozlišča #u#, je dolžina
najdaljše poti od #u# do enega od njenih naslednikov. \emph{višina}
\index{height!of a tree}%
drevesa je višina njegovega korena.
Vozlišče #u#, je \emph{list}
\index{leaf}%
če nima nobenega otroka.

Včasih mislimo, da so drevesa utrjena z \emph{zunanjimi
vozlišči}. Vsako vozlišče, ki nima levega otroka ima zunanje
vozlišče kot za svojega levega otroka in podobno vsako vozlišče, ki
nima desnega otroka ima zunanje vozlišče kot za svojega desnega otroka (glej \figref{binary-tree}.b). Z indukcijo lahko enostavno preverimo, da ima dvojiško drevo z $#n#\ge 1$ pravimi vozlišči $#n#+1$ zunanjih vozlišč.


\section{#BinaryTree#: Osnovno dvojiško drevo}

\index{BinaryTree@#BinaryTree#}%
Najenostavnejši način, predstavitve vozlišča #u#, v dvojiškem drevesu je
izrecno shranjevanje (največ treh) sosedov od #u#:
\javaimport{ods/BinaryTree.BTNode<Node}
\cppimport{ods/BinaryTree.BTNode}
Ko eden od treh sosedov ni prisoten, ga nastavimo na #nil#.
Na ta način sta oba zunanja vozlišča drevesa in starš korena
vrednosti #nil#.

Dvojiško drevo se lahko zastopa kot
\javaonly{referenca}\cpponly{pointer} do svojega vozlišča korena #r#:
\codeimport{ods/BinaryTree.r}

Globino vozlišča #u#, lahko izračunamo tako, da štejemo korake od #u# do korena:
\codeimport{ods/BinaryTree.depth(u)}


\subsection{Rekurzivni algoritmi}

\index{recursive algorithm}%
Z uporabo rekurzivnih algoritmov je izračun o dvojiških drevesih enostaven.
 Na primer, za izračun velikosti (število vozlišč)
dvojiškega drevesa, ki je zakoreninjen v vozlišču #u#, naredimo tako da rekurzivno izračunamo velikost
dveh poddreves, ki so zakoreninjena na otroke od #u#, nato povzamemo te velikosti, in dodamo eno:

\codeimport{ods/BinaryTree.size(u)}

Za izračun višine vozlišča #u# moremo izračunati višino #u#- jevih dveh poddreves,
vzeti največjega  in mu dodati:

\codeimport{ods/BinaryTree.height(u)}

\subsection{Obiskovanje dvojiškega drevesa}
\seclabel{bintree:traversal}

\index{traversal!of a binary tree}%
\index{tree traversal}%
\index{binary-tree traversal}%
Prejšnja algoritma iz prejšnjega odseka uporabljata rekurzijo, za obisk
vseh vozlišč v dvojiškem drevesu. Vsak od njih obišče vozlišča
dvojiškega drevesa v istem vrstnem redu kot naslednja koda:
\codeimport{ods/BinaryTree.traverse(u)}

Z uporabo rekurzije, lahko na ta način proizvajamo zelo kratko in preprosto kodo, lahko pa je taka koda zelo problematična.
Največja globina rekurzije je podana z
največjo globino vozlišča v dvojiškem drevesu, tj. višina drevesa.
Če je višina drevesa zelo velika, potem lahko taka rekurzija 
porabi veliko več pomnilnika na skladu, kot ga je na voljo.

Za obhod dvojiškega drevesa brez rekurzije lahko uporabimo algoritem, ki se 
zanaša na to, da ve, iz kje je prišel in kam bo odšel. Glej
\figref{bintree-traverse}.  Če pridemo do vozlišča #u# od #u.parent#,
potem obiščemo #u.left#. Če pridemo do #u#
od #u.left#, potem obiščemo #u.right#. Če prispemo
 na #u# iz #u.right#, potem smo končali z obiskovanjem #u# -jevih poddreves
in se tako vrnemo na #u.parent#. Naslednja koda izvaja
idejo, ki vključuje ravnanje v primerih, ko katera koli od #u.left#,
#u.right# ali #u.parent# je #nil#:
\codeimport{ods/BinaryTree.traverse2()}


\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[scale=0.90909]{figs/bintree-traverse-2}
      \includegraphics[scale=0.90909]{figs/bintree-3}
    \end{tabular}
  \end{center}
  \caption[Traversing a BinaryTree]{Trije primeri, ki se pojavijo na vozlišču
    #u# kadar obhodimo dvojiškega drevesa,ki niso rekurzivna}
  \figlabel{bintree-traverse}
\end{figure}

Enake primere, ki jih lahko izračunamo z rekurzivnimi algoritmi, lahko izračunamo z iterativnimi algoritmi. 
Na primer, za izračun velikosti drevesa hranimo števec #n#, in nižamo #n# vsakič ko obiščemo novo vozlišče.
\codeimport{ods/BinaryTree.size2()}

V nekaterih implementacijah dvojiških dreves, se #parent# ne uporablja.
V takih primerih, lahko še vedno uporabimo iterativno izvedbo, vendar
mora taka izvedba uporabljati #List# (ali #Stack#), saj bi tako lahko
spremljali pot od trenutnega vozlišča do korena.

Posebna vrsta prečkanja, ki ne ustreza vzorcu zgoraj navedene funkcije je
 \emph{prvi-v-širino}.
\index{breadth-first traversal}%
\index{traversal!breadth-first}%
V prvi-v-širino obhodu, so vozlišča obiskana stopnja-postopnjo,
 pri kateremu začnemo v korenu in nadaljujemo navzdol,
 kjer obiskujemo vsako vozlišče od levega proti desni (glej
\figref{bintree-bfs}). 
To je podobno načinu branja strani v Angleškem jeziku.
Prvi-v-širino obhod je implementiran z uporabo vrste #q#, ki na začetku vsebuje samo koren  #r#.
Na vsakem koraku, vzamemo naslednje vozlišče #u# iz #q# , nato procesiramo #u#, in dodamo #u.left#
in #u.right# (če niso #nil#) v #q#:
\codeimport{ods/BinaryTree.bfTraverse()}

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bintree-4}
  \end{center}
  \caption{Med prvi-v-širino obhodu,  so vozlišča v dvojiškem drevesu obiskana po principu stopnja-po-stopnjo in levo-proti-desni za vsako stopnjo.}
  \figlabel{bintree-bfs}
\end{figure}



\translatedby{Matej Brlec}{sl}

\section{#BinarySearchTree#: Neuravnoteženo dvojiško iskalno drevo}
\seclabel{binarysearchtree}

\index{BinarySearchTree@#BinarySearchTree#}%
\index{binary search tree}%
\index{binary tree!search}%
#BinarySearchTree# je posebna oblika dvojiškega drevesa, pri katerem vsako vozlišče #u# hrani tudi podatek #u.x# iz nekega skupnega vrstnega reda. Podatki dvojiškega iskalnega drevesa upoštevajo \emph{lastnost dvojiških iskalnih dreves}:
\index{binary search tree property}%
Za vozlišče #u# velja, da vsak podatek shranjen v poddrevesu #u.left# je manjši od #u.x# ter vsak podatek shranjen v poddrevesu #u.right# je večji od #u.x#.  Primer #BinarySearchTree# je prikazan v \figref{bst}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bst-example}
    %\includegraphics[scale=0.90909]{figs/binary-tree-4}
  \end{center}
  \caption{Dvojiško iskalno drevo.}
  \figlabel{bst}
\end{figure}


\subsection{Iskanje}

\index{search path!in a binary search tree}%
Lastnost dvojiškega iskalnega drevesa je zelo uporabna, ker nam omogoča hitro iskanje vrednosti #x# v dvojiškem iskalnem drevesu. To naredimo tako, da začnemo z iskanjem vrednosti #x# v korenu #r#. Ko pregledamo vozlišče #u#, imamo tri možnosti:
\begin{enumerate}
\item Če je $#x#< #u.x#$, nadaljujemo z iskanjem v #u.left#;
\item Če je $#x#> #u.x#$, nadaljujemo z iskanjem v #u.right#;
\item Če je $#x#= #u.x#$, pomeni, da smo našli vozlišče #u#, ki hrani #x#.
\end{enumerate}
Iskanje se zaključi, ko dosežemo Možnost~3 ali ko je #u=nil# (prazen).  V prvem primeru smo našli #x#. V drugem pa sklenemo, da #x# ni v dvojiškem iskalnem drevesu.
\codeimport{ods/BinarySearchTree.findEQ(x)}

V \figref{bst-search} sta prikazana dva primera iskanj v dvojiškem iskalnem drevesu. Drugi primer prikazuje, da tudi če ne najdemo #x# v drevesu, vseeno pridobimo nekaj pomembnih informacij. Če pogledamo zadnje vozlišče #u# pri katerem se je zgodila Možnost~1, vidimo, da je #u.x# najmanjša vrednost v drevesu, ki je večja od #x#.  Podobno, zadnje vozlišče kjer se je zgodila Možnost~2 hrani največjo vrednost v drevesu, ki je manjša od #x#.  Torej, ob spremljanju zadnjega vozlišča #z# pri katerem se je zgodila Možnost~1, lahko #BinarySearchTree# implementira #find(x)# funkcijo, ki vrne najmanjšo vrednost v drevesu, ki je večja ali enaka #x#:
\codeimport{ods/BinarySearchTree.find(x)}

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-2} &
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-3} \\
    (a) & (b)
    \end{tabular}
  \end{center}
  \caption{Primer (a)~uspešnega iskanja (za $6$) ter (b)~neuspešnega iskanja (za $10$) v dvojiškem iskalnem drevesu.}
  \figlabel{bst-search}
\end{figure}


\subsection{Vstavljanje}

Pri vstavljanju nove vrednosti #x# v #BinarySearchTree#, najprej poiščemo #x# v drevesu. Če ga najdemo, potem vstavljanje ni potrebno. V nasprotnem primeru shranimo #x# v otroka zadnjega vozlišča #p#, ki smo ga obiskali med iskanjem za vrednostjo #x#. Ali je novo vozlišče levi ali desni otrok vozlišča #p#, je odvisno od rezultata primerjave med #x# ter #p.x#.
\codeimport{ods/BinarySearchTree.add(x)}
\codeimport{ods/BinarySearchTree.findLast(x)}
\codeimport{ods/BinarySearchTree.addChild(p,u)}
Primer je prikazan v \figref{bst-insert}. Najbolj časovno požrešen del tega procesa je začetno iskanje vozlišča #x#, ki porabi količino časa sorazmerno z višino novo vstavljenega vozlišča #u#. V najslabšem primeru je ta enaka višini #BinarySearchTree#.


\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-4} &
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-example-5} 
    \end{tabular}
  \end{center}
  \caption{Vstavljanje vrednosti $8.5$ v dvojiško iskalno drevo.}
  \figlabel{bst-insert}
\end{figure}

\translatedby{Anže Pratnemer}{sl}
\subsection{Brisanje}

Brisanje vrednosti, ki jo hrani vozlišče #u# v strukturi #BinarySearchTree# je malce težje. Če je #u# list potem preprosto odstranimo #u# iz seznama otrok njegovega starša. V primeru, da ima #u# samo enega otroka lahko odstranimo #u# iz drevesa tako, da #u.parent# posvoji #u#-jevega otroka(glej
\figref{bst-splice}):
\codeimport{ods/BinarySearchTree.splice(u)}

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/bst-splice}
  \end{center}
  \caption{Brisanje lista ($6$) ali vozlišča z enim otrokom ($9$) je preprosto.}
  \figlabel{bst-splice}
\end{figure}

Brisanje pa se zakomplicira, ko ima #u# dva otroka. V tem primeru je najlažje poiskati neko vozlišče #w#, ki ima manj kot dva otroka, ter da #w.x# lahko zamenja #u.x#. Za ohranjanje lastnosti dvojiškega iskalnega drevesa mora biti vrednost #w.x# blizu vrednosti #u.x#.  Na primer: če bi izbrali #w# tako, da je #w.x# najmanjša vrednost, ki je večja od #u.x#, bi delovalo.  Iskanje primernega vozlišča #w# je preprosto: to je najmanjša vrednost, ki se nahaja v poddrevesu #u.right#.  To vozlišče lahko brez skrbi odstranimo, ker nima levega otroka (glej \figref{bst-remove}).
\codeimport{ods/BinarySearchTree.remove(u)}

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-delete-1}
    \includegraphics[width=\HalfScaleIfNeeded]{figs/bst-delete-2}
    \end{tabular}
  \end{center}
  \caption[Brisanje iz dvojiškega iskalnega drevesa]{Brisanje neke vrednosti ($11$) iz nekega vozlišča #u#, ki ima dva otroka, počnemo z zamenjavo #u#-jeve vrednosti z najmanjšo vrednostjo v #u#-jevem desnem poddrevesu.}
  \figlabel{bst-remove}
\end{figure}

\subsection{Povzetek}

Vsaka izmed funkcij #find(x)#, #add(x)# ter #remove(x)# v strukturi #BinarySearchTree# vključuje sledenje neki poti od korena pa do nekega vozlišča v drevesu. Brez dodatnega znanja o obliki drevesa je težko karkoli povedati o dolžini te poti, razen tega, da je pot manjša kot #n# - število vseh vozlišč v drevesu. Sledeči izrek povzame zmožnosti podatkovne strukture #BinarySearchTree#:

\begin{thm}\thmlabel{bst}
  #BinarySearchTree# implementira #SSet# vmesnik ter podpira funkcije #add(x)#, #remove(x)# ter #find(x)# v $O(#n#)$ časa na operacijo.
\end{thm}

\thmref{bst} se slabo primerja z \thmref{skiplist}, ki prikazuje, da struktura #SkiplistSSet# lahko implementira #SSet# vmesnik z pričakovanim časom $O(\log #n#)$ na operacijo.  Problem strukture #BinarySearchTree# tiči v tem, da lahko postane \emph{neuravnoteženo}. Namesto da drevo izgleda kot na \figref{bst}, lahko izgleda kot dolga veriga z #n# vozlišči, ki imajo po točno enega otroka, razen zadnjega, ki nima nobenega.

Obstaja več načinov, kako se izogniti strukturi #BinarySearchTree#, ki je neuravnotežena. Vsi načini vodijo v podatkovne strukture, ki imajo operacije s časom $O(\log #n#)$. V \chapref{rbs} pokažemo, kako lahko dosežemo operacije z \emph{pričakovanim} časom $O(\log #n#)$ s pomočjo naključnosti. V \chapref{scapegoat} pokažemo, kako dosežemo operacije z \emph{amortiziranim} časom $O(\log #n#)$ s pomočjo delnih obnovitvenih operacij. V \chapref{redblack} pokažemo, kako dosežemo operacije z \emph{najslabšim} časom $O(\log #n#)$ s pomočjo simulacije dreves, ki niso dvojiška: eno v katerem imajo vozlišča lahko do štiri otroke.

%prevedeno po angleški verziji 0.1G z dne 2. april 2014
\section{#BinaryTree#: Razprava in vaje}
Dvojiška drevesa se že tisočletja uporabljajo za predstavitev razmerij med elementi. Med drugim se uporabljajo tudi za prikaz družinskih dreves (rodovnika).
\index{family tree}%
\index{pedigree family tree}%
Vzemimo primer, koren drevesa je oseba A. Levi in desni otrok osebe A sta njena starša in sta vozlišči drevesa; zgodba se naprej ponavlja za vsako vozlišče rekurzivno v globino. V zadnjih stoletjih se uporabljajo tudi v biologiji, natančneje za prikaz vrst v drevesni strukturi, kjer listi drevesa predstavljajo obstoječe vrste, vozlišča znotraj drevesa pa dogodke v razvoju, kjer se iz ene razvijeta dve novi vrsti (\emph{angl: speciation event}).

V petdesetih letih 19. st. so raziskovalci odkrili dvojiška iskalna drevesa. Več o dvojiških iskalnih drevesih lahko preberete v nadaljevanju.

Ko se srečamo z implementacijo dvojiških dreves, zlasti če le-te gradimo z ničle, se moramo dogovoriti za nekaj pravil. Eno izmed pravil je vprašanje: naj vozlišča drevesa vsebujejo kazalce na svoje starše ali ne? Če večina operacij na drevesu poteka od korena do listov, potem kazalcev ne potrebujemo. Po drugi strani pa to pomeni, da moramo t.i. sprehode po drevesu implementirati rekurzivno ali pa z uporabo posebnih skladov. Pomanjkanje kazalcev se pozna tudi v nekaterih drugih metodah, kot sta npr. vstavljanje in brisanje elementov iz dvojiškega drevesa, kjer se brez kazalcev njuna implementacija močno zaplete.

Drugo pravilo govori o tem kako v vozlišču hraniti kazalce na starša ter levega in desnega otroka. Ena možnost je, da so kazalci shranjeni kot spremenljivke. Druga možnost je, da jih hranimo v tabeli #p#, ki je dolžine 3 tako, da je vrednost #u.p[0]# levi otrok vozlišča #u#, vrednost #u.p[1]# je desni otrok vozlišča #u#, vrednost #u.p[2]# pa je starš vozlišča #u#. Z uporabo tabele kazalcev tudi omogočimo poenostavitev nekaterih zaporedij #if# stavkov v algebraične izraze.

Takšno poenostavitev lahko opazimo ob sprehodu po drevesu. Ko naletimo na vozlišče #u# iz tabele #u.p[i]#, je naslednje vozlišče v sprehodu $#u.p#[(#i#+1)\bmod 3]$. Podoben primer nastopi, ko v drevesu nimamo levo-desne simetrije. Npr. sorojenec (tj. brat) vozlišča #u.p[i]# je $#u.p#[(#i#+1)\bmod 2]$. Takšen trik deluje, če je vozlišče #u.p[i]# levi otrok ($#i#=0$) ali desni otrok ($#i#=1$) vozlišča #u#. S tem nam ni več potrebno pisati \emph{leve} in \emph{desne} kode (tj. dve različni kodi za urejanje leve in desne strani drevesa), temveč lahko vse združimo v en sam košček kode. Kot primer si lahko ogledate metodi #rotateLeft(u)# in #rotateRight(u)# na strani~\pageref{page:rotations}.\\[1\baselineskip]

\begin{exc}
Dokažite, da ima dvojiško drevo s številom vozlišč $#n#\ge 1$ $#n#-1$ povezav.\\[1\baselineskip]
\end{exc}

\begin{exc}
Dokažite, da ima dvojiško drevo s številom notranjih vozlišč $#n#\ge 1$ $#n#+1$ zunanjih vozlišč (listov).\\[1\baselineskip]
\end{exc}

\begin{exc}
Privzemimo, da imamo dvojiško drevo #T# z vsaj enim listom. Dokažite bodisi, da: a) ima koren drevesa največ enega otroka bodisi b), da ima drevo #T# več kot en list.\\[1\baselineskip]
\end{exc}

\begin{exc}
Implementirajte nerekurzivno metodo $size2(#u#)$, ki izračunava velikost podrevesa vozlišča u.
\end{exc}

\begin{exc}
Napišite nerekurzivno metodo $height2(#u#)$, ki izračunava višino vozlišča u v dvojiškem drevesu.
\end{exc}

\begin{exc}
Dvojiško drevo je uravnoteženo, če za vsako vozlišče $#u#$ velja, da se višina njegovih poddreves z vozliščem $#u.left#$ in $#u.right#$ razlikuje za največ ena. Napišite rekurzivno metodo $isBalanced()$ katera testira, če je drevo uravnoteženo. Metoda mora imeti časovno zahtevnost $O(#n#)$. (Priporočeno je, da kodo testirate na nekaj velikih drevesih z različnimi oblikami. Metodo s časovno zahtevnostjo veliko večjo od $O(#n#)$ je dosti lažje napisati.)

Premi pregled (pre-order) po dvojiškem drevesu je sprehod, ki obišče vsako vozlišče $#u#$ pred svojimi otroci.
Vmesni pregled (in-order) pogleda najprej levega otroka potem koren in nato še desnega otroka. Dobljeni vrstni red je sortiran.
Obratni pregled (post-order) obišče koren $#u#$ šele po tem, ko obišče vsa vozlišča v svojih poddrevesih.
Glej sliko 6.10.
\end{exc}

\begin{exc}
Ustvarite podrazred BinaryTree, čigar vozlišča imajo polja za shranjevanje števil premega, obratnega in vmesnega pregleda.
Napišite rekurzivne metode $preOrderNumber()$, $inOrderNumber()$ in $postOrderNumber()$, ki ta števila pravilno dodelijo. Vse te metode morajo imeti časovno zahtevnost $O(#n#)$.
\end{exc}

\begin{exc}\exclabel{tree-traversal}
Napišite nerekurzivno metode $nextPreOrder(#u#)$, $nextInOrder(#u#)$ in $nextPostOrder(#u#)$, ki vračajo vozlišče katero sledi $#u#$ v premem, vmesnem in obratnem pregledu. Te metode bi morale vzeti amortiziran konstanten čas.
Če začnemo pri katerem koli izbranem vozlišču, ter večkrat kličemo eno izmed teh funkcij dokler $#u#$ ni enak $null$, bi časovna zahtevnost morala biti $O(#n#)$.
\end{exc}

\begin{exc}
Recimo, da imamo dvojiško drevo s pre-, in- in post-order številkami dodeljenimi vozliščem.
Pokažite, kako se lahko te številke uporabijo za odgovor na vsako izmed naslednjih vprašanj, v konstantnem času.
\end{exc}

% slika 6.10
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/binarytree-numbering}
  \end{center}
  \caption{Pre-order, post-order, and in-order numberings of a binary tree.}
  \figlabel{binarytree-numbering}
\end{figure}
% have fun - mistakes are not our fault XD

\begin{enumerate}
  \item Ob danem vozlišču #u#, določite velikost poddrevesa, ki ima koren v #u#.
  \item Ob danem vozlišču #u#, določite globino v #u#.
  \item Ob danih dveh vozliščih #u# in #w#, določite ali je #u# prednik #w#.
\end{enumerate}


\begin{exc}
  Recimo, da imamo seznam vozlišč, ki so premo in vmesno oštevilčena. Dokažite, da obstaja največ eno 	premo/vmesno oštevilčeno drevo in pokažite, kako ga sestavimo.
\end{exc}

\begin{exc}
  Pokažite, da je lahko oblika kateregakoli dvojiškega drevesa z #n# vozlišči predstavljena z največ $2(#n#-1)$ biti. (Namig: poskusite zabeležiti, kaj se zgodi ob sprehodu, nato podatke uporabite za ponovno postavitev drevesa.)
\end{exc}

\begin{exc}
  Narišite, kaj se zgodi, ko dodamo vrednosti $3.5$ in nato 4.5 dvojiškemu iskalnemu drevesu v \figref{bst}.
\end{exc}

\begin{exc}
  Narišite, kaj se zgodi, ko odstranimo vrednosti $3$ in nato 5 iz dvojiškega iskalnega drevesa v \figref{bst}.
\end{exc}

\begin{exc}
  Izvedite #BinarySearchTree# metodo, #getLE(x)#,
  ki vrne seznam vseh členov, ki so manjši ali enaki #x#. Čas izvajanja vaše metode, bi moral biti $O(#n#'+#h#)$, kjer je $#n#'$ število členov, ki so manjši ali enaki #x# in #h#
  je višina drevesa.
\end{exc}

\begin{exc}
  Opišite, kako dodamo elemente $\{1,\ldots,#n#\}$ prvotno praznemu #BinarySearchTree# tako, da ima končno drevo višino $#n#-1$. Na koliko načinov je to mogoče narediti?
\end{exc}

\begin{exc}
  Če imamo neko #BinarySearchTree# in izvedemo operaciji #add(x)#, ki ji sledi #remove(x)# (z enako vrednostjo #x#), ali se nujno povrnemo v prvotno drevo?
\end{exc}

\begin{exc}
  Ali lahko #remove(x)# operacija poveča višino kateregakoli vozlišča v #BinarySearchTree#? In če da, za koliko?
\end{exc}

\begin{exc}
  Ali lahko #add(x)# operacija poveča višino kateregakoli vozlišča v #BinarySearchTree#? Ali lahko poveča višino drevesa? Če da, za koliko?
\end{exc}

\begin{exc}
  Oblikujte in izvedite različico #BinarySearchTree#, v kateri vsako vozlišče #u#, vzdržuje vrednosti #u.size# (velikost poddrevesa, ki ima koren v vozlišču #u#), #u.depth# (globino od #u#), in #u.height# (višino poddrevesa, s korenom v #u#).

  Te vrednosti vzdržujemo tudi ob klicu #add(x)# in #remove(x)# operacij, ampak to ne sme povečati ceno operacij za več kakor neko konstanto vrednost.
\end{exc}
