\chapter{Kopice}
\chaplabel{Kopice}
\translatedby{David Zavodnik, Luka Vabič, Jure Žvelc, Grega Vertovšek, Luka Florjančič}{sl}

V tem poglavju si bomo pogledali 2 implementacije zelo uporabne podatkovne strukture
#Polje# s prednostjo. Obe od teh dveh struktur sta posebne oblike Binarnega drevesa imenovani \emph{Kopica}, 
\index{Kopica}%
\index{Binarna Kopica}%
\index{Kopica!Binarna}%
kar pomeni ''neorganizirana kopica''. To je v nasprotju z binarnimi iskalnimi drevesi 
pri katerih pomislimo na zelo urejeno kopico.

Prva izvedba kopic uporablja polje, da simuliramo popolno binarno 
drevo.
Ta zelo hitra implementacija je osnova za enega izmed najhitrejših 
znanih sortirnih algoritmov, in sicer Kopično urejanje. (glej \secref{Kopicno urejanje}).

Druga implementacija je bazirana na bolj fleksiblinih binarnih drevesih, ki 
podpirajo #meld(h)# operacijo, ki omogoča vrsti s prednostjo, da obsorbira elemente druge vrste s prednostjo #h#.

\section{#Binarna Kopica#: implicitno binarno drevo}
\seclabel{BinarnaKopica}

\index{BinarnaKopica@#BinarnaKopica#}%
Naša prva implementacija #Vrste# (s prednostjo) temelji na tehniki, 
ki je stara preko 400 let. \emph{Eytzingerjeva metoda}
\index{Eytzingerjeva metoda}%
nam omogoča, da predstavimo popolno binarno drevo kot polje, v katerem imamo vozlišča 
postavljena v vrsto iz leve proti desni.
(glej \secref{bintree:traversal}).
Na ta način je koren drevesa shranjen na poziciji 0, njegov levi otrok je shranjen na poziciji 0, 
njegov desni otrok na pozciji 1, levi otrok na 2, levi otrok otroka na poziciji 3 in tako naprej.
Glej \figref{eytzinger}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/eytzinger}
  \end{center}
  \caption{Eytzingerjeva metoda predstavlja popolno binarno drevo kot polje.}
  \figlabel{eytzinger}
\end{figure}

Če uporabimo Eytzingerjevo metodo na dovolj velikih drevesih se
začnejo pojavljati vzorci.
Levi otrok vozlišča pri indexu #i# je na indexu $#left(i)#=2#i#+1$ 
in desni otrok vozlišča pri indexu #i# je na indexu $#right(i)#=2#i#+2$
Starš vozlišča pri indexu #i# pa je na $#parent(i)#=(#i#-1)/2$.
\codeimport{ods/BinaryHeap.left(i).right(i).parent(i)}

#Binarna Kopica# uporablja to tehniko, da implicitno predstavi popolno binarno drevo
v katerem so elementi \emph{Kopično urejeni}:
\index{heap-ordered binary tree}%
\index{binary tree!heap-ordered}%
\index{heap order}%
Vrednost shranjena na katerem koli indexu #i# ni manjša kot vrednost shranjena
na katerem koli indexu #parent(i)# razen izjeme vrednosti korena $#i#=0$. To nam 
omogoča, da je najmanjša vrednost #vrste# s prednostjo tako na shranjena na poziciji 0 (koren).

V Binarni kopici,  je #n# elementov shranjenih v tabeli #a#:
\codeimport{ods/BinaryHeap.a.n}

Implementacija operacije #dodaj(x)# je preprosta. Kot vse strukture bazirane na polju
najprej pogledamo, če je #a# poln (preverimo $#a.length#=#n#$) in če je, povečamo #a#. Nato #x# zapišemo na mesto #a[n]# in povečamo #n#. Na tej točki je potrebno storiti samo še to, da zagotovimo lastnost kopice.
To storimo tako, da zamenjujemo #x# z njegovim staršem, dokler ni #x# manjši od svojega starša.
See \figref{Kopica-vstavi}.
\codeimport{ods/BinaryHeap.add(x).bubbleUp(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-4} \\
  \end{center}
  \caption[Adding to a BinaryHeap]{Dodajanje elementa 6 v Binarno kopico.}
  \figlabel{heap-insert}
\end{figure}

Implementacija #remove()# operacije, katera odstarani najmanjšo vrednost
v kopici, je nekoliko težje. Vemo, kje je najmanjši element (v korenu), vendar ga moramo po odstranitvi nadomestiti in zagotoviti, da ohranjamo
lastnosti kopice.

Najlažji način, da to naredimo je, da koren nadomestimo z vrednostjo #a[n-1]#, 
zbrišemo vrednost in zmanjšamo #n#. Na žalost novi koren najverjetneje ni najmanjši element, zato ga  moramo prestaviti po kopici navzdol. To naredimo tako, da rekurzivno primerjamo element z njegovimi otroki. V primeru, da je element v kopici najmanjši smo končali, v nasprotnem primeru ga zamenjamo z najmanjšim od njegovih otrok in nadaljujemo ta postopek rekurzivno.
\codeimport{ods/BinaryHeap.remove().trickleDown(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-4} \\
  \end{center}
  \caption[Odstranjevanje iz binarne kopice]{Odstranjevanje najmanjšega elementa, 4, iz #Binarne Kopice#.}
  \figlabel{heap-remove}
\end{figure}


Kot ostale implementirane strukture polja, bomo mi ignorirali porabljen čas
v celicah za funkcijo #povecaj()#, ker se to lahko obračunava na amortizacijskem argumentu iz Lemma
\lemref{arraystack-amortized}. Pretečeni čas za #dodaj(x)# in #odstrani()# je odvisen
od višine (implicitnega) binarnega drevesa. Na srečo je to \emph{popolno}
\index{Binarno drevo!Popolno}%
\index{Popolno Binrano drevo}%
Binarno drevo;  vsak nivo, razen zadnji ima maximalno število vozlišč. Tako, je
višina drevesa enaka $h$ in ima najmanj $2^h$ vozlišč. Začnimo na ta način:
\[
  #n# \ge 2^h \enspace .
\]  
Algoritem nam da na obeh straneh enačbe
\[
   h \le \log #n# \enspace .
\]
tako obe, #dodaj(x)# in #odstrani()# operaciji tečeta v $O(\log #n#)$ času.

\subsection{Povzetek}

Naslednji teorem povzame uspešnost #Binarne Kopice#.

\begin{thm}\thmlabel{binaryheap}
  #Binarna Kopica# implementira #Polje# (s prednostjo). Ignoriramo ceno 
  polja da se poveča #resize()#, Binarna Kopica podpira operaciji 
  #dodaj(x)# in #odstrani()# v času $O(\log #n#)$ na operacijo.

  Poleg tega, začnimo s prazno #Binarna Kopica#, katero koli zaporedje $m$
  #dodaj(x)# in #odstrani()# operacij je rezultat skupaj $O(m)$ čas enak
  porabljen za vse klice funkcije #resize()#.
\end{thm}

\section{#MeldableHeap#: Naključna zlivalna kopica}
\seclabel{ZlivalnaKopica}

\index{ZlivalnaKopica@#MeldableHeap#}%
V poglavju bomo opisali #MeldableHeap#, implementacijo prioritetne #Queue#, shranjeno 
v kopičasto urejenem binarnem drevesu. Z razliko od #BinaryHeap#, pri katerem binarno drevo
definira število elementov, binarno drevo #MeldableHeap# nima omejitev glede oblike.

Operaciji #add(x)# in #remove()# v #MeldableHeap# sta implementirani z uporabo
operacije #merge(h1,h2)#. Operacija #merge(h1,h2)# združi vozlišči kopice #h1# in #h2# in vrne
korensko vozlišče nove kopice, ki vsebuje vse elemente poddreves vozlišč #h1# in #h2#.

Operacijo #merge(h1,h2)# lahko implementiramo rekurzivno. Glej \figref{meldable-merge}.
Če je vozlišče #h1# oz. #h2# #nil#, zlivamo s prazno množico in vrnemo vozlišče #h1# ali #h2#,
ki ni #nil#. V nasprotnem primeru zamenjamo vlogi #h1# in #h2# glede na velikost
vrednosti vozlišča tako, da večje od obeh vozlišč postane koren nove kopice. V primeru, da je v korenu
vrednost #h1.x#, potem lahko #h2# lahko rekurzivno zlivamo z #h1.left# ali #h1.right#, odvisno od
naključne vrednosti meta kovanca. 
\codeimport{ods/MeldableHeap.merge(h1,h2)}

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/meldable-merge}}
  \caption[Zlivanje v zlivalnii kopici]{Zlivanje #h1# in #h2# opravimo z združitvijo #h2# in #h1.left# oz. #h1.right#.}
  \figlabel{meldable-merge}
\end{figure}

V naslednjem delu poglavja pokažemo, da ima operacija #merge(h1,h2)# pričakovano časovno zahtevnost $O(\log #n#)$,
kjer je #n# končno število elementov v #h1# in #h2#.

S pomočjo operacije #merge(h1,h2)# je vstavljanje #add(x)# enostavno. Ustvarimo novo vozlišče #u# z vrednostjo #x# in zlivamo vozlišče s korenom kopice:
\codeimport{ods/MeldableHeap.add(x)}
Operacija ima pričakovano časovno zahtevnost $O(\log (#n#+1)) = O(\log #n#)$.

Podobno je z operacijo #remove()#. Odstranjujemo korensko vozlišče, ki ga zamenja rezultat
zlivanja njegovih otrok:
\codeimport{ods/MeldableHeap.remove()}
Tudi remove ima pričakovano časovno zahtevnost $O(\log #n#)$.

#MedlableHeap# lahko implementira tudi mnogo ostalih operacij s časovno zahtevnostjo
$O(\log #n#)$, npr.:
\begin{itemize}
\item #remove(u)#: iz kopice odstranimo vozlišče #u# (in pripadajoč ključ #u.x#).
\item #absorb(h)#: vse elemente #MeldableHeap# #h# dodamo kopici, kjer v postopku praznimo #h#.
\end{itemize}
Vsaka operacija lahko vsebuje konstantno število #merge(h1,h2)# operacij s časovno zahtevnostjo
$O(\log #n#)$.


\subsection{Analiza #merge(h1,h2)#}

Analiza operacije #merge(h1,h2)# je osnovana na analizi naključnega sprehoda v binarnem drevesu.
V binarnem drevesu se \emph{random walk} začne v korenu drevesa. V vsakem koraku naključnega sprehoda
vržemo kovanec, ki določa smer sprehoda (levi ali desni otrok trenutnega vozlišča).
Ko trenutno vozlišče postane #nil# se sprehod konča.

Sledeča lema je zanimiva, ker ni odvisna od oblike binarnega drevesa:

\begin{lem}\lemlabel{tree-random-walk}
Pričakovana dolžina naključnega sprehoda v binarnem drevesu z #n# vozlišči je največ #\log (n+1)#.
\end{lem}

\begin{proof}
Trditev lahko dokažemo z indukcijo. Za osnovo izberimo $#n#=0$ in dolžino sprehoda $0=\log (#n#+1)$.
Trditev drži za vsa ne negativna števila $#n#'< #n#$.


Dolžino korenskega levega poddrevesa označimo z $#n#_1$, da bo $#n#_2=#n#-#n#_1-1$ velikost
korenskega desnega poddrevesa. Sprehod se začne v korenu, zavzame en korak in nato nadaljuje v
poddrevesu velikosti $#n#_1$ ali $#n#_2$.
Po naši indukcijski predpostavki je pričakovana dolžina sprehoda 
\[
    \E[W] = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1)  \enspace , 
\] 
saj je vsako od $#n#_1$ ali $#n#_2$ manjše od $#n#$. Ker je $\log$ funkcija konkavne
oblike $\E[W]$ doseže maksimum, ko je $#n#_1=#n#_2=(#n#-1)/2$. 
%To maximize this,
%over all choices of $#n#_1\in[0,#n#-1]$, we take the derivative and obtain
%\[
%    (\E[W])' = \frac{1}{2}(c/#n#_1 - c/(#n#-#n#_1-1)) \enspace , 
%\]
%which is equal to 0 when $#n#_1 = (#n#-1)/2$.  We can establish that
%this is a maximum fairly easily, so
Potemtakem je pričakovano število korakov
\begin{align*}
    \E[W] 
    & = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1) \\
   & \le  1 + \log ((#n#-1)/2+1) \\
   & =  1 + \log ((#n#+1)/2) \\
   & =  \log (#n#+1)  \enspace . \qedhere 
\end{align*}
\end{proof}

Za bralce s pomankljivim poznavanjem informacijske teorije lahko dokaz za \lemref{tree-random-walk}
izrazimo s pomočjo entropije.


\begin{proof}[Informaciski teoretični dokaz za \lemref{tree-random-walk}]
Naj $d_i$ označuje globino $i$-tega zunanjega vozlišča. Spomnimo se, da
ima binarno drevo z #n# vozlišči #n+1# zunanjih vozlišč. Verjetnost, da bo
naključni sprehod dosegel $i$-to zunanje vozlišče je natančno 
$p_i=1/2^{d_i}$. Tako je pričakovana dolžina naključnega sprehoda
\[
   H=\sum_{i=0}^{#n#} p_id_i
    =\sum_{i=0}^{#n#} p_i\log\left(2^{d_i}\right)
    = \sum_{i=0}^{#n#}p_i\log({1/p_i})
\]
Desna stran enačbe je prepoznavna kot entropija verjetnostne distribucije na $#n#+1$ 
elementih, katera nikoli ne preseže $\log(#n#+1)$, kar dokazuje lemo. 

\end{proof}

S tem tudi enostavno dokažemo, da je čas izvajanja operacije #merge(h1,h2)# $O(\log #n#)$.



\begin{lem}
  Če sta #h1# in #h2# korena dveh kopic z vozliščema $#n#_1$ in $#n#_2$ je pričakovan
  čas izvajanja operacije #merge(h1,h2)# največ $O(\log #n#)$, kjer je $#n#=#n#_1+#n#_2$.
\end{lem}




\begin{proof}
  Vsak korak algoritma za zlivanje zavzame en korak v naključnem sprehodu,
  bodisi v kopici s korenom #h1# bodisi v kopici s korenom #h2#.
  Algoritem se zaključi ko katerikoli izmed dveh naključnih sprehodov doseže
  konec drevesa. Pričakovano število korakov zlivalnega algoritma je največ
  \[
     \log (#n#_1+1) + \log (#n#_2+1) \le 2\log #n# \enspace . \qedhere
  \]
\end{proof}

\subsection{Povzetek}

Sledeči teorem povzame zmogljivost #MeldableHeap#:

\begin{thm}\thmlabel{meldableheap}
  #MeldableHeap# implementira (prioritetni) #Queue# vmesnik.
  #MeldableHeap# podpira operaciji #add(x)# in #remove()#.
  $O(\log #n#)$ je pričakovan čas izvajanja posamezne operacije.
\end{thm}

\section{Diskusije in vaje}

Izgleda, da je implicitno predstavitev polnega binarnega drevesa s tabelo ali seznamom 
prvič predlagal Eytzinger \cite{e1590}.
Implicitno predstavitev je v svojih knjigah uporabil na primeru družinskih drevesih plemiških družin.
\index{pedigree family tree}%
Podatkovno strukturo #BinaryHeap# opisano v tej knjigi je prvič predstavil Williams \cite{w64}.

Naključno podatkovno strukturo #MeldableHeap# sta prvič predlagala Gambin in Malinowski \cite{gm98}.
Obstajajo tudi druge implementacije zlivalnih kopic vključno z
levo poravnanimi kopicami \cite[Section~5.3.2]{c72,k97v3},
\index{leftist heap}%
\index{heap!leftist}%
binomske kopice \cite{v78},
\index{binomial heap}%
\index{heap!binomial}%
Fibonaccijeve kopice \cite{ft87}, 
\index{Fibonacci heap}%
\index{heap!Fibonacci}%
parne kopice \cite{fsst86},\
\index{pairing heap}%
\index{heap!pairing}%
 in samoprilagoditvene kopice \cite{st83}, 
\index{skew heap}%
\index{heap!skew}%
čeprav niso tako enostavne kot je struktura #MeldableHeap#.


Nekaj zgoraj navedenih struktur podpira tudi operacijo #decreaseKey(u,v)#
\index{decreaseKey@#decreaseKey(u,y)#}%
v kateri se vrednost vozlišča #u# zniža na vrednost vozlišča #y# (ob predpogoju $#y#\le#u.x#$.) 
V večini strukturah lahko opracijo #decreaseKey(u,v)# izvajamo s časovno zahtevnostjo
$O(\log #n#)$ z odstranjanjem vozlišča #u# in dodajanjem vozlišča #t#. Nekatere strukture
lahko implementirajo operacijo bolj učinkovito. V Fibonaccijevih kopicah ima amortizirano časovno 
zahtevnost $O(1)$ in amortizirano $O(\log\log #n#)$ v posebni različici parnih kopic \cite{e09}.
Omenjena učinkovitejša različica operacije #decreaseKey(u,y)# se uporablja pri 
pohitritvi grafov, vključno z Dijkstra algoritmom za iskanje najkrajše poti \cite{ft87}.

\begin{exc}
  Narišite dodajanje elementov vrednosti 7 in vrednosti 3 na #BinaryHeap#
  prikazano na koncu iz \figref{heap-insert}.
\end{exc}

\begin{exc}
  Narišite odstranjevanje naslednjih dveh elementov (6 in 8) na
  #BinaryHeap# prikazano na koncu iz \figref{heap-remove}.
\end{exc}

\begin{exc}
  Implementirajte metodo #remove(i)#, katera odstrani shranjene vrednosti v
  #a[i]# v #BinaryHeap#.  Metoda mora teči v časovni zahtevnosti $O(\log #n#)$.
  Nato razložite, zakaj ta metoda ni uporabna.
\end{exc}

\begin{exc}\exclabel{general-eytzinger}
  \index{tree!$d$-ary}%
  A $d$-ary drevo je posplošitev binarnega drevesa, v katerem ima vsako
  notranje vozlišče $d$ otrok.  Uporabite Eytzingerjevo metodo, ki je
  lahko predstavljena kot popolno $d$-ary drevo z uporabo tabele. Ugotovite
  enačbe, v katerih je podan indeks #i#, določite indeks staršev od #i#
  in vsakega $d$ otroka od indeksa #i#'.
\end{exc}

\begin{exc}
  \index{DaryHeap@#DaryHeap#}%
  Uporabite kar ste spoznali v \excref{general-eytzinger}, oblikujte in
  implementirajte \emph{#DaryHeap#}, $d$-aryeva posplošitev
  #BinaryHeap#. Analizirajte čas poteka za operacije na #DaryHeap#
  in testirajte vaše delovanje #DaryHeap# katera se izvaja
  na #BinaryHeap# katere implementacija je podana.
\end{exc}



\begin{exc}
  Narišite dodajanje elementov vrednosti 17 in 82 v
  #MeldableHeap# #h1# prikazano v \figref{meldable-merge}.  Uporabite kovanec za
  simulacijo naključnega bita, če je potrebno.
\end{exc}

\begin{exc}
  Narišite odstranjevanje naslednjih dveh elementov (4 in 8) v
  #MeldableHeap# #h1# prikazano v \figref{meldable-merge}.  Uporabite kovanec za
  simulacijo naključnega bita, če je potrebno.
\end{exc}

\begin{exc}
  Implementirajte metodo #remove(u)#, katera odstrani vozlišče #u# iz
  a #MeldableHeap#.  Metoda mora teči v časovni zahtevnosti $O(\log #n#)$.
\end{exc}

\begin{exc}
  Poiščite drugo najmanjšo vrednost v #BinaryHeap# ali v
  #MeldableHeap# v enakem času.
\end{exc}

\begin{exc}
  Poiščite $k$-jevo najmanjšo vrednost v #BinaryHeap# ali v
  #MeldableHeap# v časovni zahtevnosti $O(k\log k)$.  (Namig: Uporabite drugo kopico.)
\end{exc}

\begin{exc}
  Predpostavimo da imamo podane #k# razporejene sezname, dolžine #n#.  Z uporabo
  kopice, pokažite kako združiti urejene sezname v časovni zahtevnosti $O(n\log
  k)$e.  (Namig: Začnite s primerom $k=2$, ki lahko pomaga.)
\end{exc}






