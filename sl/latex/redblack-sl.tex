\chapter{Rdeče-Črna Drevesa}
\chaplabel{redblack}

\index{binary search tree!red-black}%
\index{red-black tree}%
V tem poglavju so predstavljena rdeče-črna drevesa. So delno poravnana 
iskalna dvojiška drevesa z logaritemsko višino. Rdeče-črna drevesa so najbolj
razširjena uporaba podatkovnih struktur. Pojavljajo se kot primarne iskalne
strukture v mnogih knjižnicah, kot je naprimer Java Collections Framework
in v posameznih implementacijah C++ Standard Template Library. Prav tako se 
uporabljajo znotraj jedra operacijskega sistema Linux. Nekaj razlogov zakaj 
so rdeče-črna drevesa tako priljubljena:
\begin{enumerate}
\item Največja možna višina rdeče-črnega drevesa z #n# vozlišči je enaka $2\log #n#$.
\item Časovna zahtevnost operacij #add(x)# in #remove(x)# je enaka $O(\log #n#)$ \emph{worst-case}.
\item Amortizirano število rotacij, ki nastopijo med izvajanjem operacij #add(x)#
   ali #remove(x)# je konstanta.
\end{enumerate}
Prvi dve lastnosti postavljajo rdeče-črna drevesa pred preskočne sezname,
naključna iskalna binarna drevesa in samouravnotežena binarna drevesa.
Preskočni seznami in naključna iskalna binarna drevesa se zanašajo na 
naključje, njihova pričakovana časovna zahtevnost je $O(\log #n#)$. 
samouravnotežena binarna drevesa imajo garantirano povezavo na njihovi
višini, vendar se #add(x)# in #remove(x)# izvršita v $O(\log#n#)$ 
amortiziranem času.  Tretja lastnost je le pika na i. Pove nam, da je čas
potreben za vstaviti ali izločiti element #x# manjši od časa, ki ga porabimo
za iskanje elementa #x#.\footnote{Naključna iskalna binarna drevesa in
samo uravnotežena binarna drevesa imajo enako lastnost. Glej vaje~\ref{exc:skiplist-changes} 
in \ref{exc:treap-rotates}.}

Vendar pa imajo dobre lastnosti rdeče-črnih dreves določeno ceno: 
kompleksnost implementacije. Ohranjati mejo višine $2\log #n#$ ni 
preprosto. Zahteva pazljivo in podrobno analizo številnih primerov. 
Zagotoviti moramo, da implementacija naredi natančno določeno stvar 
za določen primer. Že samo ena napačna rotacija ali zamenjava barve 
povzroči napako, ki jo je težko najti in razumeti. 

Preden se bomo lotili implementacije rdeče-črnih dreves, bomo spoznali 
ozadje sorodne podatkovne strukture: 2-4 drevesa. S tem bomo pridobili 
informacije na podlagi česa so bila rdeče-črna drevesa ustvarjena in kako 
jih je možno tako učinkovito ohranjati. 
\section{2-4 Trees}
\seclabel{twofour}

2-4 Drevo je korensko drevo, ki ima naslednje lastnosti:
\begin{prp}[height]
  Vsi listi imajo enako globino.
\end{prp}
\begin{prp}[degree]
  Vsako notranje vozlišče ima 2, 3 ali 4 otrok.
\end{prp}
Primer 2-4 drevesa je prikazan v \figref{twofour-example}.
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/24rb-2}
  \end{center}
  \caption{2-4 drevo višine 3.}
  \figlabel{twofour-example}
\end{figure}
Lastnost 2-4 dreves je logaritemska višina v številu listov:
\begin{lem}\lemlabel{twofour-height}
  Najvišja višina 2-4 drevesa z #n# je $\log #n#$.
\end{lem}

\begin{proof}
  Omejenost vsakega notranje vozlišče na najmanj 2 otroka dokakzuje, da imamo v 
  primeru višine $h$ v 2-4 drevesu vsaj $2^h$ listov.  Z drugimi besedami,
  \[
     #n# \ge 2^h \enspace .
  \]
  Če obe strani logaritmiramo dobimo neenačbo $h \le \log #n#$.
\end{proof}

\subsection{Dodajanje lista}

Dodajanje lista v 2-4 drevo je preprosto (Glej \figref{twofour-add}). Če hželimo 
dodati na predzadnje mesto list #u# v vozlišče #w#, potem preprosto #u# postane otrok 
vozlišča #w#. V tem primeru vsekakor ohranja višino, ampak lahko krši pravilo;
če bi imel #w# štiri otroke pred dodajanjem #u#, potem ima #w# sedaj pet otrok.
V tem primeru moramo \emph{razdeliti}
\index{split}%
#w# v dve vozlišči, #w# in #w#', ki imata sedaj 2 in 3 otroke.
Toda #w#' sedaj nima staršev, zato smo rekurzivno dali #w#' kot otroka starša #w#'. V tem primeru 
ima lahko starš vozlišča #w#' preveč otrok, zato ga moramo razdeliti.
Ta postopek se nadaljuje, dokler ne pridemo do vozlišča, ki ima manj kot štiri 
otroke ali dokler ne razdelimo korena #r#, v dva vozlišča #r# in #r'#. V slednjem 
primeru naredimo nov koren  ki ima otroka #r# in #r'#.
To hkrati povečuje globino vseh listov in tako ohranja višino 
the height property.

\begin{figure}
  \begin{center}
   \begin{tabular}{c}
     \includegraphics[scale=0.90909]{figs/24tree-add-1} \\
     \includegraphics[scale=0.90909]{figs/24tree-add-2} \\
     \includegraphics[scale=0.90909]{figs/24tree-add-3}
   \end{tabular}
  \end{center}
  \caption[Adding a leaf to a 2-4 Tree]{Dodajanje lista v 2-4 drevo.
  Ta proces se konča po enemu razdeljevanju, ker ima #w.parent# stopnjo manj kot 4 
  pred dodajanjem.}
  \figlabel{twofour-add}
\end{figure}

Ker višina 2-4 drevesa nikoli več kot $\log #n#$, se proces dodajanja listov 
konča po največ $\log #n#$ korakih.

\subsection{Odstranjevanje lista}

Odstranjevanje lista 2-4 drevesa je lahko rahlo bolj komplicirano kot dodajanje(Glej
\figref{twofour-remove}).  Da ločimo list #u# od njegovega starša #w#, ga samo odstranimo.  
Če ima #w# samo dva lista in mu mi enega izmed njih odstranimo, moramo drevo ustrezno 
popraviti, saj krši pravilo.  

\begin{figure}
  \begin{center}
   \begin{tabular}{c}
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-1} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-2} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-3} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-4} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-5} \\
   \end{tabular}
  \end{center}
  \caption[Removing a leaf from a 2-4 Tree]{Odstranjevanje lista z 2-4 drevesa.  
  	Ta proces sega vse do korena, saj ima vsak prednik in bratje vozlišča #u# samo dva otroka.}
  \figlabel{twofour-remove}
\end{figure}

Da popravimo napako, poiščemo brata #w# ki je #w'#. Vozlišče #w'# definitivno
obstaja, ker ima  starš #w# vsaj dva otroka.  Če ima #w'#
tri ali štiri otroke, potem vzamemo enega izmed otrok in ga dodamo #w#. 
Sedaj ima #w# dva otroka in #w'# ima dva ali tri, nato končamo s popravljanjem.

Če ima #w'# samo dva otroka, potem ju \emph{združimo}
\index{merge}%
združimo v skupno vozlišče, ki ima tri otroke.  Potem moramo rekurzivno izbrisati 
#w'#. dokler ne dosežemo vozlišča #u# ali njegovega brata, ki ima več kot dva otroka 
ali ne dosežemo korena.  Če je koren levi z enim samim otrokom, nato pobrišemo koren 
in otroka dodamo v koren. Tudi to istočasno zmanjšuje višino vsakega lista in tako 
ohranimo višino drevesa.

Ker višina 2-4 drevesa nikoli več kot $\log #n#$, se proces odstranjevanja listov 
konča po največ $\log #n#$ korakih.

\section{#RedBlackTree#: A Simulated 2-4 Tree}
\seclabel{redblacktree}

Rdeče črno drevo je binarno iskalno drevo, katerega vsako vozlišče, #u#,
je \emph{rdeče} ali \emph{črno}. Rdeče 
predstavlja vrednost $0$, črno pa vrednost $1$.
\index{red node}%
\index{black node}%
\javaimport{ods/RedBlackTree.red.black.Node<T>}
\cppimport{ods/RedBlackTree.RedBlackNode.red.black}

Pred in po spreminjanju rdeče-črnega drevesa, morata veljati naslednji dve
lastnosti. Each property is defined both in terms of the
colours red and black, and in terms of the numeric values 0 and 1.
\begin{prp}[višina-črnih]
  \index{black-height property}%
  Enako število črnih vozlišč v poti od korena do katerega koli lista. (Vsota
  barv na poti od korena do poljubnega lista je enaka.)
\end{prp}

\begin{prp}[no-red-edge]
  \index{no-red-edge property}%
  Dve rdeči vozlišči nista med seboj nikoli sosednji.  (Velja za vsako vozlišče #u#, razen korena,
  $#u.barva# + #u.stars.barva# \ge 1$.)
\end{prp}
Opazili smo, da lahko vedno pobarvamo koren, #r#, rdeče-črnega drevesa črno,
ne da bi kršili katero od lastnosti, zato bomo predvidevali, da je koren črne barve
in algoritmi za posodabljanje rdeče-črnih dreves bodo to upoštevali.
Druga stvar, ki poenostavlja rdeče-črna drevesa
je, da so zunanja vozlišča (predstavljena z #nil#) črna vozlišča.
Na ta način ima vsako vozlišče, #u#, rdeče-črnega drevesa natanko dva
otroka, vsak z opredeljeno barvo. Primer rdeče-črnega
drevesa je predstavljen v sliki \figref{redblack-example}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/24rb-1}
  \end{center}
  \caption[A red-black tree]{Primer rdeče-črnega drevesa, kjer je višina črnih 3. Zunanja (#nil#) vozlišča so v obliki kvadrata.} 
  \figlabel{redblack-example}
\end{figure}

\translatedby{Mitja Ahlin}{sl}
\subsection{Rdeče-Črna drevesa in 2-4 Drevesa}

Sprva se morda zdi presenetljivo, da lahko rdeče-črno drevo učinkovito
posodabljamo tako, da ohranjamo višine črnih vozlišč in ne ohranjamo lastnosti rdečih vozlišč. Zdi se tudi nenavadno, da nekateri menijo, da so to koristne lastnosti. Kakorkoli, rdeče-črna drevesa so bila zasnovana za učinkovito simulirati 2-4 drevesa kot binarna drevesa.


Nanašanje na \figref{twofour-redblack}.
Vzemimo, da ima katerokoli rdeče-črno drevo, $T$, #n# vozlišč in izvaja naslednje operacije: Zbriše vsako rdeče vozlišče #n# in poveže otroka vozlišča #u# direktno na (črnega) starša vozlišča #u#. Po teji spremembi imamo drevo $T'$ z samo črnimi vozlišči.

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[scale=0.90909]{figs/24rb-3} \\
      \includegraphics[scale=0.90909]{figs/24rb-2}
    \end{tabular}
  \end{center}
  \caption{Vsako rdeče-črno drevo ima ustrezno 2-4 drevo.}
  \figlabel{twofour-redblack}
\end{figure}

Vsako notranje vozlišče v $T'$ ima dva, tri ali štiri otroke: Črno vozlišče, ki je imelo dva črna otroka bo še vedno imelo črna otroka po spremembi. Črno vozlišče, ki je imelo enega rdečega in enega črnega otroka bo imelo tri otroke po tej spremembi. Črno vozlišče, ki je imelo dva rdeča otroka bo imelo štiri otroke po teji spremembi. Poleg tega, lastnost črnih vozlišč nam garantira, da vsaka pot od korena do lista v $T'$ je enake dolžine. Z drugimi besedami, $T'$ je 2-4 drevo!

2-4 drevo $T'$ ima $#n#+1$ listov, ki ustrezajo $#n#+1$ zunanjim vozliščim rdeče-črnega drevesa. Torej, to drevo ima višino največ $\log (#n#+1)$. Vsaka pot od korena do lista v 2-4 drevesu ustreza poti od korena rdeče-črnega drevesa $T$ do zunanjega vozlišča.
Prvo in zadnje vozlišče v teji poti sta črna in največ eden na vsaka dva notranja vozlišča je rdeč, tako, da ima ta pot največ $\log(#n#+1)$ črnih in največ $\log(#n#+1)-1$ rdečih vozlišč. Torej, najdaljša pot od korena do kateregakoli \emph{notranjega} vozlišča v $T$ je največ
\[
   2\log(#n#+1) -2 \le 2\log #n# \enspace ,
\]
za kateregakoli $#n#\ge 1$. To dokaže najpomembnejšo lastnost rdeče-črnih dreves:
\begin{lem}
Višina rdeče-črnega drevesa z #n# vozlišči je največ $2\log #n#$.
\end{lem}

Sedaj, ko smo videli relacijo med 2-4 drevesi in rdeče-črnimi drevesi, ni tako težko za verjeti, da lahko učinkovito ohranjamo rdeče-črno drevo med dodajanjem in brisanjem elementov.

Videli smo že, da dodajanje elementa v #BinarySearchTree# izvedemo z dodajanjem novega lista. Torej, za implementacijo #add(x)# v rdeče-črno drevo moramo imeti metodo za simulacijo razdelitve vozlišča s petimi otroci v 2-4 drevesu. Vozlišče v 2-4 drevesu s petimi otroci je predstavljeno s črnim vozliščem, ki ima dva rdeča otroka, eden od teh ima tudi rdečega otroka. Lahko ``razdelimo'' to vozlišče s tem, da ga pobarvamo v rdeče in pobarvamo njegova dva otroka v črno. Primer prikazuje \figref{rb-split}.

\begin{figure}
  \begin{center}
   \begin{tabular}{c}
     \includegraphics[scale=0.90909]{figs/rb-split-1} \\
     \includegraphics[scale=0.90909]{figs/rb-split-2} \\
     \includegraphics[scale=0.90909]{figs/rb-split-3} \\
   \end{tabular}
  \end{center}
  \caption[Simulirano 2-4 drevo]{Simuliranje operacije deljenja 2-4 drevesa med dodajanjem v rdeče-črno drevo. (To simulira dodajanje v 2-4 drevo prikazano na \figref{twofour-add}.)}
  \figlabel{rb-split}
\end{figure}

Podobno, implementacija #remove(x)# zahteva metodo za združevanje dveh vozlišč in izposojo sorodnikovega otroka. Združitev dveh vozlišč je inverz deljenja vozlišč (prikazano na \figref{rb-split}) in vključuje barvanje dveh (črnih) sorodnikov v rdeče in barvanje njegovega (rdečega) starša v črno. Izposoja od sorodnika je najboj zakompliciran postopek in vključuje obe rotacije in barvanje vozlišč.

Vsekakor, med vsem tem moramo še vedno ohranjati lastnost no-red-edge in lastnost black-height. Medtem ni več presenetljivo, da je to lahko izvedljivo, veliko je število primerov, ki jih moramo upoštevati, če poikušamo narediti ditektno simulacijo 2-4 drevesa z rdeče-črnim drevesom. Na neki točki, postane lažje če neupoštevamo osnovnih 2-4 dreves in delamo neposredno k ohranjanju lastnosti rdeče-črnih dreves.

\subsection{Levo-viseca Rdece-Crna Drevesa}

\index{red-black tree}%
\index{left-leaning red-black tree}%
Ne obstaja nobena definicija rdeče-črnega drevesa. Namesto tega, je družina struktur, ki uspe ohranjati  lastnosti black-height in no-red-edge med operacijama #add(x)# in #remove(x)#. Drugačne strukture to delajo na drugačne načine. Tukaj mi implementiramo podatkovno strukturo, ki jo kličemo #RdeceCrnoDrevo#.
\index{RedBlackTree@#RedBlackTree#}%
Ta struktura implementira posebno obliko rdeče-črnega drevesa, ki zadovoljuje dodatni lastnosti.
\begin{prp}[left-leaning]\prplabel{levo-visece}\prplabel{redblack-last}
  \index{left-leaning property}%
  Na kateremkoli vozlišču #u#, če je #u.levo# črno, potem #u.desno# je črno.
\end{prp}

Opomnimo, da rdeče-črno drevo prikazano na \figref{redblack-example} ne zadošča levo-viseči lastnosti; krši jo starš rdečega vozlišča na najbolj desni poti od korena proti listu.

Razlog za ohranjanje levo-viseče lastnosti je, da zmanjšuje število primerov soočenih pri posodabljanju drevesa med operacijama #add(x)# in #remove(x)#. V smuslu 2-4 dreves, to pomeni, da vsako 2-4 drevo ima edinstveno zastopanje: Vozlišče stopnje dva postane črno vozlišče z dvemi črnimi otroci. Vozlišče stopnje tri postane črno vozlišče katerega levi otrok je rdeč in desni otrok je črn. Vozlišče stopnje štiri postane črno vozlišče z dvema rdečima otrokoma.

Preden opišemo implementacijo operacij #add(x)# in #remove(x)# v podrobnosti, prvo predstavimo nekaj osnovnih podoperacij uporabljenih v teh metodah prikazanih v \figref{redblack-flippullpush}. Prvi dve podoperaciji so za manipulacijo barv med ohranjanjem lastnosti black-height. Operacija #pushBlack(u)# metoda vzame za vhod črno vozlišče #u#, katero ima dva rdeča otroka in pobarva #u# rdeče in njegova dva otroka črno. Operacija #pullBlack(x)# obrne to opisano operacijo:
\codeimport{ods/RedBlackTree.pushBlack(u).pullBlack(u)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/flippullpush}
  \end{center}
  \caption{Flips, pulls and pushes}
  \figlabel{redblack-flippullpush}
\end{figure}

Metoda #flipLeft(u)# zamenja barve vozlišča #u# in #u.desno# in izvede levo rotacijo nad vozliščem #u#. Ta metoda obrne barve teh dveh vozlišč tako kot tudi relacijo njihovih staršev-otrok:
\codeimport{ods/RedBlackTree.flipLeft(u)}
Operacija #flipLeft(u)# je pposebno uporabna pri povrnitvi levo-viseče lastnosti na vozlišču #u#, katero krši to lastnost (ker je #u.left# črno in #u.right# rdeče). V tem posebnem primeru, smo lahko zagotovi, da ta operacija ohranja obe lastnosti black-height in no-red-edge. Relacija #flipRight(u)# je simetrična z #fliPLeft(u)#, ko so vloge levega in desnega obrnjene.
\codeimport{ods/RedBlackTree.flipRight(u)}

\subsection{Dodajanje}

Za implementacijo #add(x)# v #RdeceCrnoDrevo#, izvedemo standardno #BinarnoIskalnoDrevo# vstavljanje za dodajanje novega lista, #u#, z $#u.x#=#x#$ in nastavimo $#u.colour#=#red#$. Opomnimo, da to ne spremeni črne višine kateremukoli vozlišču, torej ne krši lastnosti black-height. To pa lahko krši levo-visečo lastnost (če je #u# desni otrok svojega starša), in lahko krši no-red-edge lastnost (če je #u#jev starš #rdec#). Za povrnitev teh lastnosti, moramo klicati metodo #addFixup(u)#.
\codeimport{ods/RedBlackTree.add(x)}

Ilustrirano na \figref{rb-addfix}, metoda #addFixup(u)# vzame za vhod vozlišče #u# katerega barva je rdeča in katero bi lahko kršilo lastnost no-red-edge in/ali levo-ležečo lastnost. Slednja razprava je verjetno nemogoča za sledelje brez sklicevanja na \figref{rb-addfix} ali ponovnega ustvarjanja na kosu papirja. Dejansko, bralec bi si moral preučiti to sliko preden nadaljuje.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/rb-addfix}
  \end{center}
  \caption{Enotni postopek v procesu popravljanja Property~2 po vstavljanju.}
  \figlabel{rb-addfix}
\end{figure}

Če je #u# koren drevesa, potem lahko pobarvamo #u# v črno za pridobitev nazaj obeh lastnosti. Če je tudi #u#jev sorodnik rdeč, potem mora biti #u#jev starš črn, torej oba levo-viseča in no-red-edge lastnost že držita.
 
Če ne, najprej določimo, če je #u#jev starš, #w#, kršil levo-visečo lastnost in, če je tako, izvedemo operacijo #flipLeft(w)# in nastavimo $#u#=#w#$. To nas pusti v lepo definiranem stanju: #u# je levi otrok starša, #w#, torej #w# sedaj zadošča levi-viseči lastnosti. Vse kar nam ostane je, da zagotovimo no-red-edge lastnost na #u#. Moramo samo še skrbeti za primer v katerem je #w# rdeč, sicer v nasprotnem primeru #u# že zadošča lastnosti no-red-edge.

Glede na to, da še nismo končali, #u# je rdeč in #w# je rdeč. Lastnost no-red-edge (katero krši #u# in ne #w#) implicira, da #u#jev stari starš #g# obstaja in je črn. Če je #g#jev desni otrok rdeč, potem levo-viseča lastnost zagotavlja, da oba #g#jev otrok je rdeč in klic na #pushBlack(g)# naredi #g# rdečega in #w# črnega. To povrne no-red-edge lastnost na #u#, ampak lahko povzroči, da jo krši na #g# vozlišču, tako, da celoten proces začne z $#u#=#g#$.

Če je #g#jev otrok črn, potem klic na #flipRight(g)# nardi #w# črnega starča od #g# in naredi #w#ju dva rdeča otroka, #u# in #g#. To zagotovi, da #u# zadošča no-red-edge lastnosti in #g# zadošča levo-viseči lastnosti. V tem primeru se lahko ustavimo.
\codeimport{ods/RedBlackTree.addFixup(u)}

Metoda #insertFixup(u)# ima konstantni čas za iteracijo in vsaka iteracija ali konča ali premakne #u# bližje korenu. Zato, metoda #insertFixup(u)# konča po $O(\log #n#)$ iteracijah in po $O(\log #n#)$ času.


\subsection{Odstranitev}

#odstrani(x)# operacija v #RdeceCrnemDrevesu# je najbolj zahtevna
za implementacijo in to velja za vse različice rdeče-črnega drevesa.
Tako kot #odstrani(x)# operacija v \texttt{BinarnemIskalnemDrevesu},
išče vozlišče #w# z enim otrokom,
#u# in preplete #w# iz drevesa tako, da #w.parent# sprejme #u#.

Težava lahko nastane takrat, ko je #w# črn, saj s tem kršimo lastnost višine črnih v #w.parent#. 
Temu se lahko začasno izognemo z dodajanem #w.barva# do #u.barva#. To predstavlja
dve težavi: (1)~če se #u# in #w# obe začneta z črno, potem $#u.barva#+#w.barva#=2$ (dvojna črna), ki pa ni veljavna.
Če je bil #w# rdeč, se ga nadomesti s črnim vozliščem #u#, kateri lahko
krši levo usmerjeno lastnost pri $#u.parent#$. Obe težave 
lahko rešimo tako, da pokličemo metodo #removeFixup(u)#.

#removeFixup(u)# metoda prejme kot vhodni parameter vozlišče #u#, ki 
je črne (1) ali dvojno-črne barve (2). Če je #u# dvojno-črn, potem #removeFixup(u)#
opravi vrsto vrtenj in prebarvanj tako, da dvojno-črno vozlišče premika navzgor
po drevesu, dokler ni odpravljen.
The #removeFixup(u)# method takes as its input a node #u# whose colour is black
(1) or double-black (2).  If #u# is double-black, then #removeFixup(u)#
performs a series of rotations and recolouring operations that move the
double-black node up the tree until it can be eliminated. Skozi ta postopek
se vozlišče #u# spreminja, dokler ne pride do konca postopka, #u# pa
pripada korenu  podrevesa, ki se je spremenil. Koren tega drevesa
je lahko sedaj druge barve. Če je prešel iz rdeče na črno barvo,
 #removeFixup(u)# metoda na koncu preverja,
če #u#-jev starš krši levo usmerjeno lastnost in če jo to popravi.
\codeimport{ods/RedBlackTree.removeFixup(u)}

 #removeFixup(u)# metoda je predstavljena na figref{rb-removefix}
Naslednjemu besedilu bo težko, če ne kar nemogoče slediti
brez sklicevanja na  \figref{rb-removefix}. Vsaka ponovitev zanke
v #removeFixup(u)# postopku dvojno-črnega vozlišča #u#, temelji na
enemu od štirih primerov:

\begin{figure}
  \begin{center}
    \includegraphics[height=\HeightScaleIfNeeded]{figs/rb-removefix}
  \end{center}
  \caption{A single round in the process of eliminating a double-black node
   after a removal.}
  \figlabel{rb-removefix}
\end{figure}

\noindent
Primer 0: #u# je koren. To je najpreprostejšji primer. Prebarvali smo
#u# v črno (s tem ne kršimo nobene lastnosti rdeče-črnega drevesa).

\noindent 
Primer 1: #u# je sorodstven, #v#, je rdeč. V tem primeru, je #u# sorodstven
levemu otroku svojega starša, #w# (z lastnostjo levo-visečega). Opravimo
desno rotacijo na #w# in nadaljujemo z naslednjo ponovitvijo.
left child of its parent, #w# (by the left-leaning property).  We perform
a right-flip at #w# and then proceed to the next iteration. Upoštevamo, da
ta ukrep povzroči, da #w#-jev starš krši lasnost levo-visečega in
globina #u# naraste. To pomeni tudi, da  bo naslednja
ponovitev v Primer~3, z #w# obarvanim rdeče. Pri preučevanju Primer~3
spodaj, bomo videli, da se postopek ustavi med naslednjo ponovitvijo.
\codeimport{ods/RedBlackTree.removeFixupCase1(u)}

\noindent
Primer 2: #u# je sorodstven, #v#, je črn , #u# je levi otrok njegovega
starša, #w#. V tem primeru pokličemo funkcijo #pullBlack(w)#, ki obarvai #u# črno,
#v# rdeče in potemni barvo #w# v črno ali dvojno-črno.
V tem primeru #w# ne izpolnjuje lastnost levo-visečega, zato
to uredimo tako, da pokličemo #flipLeft(w)#.

V tem primeru je #w# rdeč, #v# pa je koren podrevesa
v katerem smo začeli. Preveriti moram še, če #w# ne povzroča kršitve
lastnosti no-red-egde. To naredimo tako, da preverimo #w#-jevega desnega otroka #q#.
Če je #q# črn, potem #w# izpolnjuje lastnost no-red-edge in nadaljujemo
z naslednjo ponovitvijo z  $#u#=#v#$.

V nasprotnem primeru (#q# je rdeč) sta obe lastnosti, nobenega-rdečega-lista – rdeče pravilo in levo-visečega, kršeni pri #q# in #w#. Levo-visečega popravimo s klicem #rotateLeft(w)#, sedaj nam ostane le še lastnost nobenega-rdečega-lista, ki jo še vedno kršimo. V tem trenutku je #q# levi sin od #v#, #w# je levi sin od #q#, #q# in #w# sta rdeča, #v# je pa črn ali dvojno-črn. #flipRight(v)# popravi drevo tako, da je #q# sedaj starš tako od #v# kot od #w#. Takoj zatem pokličemo #pushBlack(q)#, tako dobimo sledečo situacijo: #v# in #w# postaneta črna, #q# pa dobi originalno barvo od #w#.

Tako smo se znebili dvojno-črnega vozlišča ter  ponovno vzpostavili lastnosti nobenega-rdečega-lista in črna-višina. Ostane nam pa samo še ena težava: če ima #v# desnega sina, ki je rdeč, kršimo lastnost levo-visečega. To še preverimo ter pokličemo #flipLeft(v)#, ki nam to težavo odpravi, če je potrebno.
\codeimport{ods/RedBlackTree.removeFixupCase2(u)}

\noindent
Case 3: #u#'s sibling is black and #u# is the right child of its parent,
#w#.  This case is symmetric to Case~2 and is handled mostly the same way.
The only differences come from the fact that the left-leaning property
is asymmetric, so it requires different handling.

As before, we begin with a call to #pullBlack(w)#, which makes #v# red
and #u# black.  A call to #flipRight(w)# promotes #v# to the root of
the subtree.  At this point #w# is red, and the code branches two ways
depending on the colour of #w#'s left child, #q#.

If #q# is red, then the code finishes up exactly the same way as Case~2
does, but is even simpler since there is no danger of #v# not
satisfying the left-leaning property.

The more complicated case occurs when #q# is black.  In this case,
we examine the colour of #v#'s left child.  If it is red, then #v# has
two red children and its extra black can be pushed down with a call to
#pushBlack(v)#.  At this point, #v# now has #w#'s original colour, and we
are done.

If #v#'s left child is black, then #v# violates the left-leaning property,
and we restore this with a call to #flipLeft(v)#.  We then return the
node #v# so that the next iteration of #removeFixup(u)# then continues
with $#u#=#v#$.
\codeimport{ods/RedBlackTree.removeFixupCase3(u)}.

Each iteration of #removeFixup(u)# takes constant time.  Cases~2 and 3
either finish or move #u# closer to the root of the tree.  Case~0 (where
#u# is the root) always terminates and Case~1 leads immediately to Case~3,
which also terminates.  Since the height of the tree is at most $2\log
#n#$, we conclude that there are at most $O(\log #n#)$ iterations of
#removeFixup(u)#, so #removeFixup(u)# runs in $O(\log #n#)$ time.


\section{Summary}
\seclabel{redblack-summary}

Naslednji izrek povzema učinkovitost podatkovne strukture #RdeceCrnoDrevo# :

\begin{thm}
  #RedBlackTree# uporablja vmestnik #SSet# in omogoča, da se operacije
  #add(x)#, #remove(x)# in #find(x)# izvedejo v najslabšem času $O(\log
  #n#)$ na operacijo.
\end{thm}

Kar ni vključeno v zgornji teoriji, ima dodatni bonus:

\begin{thm}\thmlabel{redblack-amortized}
  Med vsemi klici metod #addFixup(u)# in #removeFixup(u)# se 
  vsako zaporedje operacij #dodaj(x)# in #odstrani(x)# izvede v času
  $O(m)$, na zacetku ko je #RedBlackTree# prazen.
\end{thm}

Skicirali smo le dokaz za \thmref{redblack-amortized}. S primerjanjem
metod #addFixup(u)# in #removeFixup(u)#, z algoritmi za dodajanje ali 
odstranjevanje listov v 2-4 drevesu se lahko prepričamo, da se ta lastnost 
deduje z 2-4 drevesa. Običajno, če lahko dokažemo, da je skupni čas porabljen 
za delitev, združevanje in zadolževanje v 2-4 drevesu $O(m)$, potem to pomeni 
\thmref{redblack-amortized}.

Dokaz tega izreka za 2-4 drevo uporablja potencial 
\index{potential method}%
odplačne analize.\footnote{Oglej si
\lemref{dualarraydeque-amortized} in \lemref{selist-amortized} dokaze za potencialno metodo
v ostalih aplikacijah.} Definiraj potencial za notranje vozlišče #u# v 2-4 drevesu kot
\[
  \Phi(#u#) = 
    \begin{cases} 
      1 & \text{če ima #u# 2 otroka} \\ 
      0 & \text{če ima #u# 3 otroke} \\ 
      3 & \text{če ima #u# 4 otroke}  
    \end{cases}
\]
in potencial za 2-4 drevo kot vsoto potencialov za njegova vozlišča.
Delitev se pojavi, ko se vozlišča s štirimi otroci razdelijo na dve vozlišči
z dvemi in tremi octroci. To pomeni, da se skupni potencial zmanjša za $3-1-0 = 2$. 
Ko pride do združevanja, se dve vozlišči z dvemi otroki zamenjata z vozliščem, 
ki ima tri otroke. Rezultat tega je zmanjšanje potenciala za  $2-0=2$. Torej se za 
vsako delitev ali združitev potencial zmanjša za dva.

Nato bodite pozorni, da če zanemarimo delitev in združevanje vozlišč, temu sledi 
konstantno število vozlišč katerih število otrok je bilo s tem ali odstranitvijo 
lista spremenjeno. Ob dodajanju vozlišča se nekemu vozlišču število otrok poveča 
za ena, s tem pa povečamo potencial za največ tri.  Med odstranitvijo lista, se 
vozlišču zmanjša število otrok za ena, potencial pa se mu poveča največ za ena. 
Ob tem sta lahko v odstranjevanje vključeni dve vozlišči s čimer se njun 
potencial poveča za največ ena.

Kot povzetek torej sledi, da lahko vsaka združitev ali delitev povzroči
zmanjšanje potenciala za vsaj dva.  V primeru, da ne upoštevamo združitev
ter delitev pri dodajanju oziroma odstranjevanju pa lahko povzroči povečanje
potenciala za največ tri. Potencial je vedno ne-negativno število.
Zatorej je število združitev ter delitev, povzročenih s strani
$m$ dodajanj oziroma odstranjevanj, na prvotno praznem drevesu največ $3m/2$.
\thmref{redblack-amortized} izhaja iz te analize in povezav med 2-4 drevesi in 
rdeče-črnimi drevesi.

\section{Discussion and Exercises}

Rdeče-črna drevesa sta prvič predstavila Guibas in Sedgewick \cite{gs78}. 
Kljub njihovi visoki zapletenosti izvedbe so najdeni v nekaterih najbolj 
pogosto uporabljenih knjižnjicah in aplikacijah. Večina algoritmov in 
učbenikov o podatkovnih strukturah razpravlja o nekaj ražličicah rdeče-črnih dreves.

Andersson \cite{a93} je predstavil left-leaning uravnano drevo, ki je
podobno rdeče-črnim drevesom, vendar pa ima left-leaning dodatno omejitev;
vsako vozlišče ima lahko največ enega rdečega otroka. Zaradi omenjene omejitve
je izvedba 2-3 dreves veliko pogostejša od 2-4 dreves. Ta so veliko preprostejša
kot podatkovna struktura #RedBlackTree# predstavljena v tem poglavju.

Sedgewick \cite{s08} pa je predstavil dve verziji left-leaning rdeče-črnih dreves.
These use recursion along with a simulation of top-down splitting
and združevanj v 2-4 drevesih. Kombinacija obeh tehnih nam omogoča zelo
kratko in elegantno kodo.

Povezana, a starejša, podatkovna struktura je \emph{AVL tree} \cite{avl62}.
\index{AVL tree}%
AVL drevesa so \emph{height-balanced}:
\index{height-balanced}%
\index{binary search tree!height balanced}%
V vsakem vozlišče $u$ se višina levega poddrevesa #u.left# ter desnega poddrevesa
#u.right# razlikuje za največ ena. Iz tega sledi: če je $F(h)$ najmanjše število
listov drevesa višine $h$, potem se $F(h)$ uvršča v okvir 
Fibonaccijevega zaporedja
\[
   F(h) = F(h-1) + F(h-2)
\]
z osnovnima primeroma $F(0)=1$ in $F(1)=1$.  $F(h)$ je tako približno
$\varphi^h/\sqrt{5}$, where $\varphi=(1+\sqrt{5})/2\approx1.61803399$ is the
\emph{golden ratio}.  (Bolj natančno $|\varphi^h/\sqrt{5} - F(h)|\le 1/2$.)
Arguing as in the proof of \lemref{twofour-height}, this implies
\[
   h \le \log_\varphi #n# \approx 1.440420088\log #n# \enspace ,
\]
torej imajo AVL drevesa manjšo višino kot rdeče-črna drevesa.  Višina je
lahko vzdrževana med izvajanjem #dodaj(x)# in #odstrani(x)# operacij z
sprehodom navzgor do korena drevesa, med katerim se izvede uravnoteženje
vsakega vozlišču #u#, katerega višina levega in desnega
poddrevesa se razlikuje za dva. Glej \figref{avl-rebalance}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/avl-rebalance}
  \end{center}
  \caption{Uravnoteženje v AVL drevesih. Največ dve rotaciji sta potrebni, da
  vozlišče z poddrevesoma višine $h$ in $h+2$ spremenimo v vozlišče z poddrevesoma
  višine $h+1$.}
  \figlabel{avl-rebalance}
\end{figure}

Uporaba Anderssonove variante in Sadgewickove variante rdeče-črnih dreves in uporaba
AVL dreves je enostavnejša kot uporaba #RedBlackTree# strukture, kot je definirana tukaj.
Žal pa ne more nobena od njih zagotavljati, da bi bil amortizacijski čas $O(1)$, 
za vsako posodobitev uravnovešen. In particular,
there is no analogue of \thmref{redblack-amortized} for those structures.

\begin{figure}
  \centering{\includegraphics[scale=0.90909]{figs/redblack-example}}
  \caption{A red-black tree on which to practice.}
  \figlabel{redblack-example2}
\end{figure}

\begin{exc}
  Nariši 2-4 drevo, ki ustreza #RedBlackTree# iz
  \figref{redblack-example2}.
\end{exc}

\begin{exc}
  Nariši dodajanje elementov 13, 3.5 in 3.3 na #RedBlackTree#
  iz \figref{redblack-example2}.
\end{exc}

\begin{exc}
  Nariši odstranjevanje elementov 11, 9, ter 5 na #RedBlackTree# iz 
  \figref{redblack-example2}.
\end{exc}

\begin{exc}
  Pokaži, da za poljubno velike vrednosti #n#, obstaja rdeče-črno
  drevo z #n# vozlišči, ki imajo višino  $2\log #n#-O(1)$.
\end{exc}

\begin{exc}
  Preuči operaciji #pushBlack(u)# and #pullBlack(u)#. Kaj naredijo ti 
  dve operaciji na 2-4 drevesu, ki temelji na simulaciji z rdeče-črnim drevesom.
\end{exc}

\begin{exc}
  Pokaži, da za poljubno velike vrednosti #n#, obstaja zaporedje ukazov
  #dodaj(x)# in #odstrani(x)#, ki vodi do rdeče-črnega drevesa
  z #n# vozlišči, ki imajo višino $2\log #n#-O(1)$.
\end{exc}



\begin{exc}
  Zakaj metoda #odstrani(x)# v #RedBlackTree# izvede operacijo
  #u.parent=w.parent#? Naj nebi bilo to storjeno že z klicem metode #splice(w)#?
\end{exc}

\begin{exc}
  Predvidevaj, da ima 2-4 drevo $T$, $#n#_\ell$ listov in $#n#_i$ notranjih
  vozlišč.
  \begin{enumerate}
    \item Kakšna je najmanjša vrednost $#n#_i$, kot funkcija $#n#_\ell$?
    \item Kakšna je največja vrednost $#n#_i$, kot funkcija $#n#_\ell$?
    \item Če je $T'$ rdeče-črno drevo, ki predstavlja $T$, koliko ima potem $T'$
     rdečih vozlišč?
  \end{enumerate}
\end{exc}

\begin{exc}
  Predpostavimo, da imamo binarno iskalno drevo z #n# vozlišči in višini
  največ $2\log #n#-2$.  Is it always possible to colour the
  nodes red and black so that the tree satisfies the black-height and
  no-red-edge properties?  If so, can it also be made to satisfy the
  left-leaning property?
\end{exc}

\begin{exc}\exclabel{redblack-merge}
  Predpostavimo, da imamo dva rdeče-črna drevesa $T_1$ in $T_2$, ki imata
  enako višino črnih vozlišč $h$ in, da je največji ključ v $T_1$ manjši
  od najmanjšega ključa v $T_2$. Prikaži kako se združita drevesi $T_1$ in $T_2$
  v eno rdeče-črno drevo v času $O(h)$.
\end{exc}

\begin{exc}
  Nadgradi rešitev iz \excref{redblack-merge}, da bo veljala tudi za drevesi 
  $T_1$ in $T_2$, ki imata različni višini črnih vozlišč , $h_1\neq h_2$.
  Čas izvajanja naj bo $O(\max\{h_1,h_2\})$.
\end{exc}



\begin{exc}
  Dokaži, da mora AVL drevo pri izvajanju #add(x)# metode, izvesti največ eno
  operacijo uravnoteženja (vključuje največ dve rotaciji; glej \figref{avl-rebalance}).
  Podaj primer AVL drevesa in klica metode #remove(x)# na tem drevesu, ki zahteva
  $\log #n#$ operacij uravnoteženja.
\end{exc}

\begin{exc}
  Napiši razred #AVLTree#, ki uporablja AVL drevo kot je opisano
  zgoraj.  Primerjaj hitrost izvajanja s hitrostjo #RedBlackTree#.
  Katera izvedba drevesa ima hitrejšo operacijo #find(x)#?
\end{exc}

\begin{exc}
  Oblikuj in izvedi vrsto poskusov, da primerjamo relativno uspešnost metod
  #find(x)#, #add(x)#, in #remove(x)# for the #SSet# implemeentations #SkiplistSSet#,
  #ScapegoatTree#, #Treap#, and #RedBlackTree#.  Bodite prepričani, da vključite več 
  testnih primerov, vključno s primeri, ko so podatki naključno razporejeni, že 
  razporejeni, jih odstranite, ko so urejeni in tako naprej.
\end{exc}
