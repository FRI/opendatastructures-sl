\chapter{Kopice}
\chaplabel{Kopice}
\translatedby{David Zavodnik, Grega Vertovšek, Luka Vabič, Luka Florjančič, Jure Žvelc, Rok Komatar}{sl}

V tem poglavju si bomo pogledali 2 implementacije zelo uporabne podatkovne strukture
#Polje# s prednostjo. Obe od teh dveh struktur sta posebne oblike Dvojiškega drevesa imenovani \emph{Kopica}, 
\index{Kopica}%
\index{Binarna Kopica}%
\index{Kopica!Binarna}%
kar pomeni ''neorganizirana kopica''. To je v nasprotju z dvojiškimi iskalnimi drevesi 
pri katerih pomislimo na zelo urejeno kopico.

Prva izvedba kopic uporablja polje, da simuliramo popolno dvojiško drevo. Ta zelo hitra implementacija je osnova za enega izmed najhitrejših znanih sortirnih algoritmov, in sicer kopično urejanje (glej \secref{heapsort}).
Druga implementacija je bazirana na bolj fleksiblinih dvojiških drevesih, ki podpirajo #meld(h)# operacijo, ki omogoča vrsti s prednostjo, da obsorbira elemente druge vrste s prednostjo #h#.

\section{#BinaryHeap#: implicitno dvojiško drevo}
\seclabel{binaryheap}

\index{BinarnaKopica@#BinaryHeap#}%
Naša prva implementacija #Queue# (s prednostjo) temelji na tehniki, 
ki je stara preko 400 let. \emph{Eytzingerjeva metoda}
\index{Eytzingerjeva metoda}%
nam omogoča, da predstavimo popolno dvojiško drevo kot polje, v katerem imamo vozlišča 
postavljena v vrsto iz leve proti desni (glej \secref{bintree:traversal}).
Na ta način je koren drevesa shranjen na poziciji 0, njegov levi otrok je shranjen na poziciji 0, 
njegov desni otrok na pozciji 1, levi otrok na 2, levi otrok otroka na poziciji 3 in tako naprej.
Glej \figref{eytzinger}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/eytzinger}
  \end{center}
  \caption{Eytzingerjeva metoda predstavlja popolno dvojiško drevo kot polje.}
  \figlabel{eytzinger}
\end{figure}

Če uporabimo Eytzingerjevo metodo na dovolj velikih drevesih se za-čnejo pojavljati vzorci.
Levi otrok vozlišča pri indexu #i# je na indexu $#left(i)#=2#i#+1$ 
in desni otrok vozlišča pri indexu #i# je na indexu $#right(i)#=2#i#+2$.
Starš vozlišča pri indexu #i# pa je na $#parent(i)#=(#i#-1)/2$.
\codeimport{ods/BinaryHeap.left(i).right(i).parent(i)}

#BinaryHeap# uporablja to tehniko, da implicitno predstavi popolno dvojiško drevo
v katerem so elementi \emph{kopično urejeni}:
\index{heap-ordered binary tree}%
\index{binary tree!heap-ordered}%
\index{heap order}%
Vrednost shranjena na katerem koli indexu #i# ni manjša kot vrednost shranjena
na katerem koli indexu #parent(i)#, razen izjeme vrednosti korena $#i#=0$. To nam 
o-mogoča, da je najmanjša vrednost #Queue# s prednostjo tako shranjena na poziciji 0 (koren).

V #BinaryHeap#,  je #n# elementov shranjenih v tabeli #a#:
\codeimport{ods/BinaryHeap.a.n}

Implementacija operacije #add(x)# je preprosta. Kot vse strukture bazirane na polju
najprej pogledamo, če je #a# poln (preverimo $#a.length#=#n#$) in če je, povečamo #a#. Nato #x# zapišemo na mesto #a[n]# in povečamo #n#. Na tej točki je potrebno storiti samo še to, da zagotovimo lastnost kopice.
To storimo tako, da zamenjujemo #x# z njegovim staršem, dokler ni #x# manjši od svojega starša.
Glej \figref{heap-insert}.
\codeimport{ods/BinaryHeap.add(x).bubbleUp(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-4} \\
  \end{center}
  \caption[Adding to a BinaryHeap]{Dodajanje elementa 6 v #BinaryHeap#.}
  \figlabel{heap-insert}
\end{figure}

Implementacija #remove()# operacije, katera odstrani najmanjšo vred-nost
v kopici, je nekoliko težja. Vemo, kje je najmanjši element (v korenu), vendar ga moramo po odstranitvi nadomestiti in zagotoviti, da ohranjamo
lastnosti kopice.

Najlažji način, da to naredimo je, da koren nadomestimo z vrednostjo #a[n-1]#, 
zbrišemo vrednost in zmanjšamo #n#. Na žalost novi koren najverjetneje ni najmanjši element, zato ga  moramo prestaviti po kopici navzdol. To naredimo tako, da rekurzivno primerjamo element z njegovimi otroki. V primeru, da je element v kopici najmanjši smo končali, v nasprotnem primeru ga zamenjamo z najmanjšim izmed otrok in nadaljujemo ta postopek rekurzivno.
\codeimport{ods/BinaryHeap.remove().trickleDown(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-4} \\
  \end{center}
  \caption[Odstranjevanje iz dvojiške kopice]{Odstranjevanje najmanjšega elementa, 4, iz #BinaryHeap#.}
  \figlabel{heap-remove}
\end{figure}


Kot ostale implementirane strukture polja, bomo mi ignorirali porabljen čas
v celicah za funkcijo #resize()#, ker se to lahko obračunava na amortizacijskem argumentu iz Lemma
\lemref{arraystack-amortized}. Pretečeni čas za #add(x)# in #remove()# je odvisen
od višine (implicitnega) dvojiškega drevesa. Na srečo je to \emph{polno}
\index{dvojiško drevo!Popolno}%
\index{popolno Dvojiško drevo}%
Dvojiško drevo;  vsak nivo, razen zadnjega ima največje možno število vozlišč. Tako, je
višina drevesa enaka $h$ in ima najmanj $2^h$ vozlišč. Začnimo na ta način
\[
  #n# \ge 2^h \enspace .
\]  
Če logaritmiramo, dobimo na obeh straneh enačbe
\[
   h \le \log #n# \enspace .
\]
Tako obe, #add(x)# in #remove()# operaciji tečeta v $O(\log #n#)$ času.

\subsection{Povzetek}

Naslednji teorem povzame uspešnost #BinaryHeap#.

\begin{thm}\thmlabel{binaryheap}
  #BinaryHeap# implementira #Queue# (s prednostjo). Ignoriramo ceno 
  polja da se poveča #resize()#, #BinaryHeap# podpira operaciji 
  #add(x)# in #remove()# v času $O(\log #n#)$ na operacijo.

  Poleg tega, začnimo s prazno #BinaryHeap#, katero koli zaporedje $m$
  #add(x)# in #remove()# je rezultat skupaj $O(m)$ čas enak
  porabljen za vse klice funkcije #resize()#.
\end{thm}

\section{#MeldableHeap#: Naključna zlivalna kopica}
\seclabel{Zlivalna kopica}

\index{ZlivalnaKopica@#MeldableHeap#}%
V poglavju bomo opisali #MeldableHeap#, implementacijo prioritetne vrste #Queue#, shranjeno 
v kopičasto urejenem dvojiškem drevesu. Za razliko od #BinaryHeap#, pri katerem dvojiško drevo
definira število elementov, dvojiško drevo #MeldableHeap# nima omejitev glede oblike.

The #add(x)# and #remove()# operations in a #MeldableHeap# sta blablablala ok to je delal.. ššščččžžž
implemented in terms of the #merge(h1,h2)# operation.  This operation
takes two heap nodes #h1# and #h2# and merges them, returning a heap
node that is the root of a heap that contains all elements in the subtree
rooted at #h1# and all elements in the subtree rooted at #h2#.

Operacijo #merge(h1,h2)# lahko implementiramo rekurzivno. Glej \figref{meldable-merge}.
Če je vozlišče #h1# oz. #h2# #nil#, zlivamo s prazno množico in vrnemo vozlišče #h1# ali #h2#,
ki ni #nil#. V nasprotnem primeru zamenjamo vlogi #h1# in #h2# glede na velikost
vrednosti vozlišča tako, da večje od obeh vozlišč postane koren nove kopice. V primeru, da je v korenu
vrednost #h1.x#, potem lahko #h2# lahko rekurzivno zlijemo z #h1.left# ali #h1.right#, odvisno od
naključne vrednosti meta kovanca. 

\codeimport{ods/MeldableHeap.merge(h1,h2)}

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/meldable-merge}}
  \caption[Zlivanje v zlivalni kopici]{Zlivanje #h1# in #h2# opravimo z združitvijo #h2# in #h1.left# oz. #h1.right#.}
  \figlabel{meldable-merge}
\end{figure}

V naslednjem delu poglavja pokažemo, da ima operacija #merge(h1,h2)# pričakovano časovno zahtevnost $O(\log #n#)$,
kjer je #n# končno število elementov v #h1# in #h2#.


S pomočjo operacije #merge(h1,h2)# je vstavljanje #add(x)# enostavno. Ustvarimo novo vozlišče #u# z vrednostjo #x# in
zlijemo vozlišče s korenom kopice:
\codeimport{ods/MeldableHeap.add(x)}
Operacija ima pričakovano časovno zahtevnost $O(\log (#n#+1)) = O(\log #n#)$.

Podobno je z operacijo #remove()#. Odstranjujemo korensko vozlišče, ki ga zamenja rezultat
zlivanja njegovih otrok:
\codeimport{ods/MeldableHeap.remove()}
Tudi #remove()# ima pričakovano časovno zahtevnost $O(\log #n#)$.

#MeldableHeap# lahko implementira tudi mnogo ostalih operacij s časovno zahtevnostjo
$O(\log #n#)$, npr.:
\begin{itemize}
\item #remove(u)#: iz kopice odstranimo vozlišče #u# (in pripadajoč ključ #u.x#).
\item #absorb(h)#: vse elemente #MeldableHeap# #h# dodamo kopici, kjer v postopku praznimo #h#.
\end{itemize}
Vsaka operacija lahko vsebuje konstantno število #merge(h1,h2)# operacij s časovno zahtevnostjo
$O(\log #n#)$.

\subsection{Analiza #merge(h1,h2)#}

Analiza operacije #merge(h1,h2)# je osnovana na analizi naključnega sprehoda v dvojiškem drevesu.
V dvojiškem drevesu se \emph{naključni sprehod} začne v korenu drevesa. V vsakem koraku naključnega sprehoda
vržemo kovanec, ki določa smer sprehoda (levi ali desni otrok trenutnega vozlišča).
Ko trenutno vozlišče postane #nil# se sprehod konča.

Sledeča lema je zanimiva, ker ni odvisna od oblike dvojiškega drevesa:

\begin{lem}\lemlabel{tree-random-walk}
Pričakovana dolžina naključnega sprehoda v dvojiškem drevesu z #n# vozlišči je največ #\log (n+1)#.
\end{lem}

\begin{proof}
Trditev lahko dokažemo z indukcijo. Za osnovo izberimo $#n#=0$ in dolžino sprehoda $0=\log (#n#+1)$.
Trditev drži za vsa pozitivna števila $#n#'< #n#$.

Let $#n#_1$ denote the size of the root's left subtree, so that
$#n#_2=#n#-#n#_1-1$ is the size of the root's right subtree.  Starting at
the root, the walk takes one step and then continues in a subtree of
size $#n#_1$ or $#n#_2$.  By our inductive hypothesis, the expected
length of the walk is then
\[
    \E[W] = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1)  \enspace , 
\] 
since each of $#n#_1$ and $#n#_2$ are less than $#n#$.  Since $\log$
is a concave function, $\E[W]$ is maximized when $#n#_1=#n#_2=(#n#-1)/2$.
%To maximize this,
%over all choices of $#n#_1\in[0,#n#-1]$, we take the derivative and obtain
%\[
%    (\E[W])' = \frac{1}{2}(c/#n#_1 - c/(#n#-#n#_1-1)) \enspace , 
%\]
%which is equal to 0 when $#n#_1 = (#n#-1)/2$.  We can establish that
%this is a maximum fairly easily, so
Therefore,
 the expected number of steps taken by the random walk is 
\begin{align*}
    \E[W] 
    & = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1) \\
   & \le  1 + \log ((#n#-1)/2+1) \\
   & =  1 + \log ((#n#+1)/2) \\
   & =  \log (#n#+1)  \enspace . \qedhere 
\end{align*}
\end{proof}

Za bralce s pomanjkljivim poznavanjem informacijske teorije lahko dokaz za \lemref{tree-random-walk}
izrazimo s pomočjo entropije.
\begin{proof}[Informaciski teoretični dokaz za \lemref{tree-random-walk}]
Naj $d_i$ označuje globino $i$-tega zunanjega vozlišča. Spomnimo se, da
ima dvojiško drevo z #n# vozlišči #n+1# zunanjih vozlišč. Verjetnost, da bo
naključni sprehod dosegel $i$-to zunanje vozlišče je natančno 
$p_i=1/2^{d_i}$. Tako je pričakovana dolžina naključnega sprehoda
\[
   H=\sum_{i=0}^{#n#} p_id_i
    =\sum_{i=0}^{#n#} p_i\log\left(2^{d_i}\right)
    = \sum_{i=0}^{#n#}p_i\log({1/p_i})
\]
Desna stran enačbe je prepoznavna kot entropija verjetnostne distribucije na $#n#+1$ 
elementih, katera nikoli ne preseže $\log(#n#+1)$, kar dokazuje lemo. 

\end{proof}


S tem tudi enostavno dokažemo, da je čas izvajanja operacije #merge(h1,h2)# $O(\log #n#)$.


\begin{lem}
  Če sta #h1# in #h2# korena dveh kopic z vozliščema $#n#_1$ in $#n#_2$ je pričakovan
  čas izvajanja operacije #merge(h1,h2)# največ $O(\log #n#)$, kjer je $#n#=#n#_1+#n#_2$.
\end{lem}

\begin{proof}
  Vsak korak algoritma za zlivanje zavzame en korak v naključnem sprehodu,
  bodisi v kopici s korenom #h1# bodisi v kopici s korenom #h2#.
  Algoritem se zaključi ko katerikoli izmed dveh naključnih sprehodov doseže
  konec drevesa. Pričakovano število korakov zlivalnega algoritma je največ 
  \[
     \log (#n#_1+1) + \log (#n#_2+1) \le 2\log #n# \enspace . \qedhere
  \]
\end{proof}

\subsection{Povzetek}

Sledeči teorem povzame zmogljivost #MeldableHeap#:

\begin{thm}\thmlabel{meldableheap}
  #MeldableHeap# implementira (prioritetni) #Queue# vmesnik.
  #MeldableHeap# podpira operaciji #add(x)# in #remove()#.
  $O(\log #n#)$ je pričakovan čas izvajanja posamezne operacije.
\end{thm}

\section{Diskusije in vaje}

Izgleda, da je implicitno predstavitev polnega dvojiškega drevesa s tabelo ali seznamom 
prvič predlagal Eytzinger \cite{e1590}.
Implicitno predstavitev je v svojih knjigah uporabil na primeru družinskih drevesih plemiških družin
\index{pedigree family tree}%
Podatkovno strukturo #BinaryHeap# opisano v tej knjigi je prvič predstavil Williams \cite{w64}.

Naključno podatkovno strukturo #MeldableHeap# sta prvič predlagala Gambin in Malinowski \cite{gm98}.
Obstajajo tudi druge implementacije zlivalnih kopic vključno z
levo poravnane kopice \cite[Section~5.3.2]{c72,k97v3},
\index{leftist heap}%
\index{heap!leftist}%
binomske kopice \cite{v78},
\index{binomial heap}%
\index{heap!binomial}%
Fibonaccijeve kopice \cite{ft87}, 
\index{Fibonacci heap}%
\index{heap!Fibonacci}%
parne kopice \cite{fsst86},\
\index{pairing heap}%
\index{heap!pairing}%
 in samoprilagoditvene kopice \cite{st83}, 
\index{skew heap}%
\index{heap!skew}%
Čeprav niso tako enostavne kot je struktura #MeldableHeap#.

Nekaj zgoraj navedenih struktur podpira tudi operacijo  \mbox[#decreaseKey(u,v)#]
\index{decreaseKey@#decreaseKey(u,y)#}%
v kateri se vrednost vozlišča #u# zniža na vrednost vozlišča #y# (ob predpogoju $#y#\le#u.x#$). 
V večini strukturah lahko opracijo #decreaseKey(u,v)# izvajamo s časovno zahtevnostjo
$O(\log #n#)$ z odstranjanjem vozlišča #u# in dodajanjem vozlišča #t#. Nekatere strukture
lahko implementirajo operacijo bolj učinkovito. V Fibonaccijevih kopicah ima amortizirano časovno 
zahtevnost $O(1)$ in amortizirano $O(\log\log #n#)$ v posebni različici parnih kopic \cite{e09}.
Omenjena učinkovitejša različica operacije #decreaseKey(u,y)# se uporablja pri 
pohitritvi grafov, vključno z algoritmom Dijkstre za iskanje najkrajše poti \cite{ft87}.

\begin{exc}
  Narišite dodajanje elementov vrednosti 7 in vrednosti 3 na #BinaryHeap#
  prikazano na koncu slike \figref{heap-insert}.
\end{exc}

\begin{exc}
  Narišite odstranjevanje naslednjih dveh elementov (6 in 8) na
  #BinaryHeap# prikazano na koncu slike \figref{heap-remove}.
\end{exc}

\begin{exc}
  Implementirajte metodo #remove(i)#, ki odstrani shranjene vrednosti v
  #a[i]# v #BinaryHeap#.  Metoda mora teči v časovni zahtevnosti $O(\log #n#)$.
  Razložite, zakaj se ta metoda verjetno ne bo uporabljala.
\end{exc}

\begin{exc}\exclabel{general-eytzinger}
  \index{tree!$d$-ary}%
  A $d$-ary drevo je posplošitev dvojiškega drevesa, v katerem ima vsako
  notranje vozlišče $d$ otrok.  Uporabite Eytzingerjevo metodo, ki je
  lahko predstavljena kot popolno $d$-tiško drevo z uporabo tabele. Ugotovite
  enačbe, v katerih je podan indeks #i#, določite indeks staršev od #i#
  in vsakega $d$ otroka od indeksa #i#'.
\end{exc}

\begin{exc}
  \index{DaryHeap@#DaryHeap#}%
  Uporabite kar ste spoznali v \excref{general-eytzinger}, oblikujte in
  implementirajte \emph{#DaryHeap#}, $d$-aryeva posplošitev
  #BinaryHeap#. Analizirajte čas poteka za operacije na #DaryHeap#
  in testirajte vaše delovanje #DaryHeap# katera se izvaja
  na #BinaryHeap# katere implementacija je podana.
\end{exc}



\begin{exc}
  Narišite dodajanje elementov vrednosti 17 in 82 v
  #MeldableHeap# #h1# prikazan na sliki \figref{meldable-merge}.  Uporabite kovanec za
  simulacijo naključnega bita, če je potrebno.
\end{exc}

\begin{exc}
  Narišite odstranjevanje naslednjih dveh elementov (4 in 8) iz
  #MeldableHeap# #h1# prikazano v \figref{meldable-merge}.  Uporabite kovanec za
  simulacijo naključnega bita, če je potrebno.
\end{exc}

\begin{exc}
  Implementirajte metodo #remove(u)#, ki odstrani vozlišče #u# iz
  a #MeldableHeap#.  Metoda mora teči v časovni zahtevnosti $O(\log #n#)$.
\end{exc}

\begin{exc}
 Pokažite, kako poiskati drugo najmanjšo vrednost v #BinaryHeap# ali v
  #MeldableHeap# v konstantnem času.
\end{exc}

\begin{exc}
  Poiščite $k$-to najmanjšo vrednost v #BinaryHeap# ali v
  #MeldableHeap# v časovni zahtevnosti $O(k\log k)$.  (Namig: Mogoče pomaga uporaba drugačne kopice.)
\end{exc}

\begin{exc}
  Predpostavimo da imamo podanih #k# razporejenih seznamov, dolžine #n#.  Z uporabo
  kopice, pokažite kako združiti urejene sezname v času $O(n\log
  k)$e.  (Namig: Pomaga, če začnete s primerom $k=2$".)
\end{exc}








