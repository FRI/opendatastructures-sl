\chapter{Zgoščevalne tabele}
\chaplabel{hashtables}
\chaplabel{hashing}


\section{#LinearHashTable#: Linearno naslavljanje}
\translatedby{Igor Plavšić}{sl}

\subsection{Povzetek}
\translatedby{Igor Plavšić}{sl}
Spodnji izrek je povzetek časovnih zahtevnosti, metod, podatkovne strukture #LinearHashTable#:

\begin{thm}\thmlabel{linear-probing}
  #LinearHashTable# implementira vmesnik #USet#.  Če ignoriramo
  ceno klicev metode #resize()#, je pričakovana časovna zahtevnost metod 
  #add(x)#, #remove(x)#, in #find(x)#, podatkovne strukture #LinearHashTable#,
  enaka $O(1)$.  

  Če začenjamo z prazno #LinearHashTable#, velja, da za 
  katero koli zaporedje $m$ operacij metod #add(x)# in #remove(x)#, 
  porabimo $O(m)$ časa za klice metode #resize()#.
\end{thm}

\subsection{Tabelarno zgoščevanje}
\translatedby{Igor Plavšić}{sl}
\seclabel{tabulation}

\index{tabulation hashing}%
Med analizo podatkovne strukture #LinearHashTable#, smo naredili zelo
močno predpostavko:  Da so za katero koli množico elementov, 
$\{#x_1#,\ldots,#x_n#\}$, zgoščevalne vrednosti $#hash(x_1)#,\ldots,#hash(x_n)#$
neodvisno in uniformno razporejene po množici $\{0,\ldots,#t.length#-1\}$.  
En način, kako to doseči je, da hranimo ogromno polje, #tab#, dolžine $2^{#w#}$,
kjer je vsak zapis naključno #w#-bitno celo število, neodvisno od vseh ostalih zapisov.  
Na ta način bi lahko implementirali #hash(x)#, tako da bi izbrali #d#-bitno celo število 
iz tabele #tab[x.hashCode()]#:
\codeimport{ods/LinearHashTable.idealHash(x)}

Na žalost, je hranjenje polja velikosti $2^{#w#}$ neoptimalna rešitev, 
kar se tiče prostorke porabe.  Pristop, ki ga uporablja 
\emph{tabulation hashing} je, da #w#-bitna cela števila obravnava kot 
cela števila, ki jih sestavljajo $#w#/#r#$ celih števil, ki imajo samo
$#r#$ bitov. Tako, pri tabelarnem zgoščevanju potrebujemo samo  $#w#/#r#$ 
polj velikosti $2^{#r#}$.  Vsi zapisi v teh poljih so neodvina #w#-bitna 
cela števila.  Da pridobimo vrednost #hash(x)#, razdelimo #x.hashCode()# 
v $#w#/#r#$ #r#-bitnih celih števil ter jih uporabimo kot indekse za polja.  
Nato vse te vrednosti združimo z bitnim operatorjem izključni-ali(XOR), 
da pridobimo #hash(x)#.
Spodnja programska koda prikazuje kako to deluje za $#w#=32$ in $#r#=4$:
\codeimport{ods/LinearHashTable.hash(x)}
V temu primeru je #tab# dvodimenzionalno polje s štirimi stolpci in $2^{32/4}=256$ vrsticami.

Enostavno lahko preverimo, da je, za poljubni #x#, #hash(x)# enakomerno razporejen 
čez $\{0,\ldots,2^{#d#}-1\}$.  Z malo dodatnega dela, lahko tudi preverimo, da ima 
poljubni par vrednosti, neodvisne zgoščene vrednosti. 
To pomeni, da bi se za implementacijo #ChainedHashTable#, namesto zgoščevalne funkcije - metode množenja 
uporabilo tabelatno zgoščevanje.

Dejstvo, da ima poljubna množica #n# različnih vrednosti množico #n# neodvisnih 
zgoščenih vrednosti ne velja.  Ne glede na to, pa velja, da ko uporabljamo tabelarno zgoščevanje, 
še vedno velja meja \thmref{linear-probing}.  
Reference za to lahko najdete na koncu tega poglavja.

% Podpoglavje 5.3
\section{Zgoščevalne vrednosti}
\translatedby{Andrej Rolih}{sl}

\index{Zgoščevalne vrednosti}%
Zgoščevalne tabele, ki smo si jih pogledali v prejšnjem podpoglavju se uporabljajo za povezovanje podatkov s celoštevilskimi ključi sestavljenimi iz #w# bitov. Velikokrat pa uporabljamo ključe, ki niso cela števila. Lahko so nizi znakov, objekti, tabele ali ostale sestavljene strukture. Da lahko uporabimo zgoščevalne funkcije na takih tipih podatkov moramo prej preslikati te podatke v #w#-bitne zgoščevalne vrednosti. Preslikave zgoščevalnih funkcij morajo imeti naslednje lastnosti:

\begin{enumerate}
  \item Če sta #x# in #y# enaka, potem morata biti enaka tudi #x.hashCode()# in #y.hashCode()# .

  \item Če #x# in #y# nista enaka, potem mora biti verjetnost, da sta
  $#x.hashCode()#=#y.hashCode()#$ majhna (blizu
  $1/2^{#w#}$).
\end{enumerate}

Prva lastnost nam zagotavlja, da če v zgoščevalni tabeli hranimo #x# in kasneje iščemo vrednost #y# (ki je enaka #x# ), da bomo našli #x# . Druga lastnost pa nam preprečuje izgubo podatkov pri pretvarjanju objektov v cela števila. Zagotavlja nam, da bodo različni objekti imeli različno zgoščevalno vrednost in bodo tako zelo verjetno shranjeni na različnih mestih v naši zgoščevalni tabeli. 

\subsection{Zgoščevalne vrednosti osnovnih podatkovnih tipov}

\index{Zgoščevalne vrednosti osnovnih podatkovnih tipov}%
Za majhne osvnovne podatkovne tipe kot so #char#, #byte#, #int#, in #float# lahko ponavadi hitro najdemo zgoščevalno vrednost. Ti podatkovni tipi imajo vedno binarno predstavitev sestavljeno iz #w# ali manj bitov. \javaonly{(V Javi je, #byte# 8-bitni podatkovni tip in #float# 32-bitni.)}\cpponly{(V C++ #char# ponavadi 8-bitni in #float# 32-bitni.)} . V teh primerih te bite obravnavamo kot cela števila na intervalu $\{0,\ldots,2^#w#-1\}$ . Če sta dve vrednosti različni potem dobijo različni zgoščevalni vrednosti. Če sta vrednosti enaki pa dobita enako zgoščevalno vrednost.

Nekateri podatkovni tipi pa so sestavljeni iz več kot #w# bitov. Ponavadi $c#w#$ bitov za neko konstantno celo število $c$ . (V Javi sta #long# in #double# primera tipov pri katerih je $c=2$.) Te podatkovne tipe lahko obravnavamo kot  objekte sestavljene iz $c$ delov, kot je opisano v naslednjem podpoglavju.

\subsection{Zgoščevalne vrednosti sestavljenih podatkovnih tipov}
\seclabel{stringhash}

\index{Zgoščevalne vrednosti sestavljenih podatkovnih tipov}%
Za sestavljene objekte si želimo zgraditi zgoščevalno funkcijo, ki bi kombinirala zgoščevalne vrednosti podatkovnih tipov, ki ta objekt sestavljajo. Vendar pa to ni tako enostavno kot zveni. Kljub temu, da lahko najdemo kar nekaj bljižnic s katerimi to lahko naredimo (na primer sestavljanje zgoščevalnih vrednosti z operacijo XOR) pa to ni rešitev problema, saj lahko hitro pridemo do primerov kjer take bljižnice odpovedo (glej naloge ~\ref{exc:hash-hack-first}--\ref{exc:hash-hack-last}). A vendar obstajajo hitri in robustni načini reševanja tega problema, če si lahko privoščimo računanje z $2#w#$ bitno natančnostjo. Zamislimo si objekt sestavljen iz delov $P_0,\ldots,P_{r-1}$ katerih zgoščevalne vrednosti so $#x#_0,\ldots,#x#_{r-1}$. Potem si lahko izberemo neodvisna in naključna  #w#-bitna števila $#z#_0,\ldots,#z#_{r-1}$ in eno liho in naključno celo število #z# sestavljeno iz $2#w#$ bitov. Iz tega lahko izračunamo zgoščevalno vrednost za naš objekt na naslednji način:
\[
   h(#x#_0,\ldots,#x#_{r-1}) =  
   \left(\left(#z#\sum_{i=0}^{r-1} #z#_i #x#_i\right)\bmod 2^{2#w#}\right)
   \ddiv 2^{#w#} \enspace .
\]

% Podpoglavje 5.4, prevedeno od primera 5.6 do konca
\section{Razprave in primeri}
\translatedby{Davor Vertelj}{sl}

\begin{exc}
  Zgodnejše verzije metode Java #hashCode()# za razred #String# ni delovala
  tako, da bi uporabila vse znake v dolgem nizu. Naprimer, za 16 znakov dolg
  niz se je koda razpršitve izračunala glede na osem sodo indeksiranih znakov. 
  Na primeru pojasnite zakaj to ni bila pametna ideja. Primer naj sestoji
  iz večjega nabora nizov, pri čemer naj imajo vsi enako kodo razpršitve.
\end{exc}

\begin{exc}\exclabel{hash-hack-first}
  Predpostavite da imate objekt sestavljen iz dveh #w#-bitnih števil, #x# in #y#. 
  Pokažite zakaj $#x#\oplus#y#$ ni dobra koda razpršitve za vaš objekt. Pokažite tudi 
  primer večje množice objektov, kjer bi vsi imeli kodo razpršitve 0.
\end{exc}

\begin{exc}
  Predpostavite da imate objekt sestavljen iz dveh #w#-bitnih števil, #x# in #y#. 
  Pokažite zakaj $#x#+#y#$ ni dobra koda razpršitve za vaš objekt. Pokažite tudi 
  primer večje množice objektov, kjer bi vsi imeli enako kodo razpršitve.
\end{exc}

\begin{exc}\exclabel{hash-hack-last}
  Predpostavite da imate objekt sestavljen iz dveh #w#-bitnih števil, #x# in #y#. Predpostavite
  tudi, da je koda razpršitve za vaš objekt definirana z deterministično funkcijo $h(#x#,#y#)$, ki ustvari eno samo #w#-bitno število. Dokažite da obstaja večja množica objektov, ki 
  imajo enako kodo razpršitve.
\end{exc}

\begin{exc}
  Naj za neko pozitivno število #w# velja $p=2^{#w#}-1$. Razložite zakaj za pozitivno število 
  $x$ velja 
  \[
      (x\bmod 2^{#w#}) + (x\ddiv 2^{#w#}) \equiv x \bmod (2^{#w#}-1) \enspace .
  \]
  (Dobimo algoritem za računanje $x \bmod (2^{#w#}-1)$ s pomočjo zaporednega nastavljanja 
  \javaonly{\[
    #x = x&((1<<w)-1) + x>>>w#
  \]}
  \cpponly{\[
    #x = x&((1<<w)-1) + x>>w#
  \]}
  dokler ne velja $#x# \le 2^{#w#}-1$.)
\end{exc}

\begin{exc}
  Izberite neko pogostokrat uporabljeno implementacijo zgoščene tabele kot je recimo \javaonly{JavaCollection Framework #HashMap#}\cpponly{The C++ STL #unordered\_map#} ali #HashTable# oziroma #LinearHashTable# iz te knjige in napišite program, ki v to podatkovno strukturo shranjuje števila, #x#, tako da je časovna zahtevnost funkcije #find(x)# linearna. Se pravi, poiščite množico #n# števil v kateri je $c#n#$ elementov, katerih koda razpršitve je na isti lokaciji v tabeli.
  Odvisno od kvalitete implementacije boste to mogoče lahko dosegli že samo z natančnim pregledom kode ali pa boste morali napisati nekaj vrstic kode, ki bo poskušala z vstavljanjem in iskanjem elementov ter merjenjem časa za dodajanje in iskanje posameznih vrednosti. (To se lahko, se tudi že je, uporabi za napad DOS(denial of service) na strežnike \cite{cw03}.)
  \index{algorithmic complexity attack}%
\end{exc}


%naslednji prevajalec naj nadaljuje od tu