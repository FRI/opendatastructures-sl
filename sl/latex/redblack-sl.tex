\chapter{Rdeče-Črna Drevesa}
\translatedby{Jan Keber, Jernej Jankovič, Matej Senožetnik }{sl}
\chaplabel{redblack}

\index{binary search tree!red-black}%
\index{red-black tree}%
V tem poglavju so predstavljena rdeče-črna drevesa. Le ta so zasnovana kot 
uravnotežena iskalna dvojiška drevesa z logaritemsko višino. So ena najbolj
razširjenih podatkovnih struktur in se pojavljajo kot primarne iskalne
strukture v mnogih knjižnicah, kot je Java Collections Framework, številnih 
implementacijah C++ Standard Template Library ter tudi znotraj jedra 
operacijskega sistema Linux. Nekaj glavnih razlogov zakaj so rdeče-črna 
drevesa tako priljubljena:
\begin{enumerate}
\item Največja možna višina rdeče-črnega drevesa z #n# vozlišči je enaka $2\log #n#$.
\item Časovna zahtevnost operacij #add(x)# in #remove(x)# je enaka $O(\log #n#)$ \emph{v najslabšem primeru}.
\item Amortizirano število rotacij, ki nastopijo med izvajanjem operacij #add(x)#
   ali #remove(x)# je konstantno.
\end{enumerate}
Že prvi dve lastnosti postavljajo rdeče-črna drevesa pred preskočne sezname,
naključna iskalna binarna drevesa in samouravnotežena binarna drevesa.
Preskočni seznami in naključna iskalna binarna drevesa se za-našajo na 
naključje, njihova pričakovana časovna zahtevnost je $O(\log #n#)$. 
Samouravnotežena binarna drevesa imajo zagotovljeno omejitev višine, vendar 
se #add(x)# in #remove(x)# izvršita v $O(\log#n#)$ amortiziranem času.  
Tretja lastnost je le pika na i. Pove nam, da je čas
potreben za vstavitev ali izločitev elementa #x# manjši od časa, ki ga porabimo
za iskanje elementa #x#.\footnote{Naključna iskalna binarna drevesa in
samouravnotežena binarna drevesa imajo enako lastnost. Glej vaje~\ref{exc:skiplist-changes} 
in \ref{exc:treap-rotates}.}

Vendar pa imajo dobre lastnosti rdeče-črnih dreves določeno ceno: 
kompleksnost implementacije. Ohranjati mejo višine $2\log #n#$ ni 
preprosto. Zahteva pazljivo in podrobno analizo številnih primerov. 
Zagotoviti moramo, da implementacija naredi natančno določeno stvar 
za določen primer. Že samo ena napačna rotacija ali zamenjava barve 
povzroči napako, ki jo je težko najti in razumeti. 

Preden se bomo lotili implementacije rdeče-črnih dreves, bomo spoznali 
ozadje sorodne podatkovne strukture: 2-4 drevesa. S tem bomo pridobili 
informacije na podlagi česa so bila rdeče-črna drevesa ustvarjena in kako 
jih je možno tako učinkovito ohranjati. 
\section{2-4 Trees}
\seclabel{twofour}

2-4 Drevo je korensko drevo, ki ima naslednje lastnosti:
\begin{prp}[height]
  Vsi listi imajo enako globino.
\end{prp}
\begin{prp}[degree]
  Vsako notranje vozlišče ima 2, 3 ali 4 otroke.
\end{prp}
Primer 2-4 drevesa je prikazan v \figref{twofour-example}.
\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/24rb-2}
  \end{center}
  \caption{2-4 drevo višine 3.}
  \figlabel{twofour-example}
\end{figure}
Lastnost 2-4 dreves je logaritemska višina v številu listov:
\begin{lem}\lemlabel{twofour-height}
  Najvišja višina 2-4 drevesa z #n# listi je $\log #n#$.
\end{lem}

\begin{proof}
  Omejenost vsakega notranjega vozlišča na najmanj 2 otroka dokakzuje, da imamo v 
  primeru višine $h$ v 2-4 drevesu vsaj $2^h$ listov.  Z drugimi besedami,
  \[
     #n# \ge 2^h \enspace .
  \]
  Če obe strani logaritmiramo dobimo neenačbo $h \le \log #n#$.
\end{proof}

\subsection{Dodajanje lista}

Dodajanje lista v 2-4 drevo je preprosto ( glej \figref{twofour-add}). Če želimo 
dodati list #u# kot otroka nekemu vozlišču #w# na predzadnjem nivoju, potem 
preprosto postavimo #u# za otroka vozlišča #w#. V tem primeru vsekakor ohranja 
višino, ampak lahko krši pravilo; če bi imel #w# štiri otroke pred dodajanjem #u#, 
potem ima #w# sedaj pet otrok.
V tem primeru moramo \emph{razdeliti}
\index{split}%
#w# v dve vozlišči, #w# in #w#', ki imata sedaj 2 in 3 otroke.
A ker #w#' sedaj nima staršev, #w# rekurzivno nastavimo kot otroka starša #w#. 
V tem primeru ima lahko starš vozlišča #w#' preveč otrok, zato ga moramo razdeliti.
Ta postopek se nadaljuje, dokler ne pridemo do vozlišča, ki ima manj kot štiri 
otroke ali dokler ne razdelimo korena #r#, v dva vozlišča #r# in #r'#. V slednjem 
primeru naredimo nov koren  ki ima otroka #r# in #r'#.
To hkrati povečuje globino vseh listov in tako ohranja višino 
the height property.

\begin{figure}
  \begin{center}
   \begin{tabular}{c}
     \includegraphics[scale=0.90909]{figs/24tree-add-1} \\
     \includegraphics[scale=0.90909]{figs/24tree-add-2} \\
     \includegraphics[scale=0.90909]{figs/24tree-add-3}
   \end{tabular}
  \end{center}
  \caption[Adding a leaf to a 2-4 Tree]{Dodajanje lista v 2-4 drevo.
  Ta proces se konča po enemu razdeljevanju, ker ima #w.parent# stopnjo manj kot 4 
  pred dodajanjem.}
  \figlabel{twofour-add}
\end{figure}

Ker višina 2-4 drevesa ni nikoli več kot $\log #n#$, se proces dodajanja listov 
konča po največ $\log #n#$ korakih.

\subsection{Odstranjevanje lista}

Odstranjevanje lista 2-4 drevesa je lahko rahlo bolj komplicirano kot dodajanje(Glej
\figref{twofour-remove}).  Da ločimo list #u# od njegovega starša #w#, ga samo odstranimo.  
Če ima #w# samo dva lista in mu mi enega izmed njih odstranimo, moramo drevo ustrezno 
popraviti, saj krši pravilo.  

\begin{figure}
  \begin{center}
   \begin{tabular}{c}
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-1} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-2} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-3} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-4} \\
     \includegraphics[height=\FifthHeightScaleIfNeeded]{figs/24tree-remove-5} \\
   \end{tabular}
  \end{center}
  \caption[Removing a leaf from a 2-4 Tree]{Odstranjevanje lista z 2-4 drevesa.  
  	Ta proces sega vse do korena, saj ima vsak prednik in bratje vozlišča #u# samo dva otroka.}
  \figlabel{twofour-remove}
\end{figure}

Da popravimo napako, poiščemo brata #w# ki je #w'#. Vozlišče #w'# definitivno
obstaja, ker ima  starš #w# vsaj dva otroka.  Če ima #w'#
tri ali štiri otroke, potem vzamemo enega izmed otrok in ga dodamo #w#. 
Sedaj ima #w# dva otroka in #w'# ima dva ali tri, nato končamo s popravljanjem.

Če ima #w'# samo dva otroka, potem ju \emph{združimo}
\index{merge}%
v skupno vozlišče, ki ima tri otroke.  Potem moramo rekurzivno izbrisati 
#w'#. dokler ne dosežemo vozlišča #u# ali njegovega brata, ki ima več kot dva otroka 
ali ne dosežemo korena.  Če je koren levi z enim samim otrokom, nato pobrišemo koren 
in otroka dodamo v koren. Tudi to istočasno zmanjšuje višino vsakega lista in tako 
ohranimo višino drevesa.

Ker višina 2-4 drevesa ni nikoli več kot $\log #n#$, se proces odstranjevanja listov 
konča po največ $\log #n#$ korakih.

\section{#RedBlackTree#: Simulirano 2-4 drevo}
\seclabel{redblacktree}
\translatedby{Karin Piškur}{sl}

Rdeče-črno drevo je binarno iskalno drevo, katerega vsako vozlišče, #u#,
je \emph{rdeče} ali \emph{črno}. Rdeče 
predstavlja vrednost $0$, črno pa vrednost $1$.
\index{rdeče vozlišče}%
\index{črno vozlišče}%
\javaimport{ods/RedBlackTree.red.black.Node<T>}
\cppimport{ods/RedBlackTree.RedBlackNode.red.black}

Pred in po spreminjanju rdeče-črnega drevesa, morata veljati naslednji dve
lastnosti. Vsaka lastnost je definirana v obeh izrazih, v rdeči in črni barvi in številskih vrednostih 0 in 1.
\begin{prp}[višina-črnih]
  \index{black-height property}%
  Enako število črnih vozlišč v poti od korena do katerega koli lista. (Vsota
  barv na poti od korena do poljubnega lista je enaka.)
\end{prp}

\begin{prp}[list-ni-rdeč]
  \index{no-red-edge property}%
  Dve rdeči vozlišči nista med seboj nikoli sosednji.  (Velja za vsako vozlišče #u#, razen korena,
  $#u.barva# + #u.stars.barva# \ge 1$.)
\end{prp}
Opazili smo, da lahko vedno pobarvamo koren, #r#, rdeče-črnega drevesa črno,
ne da bi kršili katero od lastnosti, zato bomo predvidevali, da je koren črne barve
in algoritmi za posodabljanje rdeče-črnih dreves bodo to upoštevali.
Druga stvar, ki poenostavlja rdeče-črna drevesa
je, da so zunanja vozlišča (predstavljena z #nil#) črna vozlišča.
Na ta način ima vsako vozlišče, #u#, rdeče-črnega drevesa natanko dva
otroka, vsak z opredeljeno barvo. Primer rdeče-črnega
drevesa je predstavljen v sliki \figref{redblack-example}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/24rb-1}
  \end{center}
  \caption[A red-black tree]{Primer rdeče-črnega drevesa, kjer je višina črnih 3. Zunanja (#nil#) vozlišča so v obliki kvadrata.} 
  \figlabel{redblack-example}
\end{figure}

\translatedby{Mitja Ahlin}{sl}
\subsection{Rdeče-Črna drevesa in 2-4 Drevesa}

Sprva se morda zdi presenetljivo, da lahko rdeče-črno drevo učinkovito
posodabljamo tako, da ohranjamo višine črnih vozlišč in ne ohranjamo lastnosti rdečih vozlišč. Zdi se tudi nenavadno, da nekateri menijo, da so to koristne lastnosti. Kakorkoli, rdeče-črna drevesa so bila zasnovana za učinkovito simulirati 2-4 drevesa kot binarna drevesa.


Nanašanje na \figref{twofour-redblack}.
Vzemimo, da ima katerokoli rdeče-črno drevo, $T$, #n# vozlišč in izvaja naslednje operacije: Zbriše vsako rdeče vozlišče #n# in poveže otroka vozlišča #u# direktno na (črnega) starša vozlišča #u#. Po spremembi imamo drevo $T'$ s samo črnimi vozlišči.

\begin{figure}
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics[scale=0.90909]{figs/24rb-3} \\
      \includegraphics[scale=0.90909]{figs/24rb-2}
    \end{tabular}
  \end{center}
  \caption{Vsako rdeče-črno drevo ima ustrezno 2-4 drevo.}
  \figlabel{twofour-redblack}
\end{figure}

Vsako notranje vozlišče v $T'$ ima dva, tri ali štiri otroke: Črno vozlišče, ki je imelo dva črna otroka bo še vedno imelo črna otroka po spremembi. Črno vozlišče, ki je imelo enega rdečega in enega črnega otroka bo imelo tri otroke po tej spremembi. Črno vozlišče, ki je imelo dva rdeča otroka bo imelo štiri otroke po teji spremembi. Poleg tega, lastnost črnih vozlišč nam zagotavlja, da je vsaka pot od korena do lista v $T'$ enake dolžine. Z drugimi besedami, $T'$ je 2-4 drevo!

2-4 drevo $T'$ ima $#n#+1$ listov, ki ustrezajo $#n#+1$ zunanjim vozliščim rdeče-črnega drevesa. Torej, to drevo ima višino največ $\log (#n#+1)$. Vsaka pot od korena do lista v 2-4 drevesu ustreza poti od korena rdeče-črnega drevesa $T$ do zunanjega vozlišča.
Prvo in zadnje vozlišče na poti sta črni in največ eno na vsaki dve notranji vozlišči je rdeče, tako, da ima ta pot največ $\log(#n#+1)$ črnih in največ $\log(#n#+1)-1$ rdečih vozlišč. Torej, najdaljša pot od korena do kateregakoli \emph{notranjega} vozlišča v $T$ je največ
\[
   2\log(#n#+1) -2 \le 2\log #n# \enspace ,
\]
za vsak $#n#\ge 1$. S tem dokažemo najpomembnejšo lastnost rdeče-črnih dreves:
\begin{lem}
Višina rdeče-črnega drevesa z #n# vozlišči je največ $2\log #n#$.
\end{lem}

Sedaj, ko smo videli relacijo med 2-4 drevesi in rdeče-črnimi drevesi, ni tako težko za verjeti, da lahko učinkovito ohranjamo rdeče-črno drevo med dodajanjem in brisanjem elementov.

Videli smo že, da dodajanje elementa v #BinarySearchTree# izvedemo z dodajanjem novega lista. Torej, za implementacijo #add(x)# v rdeče-črno drevo moramo imeti metodo za simulacijo razdelitve vozlišča s petimi otroki v 2-4 drevesu. Vozlišče v 2-4 drevesu s petimi otroki je predstavljeno s črnim vozliščem, ki ima dva rdeča otroka, eden od teh ima tudi rdečega otroka. Lahko ``razdelimo'' to vozlišče s tem, da ga pobarvamo v rdeče in pobarvamo njegova dva otroka v črno. Primer prikazuje \figref{rb-split}.

\begin{figure}
  \begin{center}
   \begin{tabular}{c}
     \includegraphics[scale=0.90909]{figs/rb-split-1} \\
     \includegraphics[scale=0.90909]{figs/rb-split-2} \\
     \includegraphics[scale=0.90909]{figs/rb-split-3} \\
   \end{tabular}
  \end{center}
  \caption[Simulirano 2-4 drevo]{Simuliranje operacije deljenja 2-4 drevesa med dodajanjem v rdeče-črno drevo. (To simulira dodajanje v 2-4 drevo prikazano na \figref{twofour-add}.)}
  \figlabel{rb-split}
\end{figure}

Podobno, implementacija #remove(x)# zahteva metodo za združevanje dveh vozlišč in izposojo sorodnikovega otroka. Združitev dveh vozlišč je inverz deljenja vozlišč (prikazano na \figref{rb-split}) in vključuje barvanje dveh (črnih) sorodnikov v rdeče in barvanje njegovega (rdečega) starša v črno. Izposoja od sorodnika je najboj zakompliciran postopek in vključuje obe rotacije in barvanje vozlišč.

Vsekakor, med vsem tem moramo še vedno ohranjati lastnost list-ni-rdeč in lastnost višina-črnih. Medtem ko ni več presenetljivo, da lahko naredimo direktno simulacijo 2-4 drevesa z rdeče-črnim drevesom, je vseeno veliko primerov, na katere moramo paziti. V določenem trenutku postane lažje, če ne upoštevamo 2-4 drevesa in samo ohranjamo lastnosti rdeče-črnega drevesa.

\subsection{Levo-poravnana rdece-crna drevesa}

\index{red-black tree}%
\index{left-leaning red-black tree}%
Definicija rdeče-črnega drevesa ne obstaja. Namesto tega imamo družino struktur, ki znajo ohranjati lastnosti višina-črnih in list-ni-rdeč med uporabo operacij #add(x)# in #remove(x)#. Različne strukture to delajo na različne načine. V našem primeru implementiramo podatkovno strukturo, ki ji rečemo #RedBlackTree#.
\index{RedBlackTree@#RedBlackTree#}%
Ta struktura implementira posebno obliko rdeče-črnega drevesa, ki zadovoljuje dodatno lastnost:
\begin{prp}[levo-poravnano]\prplabel{left-leaning}\prplabel{redblack-last}
  \index{left-leaning property}%
  Na kateremkoli vozlišču #u#, če je #u.left# črno, potem je #u.right# črno.
\end{prp}

Opomnimo, da rdeče-črno drevo prikazano na \figref{redblack-example} ne zadošča lastnosti levo-poravnano. Krši jo starš rdečega vozlišča na najbolj desni poti od korena proti listu.

Razlog za ohranjanje lastnosti levo-poravnano je, da zmanjšuje število soočenih primerov pri posodabljanju drevesa med operacijama #add(x)# in #remove(x)#. V smislu 2-4 dreves, to pomeni, da ima vsako 2-4 drevo edinstveno zastopanje: Vozlišče stopnje dva postane črno vozlišče z dvema črnima otrokoma. Vozlišče stopnje tri postane črno vozlišče, katerega levi otrok je rdeč in desni otrok je črn. Vozlišče stopnje štiri postane črno vozlišče z dvema rdečima otrokoma.

Preden podrobno opišemo implementacijo operacij #add(x)# in #remove(x)#, predstavimo nekaj osnovnih podoperacij, uporabljenih v metodah prikazanih v \figref{redblack-flippullpush}. Prvi dve podoperaciji stao za manipulacijo barv med ohranjanjem lastnosti višina-črnih. Operacija #pushBlack(u)# vzame za vhod črno vozlišče #u#, katero ima dva rdeča otroka in pobarva #u# rdeče in njegova dva otroka črno. Operacija #pullBlack(x)# obrne to opisano operacijo:
\codeimport{ods/RedBlackTree.pushBlack(u).pullBlack(u)}

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/flippullpush}
  \end{center}
  \caption{Rotacije, potegi in potiski}
  \figlabel{redblack-flippullpush}
\end{figure}

Metoda #flipLeft(u)# zamenja barve vozlišča #u# in #u.right# ter izvede levo rotacijo nad vozliščem #u#. Ta metoda obrne barve teh dveh vozlišč tako kot tudi njuno relacijo starš-otrok:
\codeimport{ods/RedBlackTree.flipLeft(u)}
Operacija #flipLeft(u)# je posebej uporabna pri povrnitvi lastnosti levo-poravnano na vozlišču #u#, katero krši to lastnost (ker je #u.left# črno in #u.right# rdeče). V tem posebnem primeru, smo lahko prepričani, da ta operacija ohranja obe lastnosti višina-črnih in list-ni-rdeč. Relacija #flipRight(u)# je simetrična s #fliPLeft(u)#, ko so vloge levega in desnega obrnjene.
\codeimport{ods/RedBlackTree.flipRight(u)}

\subsection{Dodajanje}

Za implementacijo #add(x)# v #RedBlackTree#, izvedemo standardno #BinarySearchTree# vstavljanje za dodajanje novega lista, #u#, z $#u.x#=#x#$ in nastavimo $#u.colour#=#red#$. Opomnimo, da to ne spremeni črne višine kateremukoli vozlišču, torej ne krši lastnosti višina-črnih. To pa lahko krši lastnost levo-poravnano (če je #u# desni otrok svojega starša) in lahko krši lastnost list-ni-rdeč (če je #u#jev starš #red#). Za povrnitev teh lastnosti, moramo klicati metodo #addFixup(u)#.
\codeimport{ods/RedBlackTree.add(x)}

Ilustrirano na \figref{rb-addfix}, metoda #addFixup(u)# vzame na vhod vozlišče #u#, katerega barva je rdeča in katero bi lahko kršilo lastnost list-ni-rdeč in/ali lastnost levo-poravnano. Slednja razprava je verjetno nemogoča za sledenje brez sklicevanja na \figref{rb-addfix} ali ponovnega ustvarjanja na kosu papirja. Preden bralec nadaljuje, bi moral preučiti to sliko.

\begin{figure}
  \begin{center}
    \includegraphics[width=\ScaleIfNeeded]{figs/rb-addfix}
  \end{center}
  \caption{Prikaz enega koraka pri popravljanju Lastnost~2 po vstavljanju.}
  \figlabel{rb-addfix}
\end{figure}

Če je #u# koren drevesa, potem lahko pobarvamo #u# črno za povrnitev obeh lastnosti. Če je tudi #u#jev sorodnik rdeč, potem mora biti #u#jev starš črn, torej obe lastnosti levo-poravnano in list-ni-rdeč že držita.
 
Sicer, najprej preverimo, če je #u#jev starš, #w#, kršil lastnost levo-poravnano in, če je da, potem izvedemo operacijo #flipLeft(w)# in nastavimo $#u#=#w#$. Tako pristanemo v lepo definiranem stanju: #u# je levi otrok starša, #w#, torej #w# sedaj zadošča lastnosti levo-poravnano. Vse kar nam ostane je, da zagotovimo lastnost list-ni-rdeč na #u#. Moramo samo še skrbeti za primer, v katerem je #w# rdeč, sicer že zadošča lastnosti list-ni-rdeč.

Če sta #u# in #w# rdeča, še nismo končali. Lastnost list-ni-rdeč (katero krši #u# in ne #w#) implicira, da #u#jev stari starš #g# obstaja in je črn. Če je #g#jev desni otrok rdeč, potem lastnost levo-poravnano zagotavlja, da oba #g#jev otrok je rdeč in klic na #pushBlack(g)# naredita #g# rdečega in #w# črnega. To povrne lastnost list-ni-rdeč na #u#, ampak lahko povzroči, da jo krši na vozlišču #g# tako, da celoten proces začne z $#u#=#g#$.

Če je #g#jev otrok črn, potem klic na #flipRight(g)# postane #w# črni starš od #g# in naredi #w#ju dva rdeča otroka, #u# in #g#. To zagotovi, da #u# zadošča lastnosti list-ni-rdeč in #g# zadošča lastnosti levo-poravnano. Sedaj lahko zaključimo.
\codeimport{ods/RedBlackTree.addFixup(u)}

Metoda #insertFixup(u)# ima konstantni čas za iteracijo in vsaka iteracija, ali konča ali premakne #u# bližje korenu. Zato, metoda #insertFixup(u)# konča po $O(\log #n#)$ iteracijah in po $O(\log #n#)$ času.


\subsection{Odstranitev}

Operacija #remove(x)# v #RedBlackTree# je najbolj zahtevna
za implementacijo in to velja za vse različice rdeče-črnega drevesa.
Tako kot operacija #remove(x)# v \texttt{BinarySearchTree}, ta operacija išče vozlišče #w# z enim otrokom, #u#, in spoji #w# iz drevesa tako, da #w.parent# posvoji #u#.

Težava lahko nastane takrat, ko je #w# črn, saj s tem kršimo lastnost višina-črnih v #w.parent#. 
Temu se lahko začasno izognemo z dodajanem #w.colour# do #u.colour#. To predstavlja dve težavi: (1)~če se #u# in #w# obe začneta s črno, potem $#u.colour#+#w.colour#=2$ (dvojna-črna), ki pa ni veljavna.
Če je bil #w# rdeč, se ga nadomesti s črnim vozliščem #u#, kateri lahko krši lastnost levo-poravnano pri $#u.parent#$. Obe težavi 
lahko rešimo tako, da pokličemo metodo #removeFixup(u)#.

Metoda #removeFixup(u)# prejme kot vhodni parameter vozlišče #u#, ki 
je črne (1) ali dvojno-črne barve (2). Če je #u# dvojno-črn, potem #removeFixup(u)# opravi vrsto vrtenj in prebarvanj tako, da dvojno-črno vozlišče premika navzgor po drevesu, dokler ni odpravljeno.
Skozi ta postopek se vozlišče #u# spreminja, dokler ne pride do konca, #u# pa pripada korenu  podrevesa, ki se je spremenil. Koren tega drevesa
je lahko sedaj druge barve. Če je prešel iz rdeče na črno barvo, metoda #removeFixup(u)# na koncu preverja,
če #u#jev starš krši lastnost levo-poravnano in če jo, to popravi.
\codeimport{ods/RedBlackTree.removeFixup(u)}

Metoda #removeFixup(u)# je predstavljena na \figref{rb-removefix}.
Naslednjemu besedilu bo težko, če ne kar nemogoče slediti,
brez sklicevanja na \figref{rb-removefix}. Vsaka ponovitev zanke
v postopku #removeFixup(u)# dvojno-črnega vozlišča #u#, temelji na
enemu od štirih primerov:

\begin{figure}
  \begin{center}
    \includegraphics[height=\HeightScaleIfNeeded]{figs/rb-removefix}
  \end{center}
  \caption{Iteracija v procesu odpravljanje dvojno-črnega vozlišča po odstranitvi.}
  \figlabel{rb-removefix}
\end{figure}

\noindent
Primer 0: #u# je koren. To je najpreprostejšji primer. Prebarvali smo
#u# v črno (s tem ne kršimo nobene lastnosti rdeče-črnega drevesa).

\noindent 
Primer 1: #u#jev sorodnik, #v#, je rdeč. V tem primeru, je #u#jev sorodnik levi otrok njegovega starša, #w# (z lastnostjo levo-poravnano). Opravimo
desno rotacijo na #w# in nadaljujemo z naslednjo ponovitvijo. Upoštevamo, da
ta ukrep povzroči, da #w#jev starš krši lasnost levo-poravnano in
globina #u# naraste. To pomeni tudi, da  bo naslednja
ponovitev v Primer~3, z #w# obarvanim rdeče. Pri preučevanju Primer~3
spodaj, bomo videli, da se postopek ustavi med naslednjo ponovitvijo.
\codeimport{ods/RedBlackTree.removeFixupCase1(u)}

\noindent
Primer 2: #u#jev sorodnik, #v#, je črn, #u# je levi otrok njegovega
starša, #w#. V tem primeru pokličemo funkcijo #pullBlack(w)#, ki obarva #u# črno, #v# rdeče in spremeni barvo #w# v črno ali dvojno-črno.
V tem primeru #w# ne izpolnjuje lastnost levo-porovnano, zato
to uredimo tako, da pokličemo #flipLeft(w)#.

V tem trenutku je #w# rdeč, #v# pa je koren poddrevesa,
v katerem smo začeli. Preveriti moramo še, če #w# ne povzroča kršitve
lastnosti list-ni-rdeč. To naredimo tako, da preverimo #w#jevega desnega otroka #q#.
Če je #q# črn, potem #w# izpolnjuje lastnost list-ni-rdeč in nadaljujemo z naslednjo ponovitvijo z  $#u#=#v#$.

Sicer (#q# je rdeč) sta obe lastnosti, list-ni-rdeč – rdeče pravilo in levo-poravnano, kršeni pri #q# in #w#. Levo-poravnano popravimo s klicem #rotateLeft(w)#, sedaj nam ostane le še lastnost list-ni-rdeč, ki jo še vedno kršimo. V tem trenutku je #q# levi sin od #v#, #w# je levi sin od #q#, #q# in #w# sta rdeča, #v# je črn ali dvojno-črn. #flipRight(v)# popravi drevo tako, da je #q# sedaj starš tako od #v# kot od #w#. Takoj zatem pokličemo #pushBlack(q)#, tako dobimo sledečo situacijo: #v# in #w# postaneta črna, #q# pa dobi originalno barvo od #w#.

Tako smo se znebili dvojno-črnega vozlišča ter ponovno vzpostavili lastnosti list-ni-rdeč in višina-črnih. Ostane nam samo še ena težava: če ima #v# desnega sina, ki je rdeč, kršimo lastnost levo-poravnano. To še preverimo ter pokličemo #flipLeft(v)#, ki nam to težavo odpravi, če je potrebno.
\codeimport{ods/RedBlackTree.removeFixupCase2(u)}

\noindent
Primer 3: #u#jev sorodnik je črn in #u# je desni otrok #w#. Primer je simetričen Primeru 2 in ga rešujemo precej podobno. Razlikuje se v tem, da je lastnost levo-poravnano asimetrična, in zato ga obravnavamo drugače.

Kot pri prejšnjem, začnemo s klicem #pullBack(w)#, kar naredi #v# rdeče vozlišče in #u# črno. S klicem #flipRight(w)# postane #v# koren našega poddrevesa. Tako je #w# rdeč, zato sedaj ločimo dva primera glede na #q#, ki je levi sorodnik #w#.

Če je #q# rdeč, nam da isto situacijo kot pri Primer~2, vendar z olajševalno okoliščino, namreč, #v# nam ne more pokvariti lastnosti levo-poravnano.

Bolj zapleteno pa je v primeru, ko je #q# črne barve. Tu moramo preveriti barvo levega otroka vozlišča #v#. Če je ta rdeč, potem ima #v# dva rdeča sinova, zato pokličemo #pushBlack(v)#. Sedaj je #w# črn, #v# je prejšnje barve #w# in smo končali z urejanjem.

Če je #v#jev levi otrok črn, kršimo lastnost levo-poravnano. Vzpostavimo jo nazaj s klicem #flipLeft(v)#. Nato vrnemo vozlišče #v#, zato da se naslednja iteracija #removeFixup(u)# nadaljuje z $#u#=#v#$.
\codeimport{ods/RedBlackTree.removeFixupCase3(u)}.

Vsaka iteracija #removeFixup(u)# se izvrši v konstantnem času. Primer~2 in 3 lahko proceduro končata, ali pa premakneta #u# bližje korenu drevesa. Primer 0 (kjer je #u# koren) se vedno konča, Primer~1 pelje v Primer~3, ki se prav tako konča. Ker vemo, da je višina drevesa največ $2\log#n#$, zaključimo, da imamo največ $O(\log #n#)$ iteracij procedure #removeFixup(u)#, torej se #removeFixup(u)# izvrši v $O(\log #n#)$ času.


\section{Povzetek}
\seclabel{redblack-summary}

Naslednji izrek povzema učinkovitost podatkovne strukture #RedBlackTree# :

\begin{thm}
  #RedBlackTree# uporablja vmestnik #SSet# in omogoča, da se operacije
  #add(x)#, #remove(x)# in #find(x)# izvedejo v najslabšem času $O(\log
  #n#)$ na operacijo.
\end{thm}

Kar ni vključeno v zgornji teoriji, ima dodatni bonus:

\begin{thm}\thmlabel{redblack-amortized}
  Med vsemi klici metod #addFixup(u)# in #removeFixup(u)# se 
  vsako zaporedje operacij #dodaj(x)# in #odstrani(x)# izvede v času
  $O(m)$, na zacetku ko je #RedBlackTree# prazen.
\end{thm}

Naredili smo samo skico dokaza za \thmref{redblack-amortized}. S primerjanjem
metod #addFixup(u)# in #removeFixup(u)#, z algoritmi za dodajanje ali 
odstranjevanje listov v 2-4 drevesu se lahko prepričamo, da se ta lastnost 
deduje z 2-4 drevesa. Običajno, če lahko dokažemo, da je skupni čas porabljen 
za delitev, združevanje in zadolževanje v 2-4 drevesu $O(m)$, potem ta dokaz 
namiguje na \thmref{redblack-amortized}.

Dokaz tega izreka za 2-4 drevo uporablja potencial 
\index{potential method}%
odplačne analize.\footnote{Oglej si
\lemref{dualarraydeque-amortized} in \lemref{selist-amortized} dokaze za potencialno metodo
v ostalih aplikacijah.} Definiraj potencial za notranje vozlišče #u# v 2-4 drevesu kot
\[
  \Phi(#u#) = 
    \begin{cases} 
      1 & \text{če ima #u# 2 otroka} \\ 
      0 & \text{če ima #u# 3 otroke} \\ 
      3 & \text{če ima #u# 4 otroke}  
    \end{cases}
\]
in potencial za 2-4 drevo kot vsoto potencialov za njegova vozlišča.
Delitev se pojavi, ko se vozlišča s štirimi otroci razdelijo na dve vozlišči
z dvemi in tremi octroci. To pomeni, da se skupni potencial zmanjša za $3-1-0 = 2$. 
Ko pride do združevanja, se dve vozlišči z dvemi otroki zamenjata z vozliščem, 
ki ima tri otroke. Rezultat tega je zmanjšanje potenciala za  $2-0=2$. Torej se za 
vsako delitev ali združitev potencial zmanjša za dva.

Nato bodite pozorni, da če zanemarimo delitev in združevanje vozlišč, temu sledi 
konstantno število vozlišč katerih število otrok je bilo s tem ali odstranitvijo 
lista spremenjeno. Ob dodajanju vozlišča se nekemu vozlišču število otrok poveča 
za ena, s tem pa povečamo potencial za največ tri.  Med odstranitvijo lista, se 
vozlišču zmanjša število otrok za ena, potencial pa se mu poveča največ za ena. 
Ob tem sta lahko v odstranjevanje vključeni dve vozlišči s čimer se njun 
potencial poveča za največ ena.

Kot povzetek torej sledi, da lahko vsaka združitev ali delitev povzroči
zmanjšanje potenciala za vsaj dva.  V primeru, da ne upoštevamo združitev
ter delitev pri dodajanju oziroma odstranjevanju, pa lahko povzroči povečanje
potenciala za največ tri. Potencial je vedno ne-negativno število.
Zatorej je število združitev ter delitev, povzročenih s strani
$m$ dodajanj oziroma odstranjevanj, na prvotno praznem drevesu največ $3m/2$.
\thmref{redblack-amortized} izhaja iz te analize in povezav med 2-4 drevesi in 
rdeče-črnimi drevesi.

\section{Razprava in naloge}

Rdeče-črna drevesa sta prvič predstavila Guibas in Sedgewick \cite{gs78}. 
Kljub njihovi visoki zapletenosti izvedbe so najdeni v nekaterih najbolj 
pogosto uporabljenih knjižnjicah in aplikacijah. Večina algoritmov in 
učbenikov o podatkovnih strukturah razpravlja o nekaj ražličicah rdeče-črnih dreves.

Andersson \cite{a93} je predstavil levo-visečo različico uravnananega drevesa, ki je
podobna rdeče-črnim drevesom, vendar z omejitvijo, da ima vsako vozlišče lahko največ 
enega rdečega otroka. Zaradi omenjene omejitve je izvedba 2-3 dreves veliko pogostejša 
od 2-4 dreves. Ta so veliko preprostejša kot podatkovna struktura #RedBlackTree# 
predstavljenih v tem poglavju.

Sedgewick \cite{s08} opisuje dve verziji levo-visečih rdeče-črnih dreves.
Te uporabljajo rekurzijo, skupaj s simulacijo delitvije od zgoraj navzdol in
združevanje v 2-4 drevesih. Kombinacija obeh tehnik nam omogoča zelo
kratek in eleganten zapis kode.

Povezana, a starejša, podatkovna struktura je \emph{AVL tree} \cite{avl62}.
\index{AVL tree}%
AVL drevesa so \emph{height-balanced}:
\index{height-balanced}%
\index{binary search tree!height balanced}%
V vsakem vozlišču $u$ se višina levega poddrevesa #u.left# ter desnega poddrevesa
#u.right# razlikuje za največ ena. Iz tega sledi: če je $F(h)$ najmanjše število
listov drevesa višine $h$, potem se $F(h)$ uvršča v okvir 
Fibonaccijevega zaporedja
\[
   F(h) = F(h-1) + F(h-2)
\]
z osnovnima primeroma $F(0)=1$ in $F(1)=1$.  $F(h)$ je tako približno
$\varphi^h/\sqrt{5}$, kjer je $\varphi=(1+\sqrt{5})/2\approx1.61803399$ is the
\emph{golden ratio}.  (Bolj natančno $|\varphi^h/\sqrt{5} - F(h)|\le 1/2$.)
S pomočjo utemeljitvije v \lemref{twofour-height}, to pomeni
\[
   h \le \log_\varphi #n# \approx 1.440420088\log #n# \enspace ,
\]
torej imajo AVL drevesa manjšo višino kot rdeče-črna drevesa.  Višina je
lahko vzdrževana med izvajanjem #dodaj(x)# in #odstrani(x)# operacij z
sprehodom navzgor do korena drevesa, med katerim se izvede uravnoteženje
vsakega vozlišču #u#, katerega višina levega in desnega
poddrevesa se razlikuje za dva. Glej \figref{avl-rebalance}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/avl-rebalance}
  \end{center}
  \caption{Uravnoteženje v AVL drevesih. Največ dve rotaciji sta potrebni, da
  vozlišče s poddrevesoma višine $h$ in $h+2$ spremenimo v vozlišče s poddrevesoma
  višine $h+1$.}
  \figlabel{avl-rebalance}
\end{figure}

Uporaba Anderssonove in Sadgewickove različice rdeče-črnih dreves in uporaba
AVL dreves je enostavnejša kot uporaba strukture #RedBlackTree#.
Žal pa ne more nobena od njih zagotavljati, da bi bil amortizacijski čas $O(1)$, 
za vsako posodobitev uravnovešen. Zlasti zato,
ker te strukture nemoremo primerjati z \thmref{redblack-amortized}.

\begin{figure}
  \centering{\includegraphics[scale=0.90909]{figs/redblack-example}}
  \caption{A red-black tree on which to practice.}
  \figlabel{redblack-example2}
\end{figure}

\begin{exc}
  Nariši 2-4 drevo, ki ustreza #RedBlackTree# iz
  \figref{redblack-example2}.
\end{exc}

\begin{exc}
  Nariši dodajanje elementov 13, 3.5 in 3.3 na #RedBlackTree#
  iz \figref{redblack-example2}.
\end{exc}

\begin{exc}
  Nariši odstranjevanje elementov 11, 9, ter 5 na #RedBlackTree# iz 
  \figref{redblack-example2}.
\end{exc}

\begin{exc}
  Pokaži, da za poljubno velike vrednosti #n#, obstaja rdeče-črno
  drevo z #n# vozlišči, ki imajo višino  $2\log #n#-O(1)$.
\end{exc}

\begin{exc}
  Preuči operaciji #pushBlack(u)# and #pullBlack(u)#. Kaj naredijo ti 
  dve operaciji na 2-4 drevesu, ki temelji na simulaciji z rdeče-črnim drevesom.
\end{exc}

\begin{exc}
  Pokaži, da za poljubno velike vrednosti #n#, obstaja zaporedje ukazov
  #dodaj(x)# in #odstrani(x)#, ki vodi do rdeče-črnega drevesa
  z #n# vozlišči, ki imajo višino $2\log #n#-O(1)$.
\end{exc}



\begin{exc}
  Zakaj metoda #odstrani(x)# v #RedBlackTree# izvede operacijo
  #u.parent=w.parent#? Naj nebi bilo to storjeno že z klicem metode #splice(w)#?
\end{exc}

\begin{exc}
  Predvidevaj, da ima 2-4 drevo $T$, $#n#_\ell$ listov in $#n#_i$ notranjih
  vozlišč.
  \begin{enumerate}
    \item Kakšna je najmanjša vrednost $#n#_i$, kot funkcija $#n#_\ell$?
    \item Kakšna je največja vrednost $#n#_i$, kot funkcija $#n#_\ell$?
    \item Če je $T'$ rdeče-črno drevo, ki predstavlja $T$, koliko ima potem $T'$
     rdečih vozlišč?
  \end{enumerate}
\end{exc}

\begin{exc}
  Predpostavimo, da imamo binarno iskalno drevo z #n# vozlišči in višini
  največ $2\log #n#-2$.  je možno, da vedno pobarvamo vozlišča tako, 
  da drevo zadošča pogoju črne višine in pogoju da rob ni rdeč?
  Če da, ali potem zadošča tudi lastnostim levo-visečih dreves?
\end{exc}

\begin{exc}\exclabel{redblack-merge}
  Predpostavimo, da imamo dva rdeče-črna drevesa $T_1$ in $T_2$, ki imata
  enako višino črnih vozlišč $h$ in, da je največji ključ v $T_1$ manjši
  od najmanjšega ključa v $T_2$. Prikaži kako se združita drevesi $T_1$ in $T_2$
  v eno rdeče-črno drevo v času $O(h)$.
\end{exc}

\begin{exc}
  Nadgradi rešitev iz \excref{redblack-merge}, da bo veljala tudi za drevesi 
  $T_1$ in $T_2$, ki imata različni višini črnih vozlišč , $h_1\neq h_2$.
  Čas izvajanja naj bo $O(\max\{h_1,h_2\})$.
\end{exc}



\begin{exc}
  Dokaži, da mora AVL drevo pri izvajanju #add(x)# metode, izvesti največ eno
  operacijo uravnoteženja (vključuje največ dve rotaciji; glej \figref{avl-rebalance}).
  Podaj primer AVL drevesa in klica metode #remove(x)# na tem drevesu, ki zahteva
  $\log #n#$ operacij uravnoteženja.
\end{exc}

\begin{exc}
  Napiši razred #AVLTree#, ki uporablja AVL drevo kot je opisano
  zgoraj.  Primerjaj hitrost izvajanja s hitrostjo #RedBlackTree#.
  Katera izvedba ima hitrejšo operacijo #find(x)#?
\end{exc}

\begin{exc}
  Oblikuj in izvedi vrsto poskusov, da primerjamo relativno uspešnost metod
  #find(x)#, #add(x)#, in #remove(x)# for the #SSet# implemeentations #SkiplistSSet#,
  #ScapegoatTree#, #Treap#, and #RedBlackTree#.  Bodite prepričani, da vključite več 
  testnih primerov, vključno s primeri, ko so podatki naključno razporejeni, že 
  razporejeni, jih odstranite, ko so urejeni in tako naprej.
\end{exc}
