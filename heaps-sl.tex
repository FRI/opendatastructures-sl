\chapter{Kopice}
\chaplabel{Kopice}
\translatedby{David Zavodnik}{sl}

V tem poglavju si bomo pogledali 2 implementacije zelo uporabne podatkovne strukture
#Polje# s prednostjo. Obe od teh dveh struktur sta posebne oblike Binarnega drevesa imenovani \emph{Kopica}, 
\index{Kopica}%
\index{Binarna Kopica}%
\index{Kopica!Binarna}%
kar pomeni ''neorganizirana kopica''. To je v nasprotju z binarnimi iskalnimi drevesi 
pri katerih pomislimo na zelo urejeno kopico.

Prva izvedba kopic uporablja polje, da simuliramo popolno binarno 
drevo.
Ta zelo hitra implementacija je osnova za enega izmed najhitrejših 
znanih sortirnih algoritmov, in sicer Kopično urejanje. (glej \secref{Kopicno urejanje}).

Druga implementacija je bazirana na bolj fleksiblinih binarnih drevesih, ki 
podpirajo #meld(h)# operacijo, ki omogoča vrsti s prednostjo, da obsorbira elemente druge vrste s prednostjo #h#.

\section{#Binarna Kopica#: implicitno binarno drevo}
\seclabel{BinarnaKopica}

\index{BinarnaKopica@#BinarnaKopica#}%
Naša prva implementacija #Vrste# (s prednostjo) temelji na tehniki, 
ki je stara preko 400 let. \emph{Eytzingerjeva metoda}
\index{Eytzingerjeva metoda}%
nam omogoča, da predstavimo popolno binarno drevo kot polje, v katerem imamo vozlišča 
postavljena v vrsto iz leve proti desni.
(glej \secref{bintree:traversal}).
Na ta način je koren drevesa shranjen na poziciji 0, njegov levi otrok je shranjen na poziciji 0, 
njegov desni otrok na pozciji 1, levi otrok na 2, levi otrok otroka na poziciji 3 in tako naprej.
Glej \figref{eytzinger}.

\begin{figure}
  \begin{center}
    \includegraphics[scale=0.90909]{figs/eytzinger}
  \end{center}
  \caption{Eytzingerjeva metoda predstavlja popolno binarno drevo kot polje.}
  \figlabel{eytzinger}
\end{figure}

Če uporabimo Eytzingerjevo metodo na dovolj velikih drevesih se
začnejo pojavljati vzorci.
Levi otrok vozlišča pri indexu #i# je na indexu $#left(i)#=2#i#+1$ 
in desni otrok vozlišča pri indexu #i# je na indexu $#right(i)#=2#i#+2$
Starš vozlišča pri indexu #i# pa je na $#parent(i)#=(#i#-1)/2$.
\codeimport{ods/BinaryHeap.left(i).right(i).parent(i)}

#Binarna Kopica# uporablja to tehniko, da implicitno predstavi popolno binarno drevo
v katerem so elementi \emph{Kopično urejeni}:
\index{heap-ordered binary tree}%
\index{binary tree!heap-ordered}%
\index{heap order}%
Vrednost shranjena na katerem koli indexu #i# ni manjša kot vrednost shranjena
na katerem koli indexu #parent(i)# razen izjeme vrednosti korena $#i#=0$. To nam 
omogoča, da je najmanjša vrednost #vrste# s prednostjo tako na shranjena na poziciji 0 (koren).

V Binarni kopici,  je #n# elementov shranjenih v tabeli #a#:
\codeimport{ods/BinaryHeap.a.n}

Implementacija operacije #dodaj(x)# je preprosta. Kot vse strukture bazirane na polju
najprej pogledamo, če je #a# poln (preverimo $#a.length#=#n#$) in če je, povečamo #a#. Nato #x# zapišemo na mesto #a[n]# in povečamo #n#. Na tej točki je potrebno storiti samo še to, da zagotovimo lastnost kopice.
To storimo tako, da zamenjujemo #x# z njegovim staršem, dokler ni #x# manjši od svojega starša.
See \figref{Kopica-vstavi}.
\codeimport{ods/BinaryHeap.add(x).bubbleUp(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-insert-4} \\
  \end{center}
  \caption[Adding to a BinaryHeap]{Dodajanje elementa 6 v Binarno kopico.}
  \figlabel{heap-insert}
\end{figure}

Implementacija #remove()# operacije, katera odstarani najmanjšo vrednost
v kopici, je nekoliko težje. Vemo, kje je najmanjši element (v korenu), vendar ga moramo po odstranitvi nadomestiti in zagotoviti, da ohranjamo
lastnosti kopice.

Najlažji način, da to naredimo je, da koren nadomestimo z vrednostjo #a[n-1]#, 
zbrišemo vrednost in zmanjšamo #n#. Na žalost novi koren najverjetneje ni najmanjši element, zato ga  moramo prestaviti po kopici navzdol. To naredimo tako, da rekurzivno primerjamo element z njegovimi otroki. V primeru, da je element v kopici najmanjši smo končali, v nasprotnem primeru ga zamenjamo z najmanjšim od njegovih otrok in nadaljujemo ta postopek rekurzivno.
\codeimport{ods/BinaryHeap.remove().trickleDown(i)}

\begin{figure}
  \begin{center}
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-1} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-2} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-3} \\
    \includegraphics[height=\QuarterHeightScaleIfNeeded]{figs/heap-remove-4} \\
  \end{center}
  \caption[Odstranjevanje iz binarne kopice]{Odstranjevanje najmanjšega elementa, 4, iz #Binarne Kopice#.}
  \figlabel{heap-remove}
\end{figure}


Kot ostale implementirane strukture polja, bomo mi ignorirali porabljen čas
v celicah za funkcijo #povecaj()#, ker se to lahko obračunava na amortizacijskem argumentu iz Lemma
\lemref{arraystack-amortized}. Pretečeni čas za #dodaj(x)# in #odstrani()# je odvisen
od višine (implicitnega) binarnega drevesa. Na srečo je to \emph{popolno}
\index{Binarno drevo!Popolno}%
\index{Popolno Binrano drevo}%
Binarno drevo;  vsak nivo, razen zadnji ima maximalno število vozlišč. Tako, je
višina drevesa enaka $h$ in ima najmanj $2^h$ vozlišč. Začnimo na ta način:
\[
  #n# \ge 2^h \enspace .
\]  
Algoritem nam da na obeh straneh enačbe
\[
   h \le \log #n# \enspace .
\]
tako obe, #dodaj(x)# in #odstrani()# operaciji tečeta v $O(\log #n#)$ času.

\subsection{Povzetek}

Naslednji teorem povzame uspešnost #Binarne Kopice#.

\begin{thm}\thmlabel{binaryheap}
  #Binarna Kopica# implementira #Polje# (s prednostjo). Ignoriramo ceno 
  polja da se poveča #resize()#, Binarna Kopica podpira operaciji 
  #dodaj(x)# in #odstrani()# v času $O(\log #n#)$ na operacijo.

  Poleg tega, začnimo s prazno #Binarna Kopica#, katero koli zaporedje $m$
  #dodaj(x)# in #odstrani()# operacij je rezultat skupaj $O(m)$ čas enak
  porabljen za vse klice funkcije #resize()#.
\end{thm}


\section{#MeldableHeap#: Naklju?na zdru?evalna kopica}
\seclabel{Zdru?evalna kopica}

\index{Zdruzevalnakopica@#MeldableHeap#}%
V poglavju bomo opisali #MeldableHeap#, implementacijo prioritetne #Queue#, shranjeno 
v kopi?asto urejenem binarnem drevesu. Z razliko od #BinaryHeap#, pri katerem binarno drevo
definira ?tevilo elementov, binarno drevo #MeldableHeap# nima omejitev glede oblike.

Operaciji #add(x)# in #remove()# v #MeldableHeap# sta implementirani z uporabo
operacije #merge(h1,h2)#. Operacija #merge(h1,h2)# zdru?i vozli??i kopice #h1# in #h2# in vrne
korensko vozli??e nove kopice, ki vsebuje vse elemente poddreves vozli?? #h1# in #h2#.

Operacijo #merge(h1,h2)# lahko implementiramo rekurzivno. Glej \figref{meldable-merge}.
?e je vozli??e #h1# oz. #h2# #nil#, zdru?ujemo s prazno mno?ico in vrnemo vozli??e #h1# ali #h2#,
ki ni #nil#. V nasprotnem primeru zamenjamo vlogi #h1# in #h2# glede na velikost
vrednosti vozli??a tako, da ve?je od obeh vozli?? postane koren nove kopice. V primeru, da je v korenu
vrednost #h1.x#, potem lahko #h2# lahko rekurzivno zdru?imo z #h1.left# ali #h1.right#, odvisno od
naklju?ne vrednosti meta kovanca. 
\codeimport{ods/MeldableHeap.merge(h1,h2)}

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/meldable-merge}}
  \caption[Zdru?evanje v zdru?evalni kopici]{Zdru?evanje #h1# in #h2# opravimo z zdru?itvijo #h2# in #h1.left# oz. #h1.right#.}
  \figlabel{meldable-merge}
\end{figure}

V naslednjem delu poglavja poka?emo, da ima operacija #merge(h1,h2)# pri?akovano ?asovno zahtevnost $O(\log #n#)$,
kjer je #n# kon?no ?tevilo elementov v #h1# in #h2#.

S pomo?jo operacije #merge(h1,h2)# je vstavljanje #add(x)# enostavno. Ustvarimo novo vozli??e #u# z vrednostjo #x# in
zdru?imo vozli??e s korenom kopice:
\codeimport{ods/MeldableHeap.add(x)}
Operacija ima pri?akovano ?asovno zahtevnost $O(\log (#n#+1)) = O(\log #n#)$.

Podobno je z operacijo #remove()#. Odstranjujemo korensko vozli??e, ki ga zamenja rezultat
zdru?evanja njegovih otrok:
\codeimport{ods/MeldableHeap.remove()}
Tudi remove ima pri?akovano ?asovno zahtevnost $O(\log #n#)$.

#MedlableHeap# lahko implementira tudi mnogo ostalih operacij s ?asovno zahtevnostjo
$O(\log #n#)$, npr.:
\begin{itemize}
\item #remove(u)#: iz kopice odstranimo vozli??e #u# (in pripadajo? klju? #u.x#).
\item #absorb(h)#: vse elemente #MeldableHeap# #h# dodamo kopici, kjer v postopku praznimo #h#.
\end{itemize}
Vsaka operacija lahko vsebuje konstantno ?tevilo #merge(h1,h2)# operacij s ?asovno zahtevnostjo
$O(\log #n#)$.

\subsection{Analiza #merge(h1,h2)#}

Analiza operacije #merge(h1,h2)# je osnovana na analizi naklju?nega sprehoda v binarnem drevesu.
V binarnem drevesu se \emph{random walk} za?ne v korenu drevesa. V vsakem koraku naklju?nega sprehoda
vr?emo kovanec, ki dolo?a smer sprehoda (levi ali desni otrok trenutnega vozli??a).
Ko trenutno vozli??e postane #nil# se sperhod kon?a.

Slede?a lema je zanimiva, ker ni odvisna od oblike binarnega drevesa:

\begin{lem}\lemlabel{tree-random-walk}
Pri?akovana dol?ina naklju?nega sprehoda v binarnem drevesu z #n# vozli??i je najve? #\log (n+1)#.
\end{lem}

\begin{proof}
Trditev lahko doka?emo z indukcijo. Za osnovo izberimo $#n#=0$ in dol?ino sprehoda $0=\log (#n#+1)$.
Trditev dr?i za vsa ne negativna ?tevila $#n#'< #n#$.


Dol?ino korenskega levega poddrevesa ozna?imo z $#n#_1$, da bo $#n#_2=#n#-#n#_1-1$ velikost
korenskega desnega poddrevesa. Sprehod se za?ne v korenu, zavzame en korak in nato nadaljuje v
poddrevesu velikosti $#n#_1$ ali $#n#_2$.
Po na?i induktivni hipotezi je pri?akovana dol?ina sprehoda 
\[
    \E[W] = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1)  \enspace , 
\] 
saj je vsako od $#n#_1$ ali $#n#_2$ manj?e od $#n#$. Ker je $\log$ funkcija konkavne
oblike $\E[W]$ dose?e maksimum, ko je $#n#_1=#n#_2=(#n#-1)/2$. 
%To maximize this,
%over all choices of $#n#_1\in[0,#n#-1]$, we take the derivative and obtain
%\[
%    (\E[W])' = \frac{1}{2}(c/#n#_1 - c/(#n#-#n#_1-1)) \enspace , 
%\]
%which is equal to 0 when $#n#_1 = (#n#-1)/2$.  We can establish that
%this is a maximum fairly easily, so
Potemtakem je pri?akovano ?tevilo korakov
\begin{align*}
    \E[W] 
    & = 1 + \frac{1}{2}\log (#n#_1+1) + \frac{1}{2}\log (#n#_2+1) \\
   & \le  1 + \log ((#n#-1)/2+1) \\
   & =  1 + \log ((#n#+1)/2) \\
   & =  \log (#n#+1)  \enspace . \qedhere 
\end{align*}
\end{proof}

Za bralce s pomankljivim poznavanjem informacijske teorije lahko dokaz za \lemref{tree-random-walk}
izrazimo s pomo?jo entropije.
\begin{proof}[Informaciski teoreti?ni dokaz za \lemref{tree-random-walk}]
Naj $d_i$ ozna?uje globino $i$-tega zunanjega vozli??a. Spomnimo se, da
ima binarno drevo z #n# vozli??i #n+1# zunanjih vozli??. Verjetnost, da bo
naklju?ni sprehod dosegel $i$-to zunanje vozli??e je natan?no 
$p_i=1/2^{d_i}$. Tako je pri?akovana dol?ina naklju?nega sprehoda
\[
   H=\sum_{i=0}^{#n#} p_id_i
    =\sum_{i=0}^{#n#} p_i\log\left(2^{d_i}\right)
    = \sum_{i=0}^{#n#}p_i\log({1/p_i})
\]
Desna stran ena?be je prepoznavna kot entropija verjetnostne distribucije na $#n#+1$ 
elementih, katera nikoli ne prese?e $\log(#n#+1)$, kar dokazuje lemo. 
S tem tudi enostavno doka?emo, da je ?as izvajanja operacije #merge(h1,h2)# $O(\log #n#)$.

With this result on random walks, we can now easily prove that the
running time of the #merge(h1,h2)# operation is $O(\log #n#)$.

\begin{lem}
  ?e sta #h1# in #h2# korena dveh kopic z vozli??ema $#n#_1$ in $#n#_2$ je pri?akovan
  ?as izvajanja operacije #merge(h1,h2)# najve? $O(\log #n#)$, kjer je $#n#=#n#_1+#n#_2$.
\end{lem}

\begin{proof}
  Vsak korak algoritma za zdru?evanje zavzame en korak v naklju?nem sprehodu,
  bodisi v kopici s korenom #h1# bodisi v kopici s korenom #h2#.
  Algoritem se zaklju?i ko katerikoli izmed dveh naklju?nih sprehodov dose?e
  konec drevesa. Pri?akovano ?tevilo korakov zdru?evalnega algoritma je najve? 
  \[
     \log (#n#_1+1) + \log (#n#_2+1) \le 2\log #n# \enspace . \qedhere
  \]
\end{proof}

\subsection{Povzetek}

Slede?i teorem povzame zmogljivost #MeldableHeap#:

\begin{thm}\thmlabel{meldableheap}
  #MeldableHeap# implementira (prioritetni) #Queue# vmesnik.
  #MeldableHeap# podpira operaciji #add(x)# in #remove()#.
  $O(\log #n#)$ je pri?akovan ?as izvajanja posamezne operacije.
\end{thm}

\section{Diskusije in vaje}

Izgleda, da je implicitno predstavitev polnega binarnega drevesa s tabelo ali seznamom 
prvi? predlagal Eytzinger \cite{e1590}.
Implicitno predstavitev je v svojih knjigah uporabil na primeru plemi?kih dru?inskih drevesih
\index{pedigree family tree}%
Podatkovno strukturo #BinaryHeap# opisano v tej knjigi je prvi? predstavil Williams \cite{w64}.

Naklju?no podatkovno strukturo #MeldableHeap# sta prvi? predlagala Gambin in Malinowski \cite{gm98}.
Obstajajo tudi druge implementacije zdru?evalnih kopic vklju?no z
levo poravnane kopice \cite[Section~5.3.2]{c72,k97v3},
\index{leftist heap}%
\index{heap!leftist}%
binomske kopice \cite{v78},
\index{binomial heap}%
\index{heap!binomial}%
Fibonaccijeve kopice \cite{ft87}, 
\index{Fibonacci heap}%
\index{heap!Fibonacci}%
parne kopice \cite{fsst86},\
\index{pairing heap}%
\index{heap!pairing}%
 in samoprilagoditvene kopice \cite{st83}, 
\index{skew heap}%
\index{heap!skew}%
?eprav niso tako enostavne kot je struktura #MeldableHeap#.

Nekaj zgoraj navedenih struktur podpira tudi operacijo #decreaseKey(u,v)#
\index{decreaseKey@#decreaseKey(u,y)#}%
v kateri se vrednost vozli??a #u# zni?a na vrednost vozli??a #y# (ob predpogoju $#y#\le#u.x#$). 
V ve?ini strukturah lahko opracijo #decreaseKey(u,v)# izvajamo s ?asovno zahtevnostjo
$O(\log #n#)$ z odstranjanjem vozli??a #u# in dodajanjem vozli??a #t#. Nekatere strukture
lahko implementirajo operacijo bolj u?inkovito. V Fibonaccijevih kopicah ima amortizirano ?asovno 
zahtevnost $O(1)$ in amortizirano $O(\log\log #n#)$ v posebni razli?ici parnih kopic \cite{e09}.
Omenjena u?inkovitej?a razli?ica operacije #decreaseKey(u,y)# se uporablja pri 
pohitritvi grafov, vklju?no z Dijkstra algoritmom za iskanje najkraj?e poti \cite{ft87}.

\begin{exc}
  Illustrate the addition of the values 7 and then 3 to the #BinaryHeap#
  shown at the end of \figref{heap-insert}.
\end{exc}

\begin{exc}
  Illustrate the removal of the next two values (6 and 8) on the
  #BinaryHeap# shown at the end of \figref{heap-remove}.
\end{exc}

\begin{exc}
  Implement the #remove(i)# method, that removes the value stored in
  #a[i]# in a #BinaryHeap#.  This method should run in $O(\log #n#)$ time.
  Next, explain why this method is not likely to be useful.
\end{exc}

\begin{exc}\exclabel{general-eytzinger}
  \index{tree!$d$-ary}%
  A $d$-ary tree is a generalization of a binary tree in which each
  internal node has $d$ children.  Using Eytzinger's method it is also
  possible to represent complete $d$-ary trees using arrays.  Work out
  the equations that, given an index #i#, determine the index of #i#'s
  parent and each of #i#'s $d$ children in this representation.
\end{exc}

\begin{exc}
  \index{DaryHeap@#DaryHeap#}%
  Using what you learned in \excref{general-eytzinger}, design and
  implement a \emph{#DaryHeap#}, the $d$-ary generalization of a
  #BinaryHeap#. Analyze the running times of operations on a #DaryHeap#
  and test the performance of your #DaryHeap# implementation against
  that of the #BinaryHeap# implementation given here.
\end{exc}



\begin{exc}
  Illustrate the addition of the values 17 and then 82 in the
  #MeldableHeap# #h1# shown in \figref{meldable-merge}.  Use a coin to
  simulate a random bit when needed.
\end{exc}

\begin{exc}
  Illustrate the removal of the next two values (4 and 8) in the
  #MeldableHeap# #h1# shown in \figref{meldable-merge}.  Use a coin to
  simulate a random bit when needed.
\end{exc}

\begin{exc}
  Implement the #remove(u)# method, that removes the node #u# from
  a #MeldableHeap#.  This method should run in $O(\log #n#)$ expected time.
\end{exc}

\begin{exc}
  Show how to find the second smallest value in a #BinaryHeap# or
  #MeldableHeap# in constant time.
\end{exc}

\begin{exc}
  Show how to find the $k$th smallest value in a #BinaryHeap# or
  #MeldableHeap# in $O(k\log k)$ time.  (Hint: Using another heap
  might help.)
\end{exc}

\begin{exc}
  Suppose you are given #k# sorted lists, of total length #n#.  Using
  a heap, show how to merge these into a single sorted list in $O(n\log
  k)$ time.  (Hint: Starting with the case $k=2$ can be instructive.)
\end{exc}








