\chapter{Iskanje v zunanjem pomnilniku}
\chaplabel{btree}
\translatedby{Jerneja Gaber}{sl}
\translatedby{Matej Batič}{sl}
\translatedby{Klemen Koželj}{sl}
\translatedby{Žane Ban}{sl}
\translatedby{Klemen Randl}{sl}
\translatedby{Robert Rozina}{sl}

Skozi knjigo smo uporabljali #w#-bitni besedni-RAM model računanja, katerega smo opredelili v \secref{model}. Implicitna predpostavka tega modela je, da ima naš računalnik dovolj velik bralno-pisalni pomnilnik za shranjevanje vseh podatkov v podatkovni strukturi. V nekaterih primerih ta predpostavka ni veljavna. Obstajajo zbirke podatkov, ki so tako velike, da noben računalnik nima dovolj glavnega pomnilnika za njihovo shranjevanje. V takih primerih se mora aplikacija zateči k shranjevanju podatkov na pomožni, zunanji pomnilniški medij, kot je trdi disk, SSD disk ali celo omrežni datotečni strežnik (ki ima lastno zunanje shranjevanje). 

\index{zunanji pomnilnik}%
\index{zunanji spomin}%
\index{trdi disk}%
\index{SSD disk}%
Dostopanje do elementa v zunanjem pomnilniku je zelo počasno. Trdi disk v računalniku, na katerem je bila spisana ta knjiga, ima povprečen čas dostopa $19$ ms, SSD disk pa ima povprečen čas dostopa $0{,}3$ ms. Za primerjavo, bralno-pisalni pomnilnik v računalniku ima povprečen čas dostopa manj kot $0{,}000113$ ms. Dostop do RAM-a je več kot $2.500$-krat hitrejši kot dostop do SSD diska, ter več kot $160.000$-krat hitrejši kot dostop do trdega diska. 

%  HDD: Fantom ST3000DM001-9YN166 USB 3 external drive (3TB)
%  SSD: ATA OCZ-AGILITY 3 (60GB)
%  Mem: Mushkin Enhanced Essentials 4GB (2 x 2GB) 204-Pin DDR3 
%       SO-DIMM DDR3 1066 (PC3 8500) Dual Channel Kit Laptop Memory
%       Model 996643
%  RAM speed was estimated using this program:
% #include<stdlib.h>
% #include<stdio.h>
% #include<time.h>
% 
% int main(void) {
%    unsigned *a, x, i, n = 50000000;
%    clock_t start, stop;
% 
%    start = clock();
%    a = malloc(sizeof(unsigned)*n);
%    for(i = 0; i < n; i++) {
%      x |= a[rand()%n];
%    }
%    stop = clock();
%    printf("x=%x, %g\n", x, (((double)(stop-start))/(double)CLOCKS_PER_SEC)/(double)n);
%    free(a);
%    return 0;
% }

Te hitrosti so dokaj tipične; dostopanje do naključnega bajta v RAM-u je tisočkrat hitrejše kot dostopanje do naključnega bajta na trdem disku ali SSD disku. Čas dostopa pa vseeno ne pove vsega. Ko dostopamo do bajta na trdem disku ali SSD disku je prebran celoten \emph{blok} 
\index{blok}%
diska. Vsak izmed diskov na računalniku ima velikost bloka 4\,096; vsakič, ko preberemo en bajt, nam disk vrne blok, ki vsebuje 4\,096 bajtov. Če našo podatkovno strukturo skrbno organiziramo, to pomeni, da z vsakim dostopom do diska dobimo 4\,096 bajtov, ki so nam v pomoč pri dokončanju operacije.

% morin@peewee:~/git/ods/latex$ sudo blockdev --report
% RO    RA   SSZ   BSZ   StartSec            Size   Device
% rw   256   512  4096          0     60022480896   /dev/sda   SSD
% rw   256  4096  4096        504   3000581885952   /dev/sdb1  HDD

To je ideja računanja z \emph{modelom zunanjega pomnilnika}, 
\index{model zunanjega pomnilnika}%
shematsko prikazanega v \figref{em}. Pri tem modelu ima računalnik dostop do velikega zunanjega pomnilnika, kjer so vsi podatki. Ta pomnilnik je razdeljen na spominske \emph{bloke}, 
\index{blok}%
kjer vsak vsebuje $B$ besed. Računalnik ima tudi omejen notranji pomnilnik na katerem lahko opravlja izračune. Čas za prenos bloka med notranjim in zunanjim pomnilnikom je konstanten. Izračuni izvedeni v notranjem pomnilniku so \emph{zanemarljivi}; ne vzamejo nič časa. Da so izračuni na notranjem pomnilniku zanemarljivi, se morda sliši malo nenavadno, vendar le preprosto poudarja dejstvo, da je zunanji pomnilnik toliko počasnejši od RAM-a. 

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/em}}
  \caption[Model zunanjega pomnilnika]{V modelu zunanjega pomnilnika, dostop do posameznega elementa #x# v zunanjem pomnilniku, zahteva branje celotnega bloka, ki vsebuje #x#, v glavni pomnilnik.}
  \figlabel{em}
\end{figure}

V popolnem modelu zunanjega pomnilnika je velikost notranjega pomnilnika tudi parameter. Vendar pa za podatkovne strukture opisane v tem poglavju zadošča, da imamo notranji pomnilnik velikosti $O(B+\log_B #n#)$. To pomeni, da mora biti pomnilnik sposoben shraniti konstantno število blokov in rekurziven sklad višine $O(\log_B #n#)$. V večini primerov, izraz $O(B)$ prevladuje pri zahtevah po pomnilniku. Na primer, tudi pri relativno majhni vrednosti $B=32$, $B\ge \log_B #n#$ za vse $#n#\le 2^{160}$. V desetiškem zapisu, $B\ge \log_B #n#$ za vse 
\[
#n# \le 1\,461\,501\,637\,330\,902\,918\,203\,684\,832\,716\,283\,019\,655\,932\,542\,976 \enspace 
. \]

\section{Bločna shramba}

Pojem zunanjega pomnilnika vključuje veliko število različnih naprav, od katerih ima vsaka svojo velikost bloka in je dostopna s svojo zbirko sistemskih klicev. Da poenostavimo razlago tega poglavja in se osredotočimo na skupne ideje, povzamemo zunanje pomnilniške naprave z objektom bločna shramba. Bločna shramba hrani zbirko spominskih blokov, kjer ima vsak velikost $B$. Vsak blok je enolično določen s celoštevilskim indeksom. Bločna shramba podpira sledeče operacije:

\begin{enumerate}
  \item #readBlock(i)#: Vrne vsebino bloka z indeksom #i#.

  \item #writeBlock(i,b)#: Zapiše vsebino bloka #b# v blok z indeksom #i#.

  \item #placeBlock(b)#: Vrne nov indeks in shrani vsebino bloka #b# na ta indeks.

  \item #freeBlock(i)#: Sprosti blok z indeksom #i#. To nakazuje, da vsebina tega bloka ni več v uporabi in, da se zunanji pomnilnik, ki je bil dodeljen temu bloku, lahko ponovno uporabi.
\end{enumerate}

Bločno shrambo si najlažje predstavljamo tako, da si ga zamislimo kot shranjevanje datoteke na disk, kateri je razdeljen na bloke, kjer vsak vsebuje $B$ bajtov. Na ta način #readBlock(i)# in #writeBlock(i,b)# preprosto bereta in zapisujeta bajte $#i#B,\ldots,(#i#+1)B-1$ te datoteke. Poleg tega bi preprosta bločna shramba lahko vodila \emph{prosti seznam} blokov, ki so na voljo za uporabo. Bloki, sproščeni s #freeBlock(i)#, so dodani prostemu seznamu. Na ta način lahko #placeBlock(b)# uporabi blok iz prostega seznama ali, če nobeden ni na voljo, doda nov blok na konec datoteke.

\section{B-drevesa}
\seclabel{B drevo}
\translatedby{Tanja Štular}{sl}

V tem poglavju bomo razpravljali o posplošitvah dvojiških dreves,
imenovanih $B$-drevesa, ki so učinkovita predvsem v zunanjem pomnilniškem modelu.
Alternativno se na $B$-drevesa lahko gleda kot na posplošitev 2-4 dreves, 
opisana v poglavju \secref{twofour}. (2-4 drevo je posebni primer $B$-drevesa,
ki ga dobimo z določitvijo $B=2$.)

\index{B-tree@$B$-tree}%
Za katerokoli število $B\ge 2$ je \emph{$B$-drevo}, drevo, pri katerem imajo vsi
listi enako globino in vsako notranjo vozlišče (z izjemo korena), #u#,
ima najmanj $B$ otrok in največ $2B$ otrok. Otroci vozlišča #u#
so shranjeni v polju #u.children#. Zahtevano število otrok ne velja pri korenu, ki
pa ima lahko število otrok med 2 in $2B$.

Če je višina $B$-drevesa $h$, iz tega sledi, da število listov v $B$-drevesu
$\ell$, izpolnjuje naslednji neenakosti: 
\[
    2B^{h-1} \le \ell \le 2(2B)^{h-1} \enspace .
\]
Vzamemo logaritem iz prve neenakosti in preuredimo. Dobimo:
\begin{align*}
    h & \le \frac{\log \ell-1}{\log B} + 1  \\
      & \le \frac{\log \ell}{\log B} + 1 \\
      & = \log_B \ell + 1 \enspace .
\end{align*}
Višina $B$-drevesa je sorazmerna logaritmu števila listov z 
osnovo $B$.

Vsako vozlišče, #u#, v $B$-drevesu shranjuje polje ključev
$#u.keys#[0],\ldots,#u.keys#[2B-1]$.  Če je #u# notranje vozlišče z $k$
otroci, potem je število ključev, ki so shranjeni v #u# natanko $k-1$ in ti so
shranjeni v $#u.keys#[0],\ldots,#u.keys#[k-2]$.  Ostalih $2B-k+1$
mest v polju #u.keys# je nastavljeno na #null#.  Če je #u# notranje vozlišče
in ni koren, potem #u# vsebuje med $B-1$ in $2B-1$ ključev. Ključi v 
$B$-drevesu so razvrščeni podobno kot ključi v dvojiškem iskalnem drevesu.
Za vsako vozlišče #u#, ki shranjuje $k-1$ ključev velja:
\[
   #u.keys[0]# < #u.keys[1]# < \cdots < #u.keys#[k-2] \enspace .
\]
Če je #u# notranje vozlišče, potem za vsak $#i#\in\{0,\ldots,k-2\}$ velja, da
$#u.keys[i]#$ je večji od vseh ključev shranjenih v poddrevesu zakoreninjenega na
#u.children[i]# vendar manjši od vseh ključev shranjenih v poddrevesu, ki je zakoreninjen
na $#u.children[i+1]#$. 
\[
   #u.children[i]# \prec #u.keys[i]# \prec #u.children[i+1]# \enspace .
\]
Primer $B$-drevesa z $B=2$ je prikazan na sliki \figref{btree}.

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/btree-1}}
  \caption{$B$-drevo, $B=2$.}
  \figlabel{btree}
\end{figure}

Upoštevajte, da so podatki shranjeni v vozliščih $B$-drevesa velikosti $O(B)$. Zato
je v nastavitvah zunanjega pomnilnika vrednost $B$ za $B$-drevo določena tako,
da celotno vozlišče lahko ustreza enemu zunanje pomnilniškemu bloku. V tem primeru
je čas izvajanja operacij na $B$-drevesu v zunanjem spominskem modelu
sorazmerno številu vozlišč, ki jih obiščemo (branje ali pisanje) med operacijo.

Poglejmo si primer. Če ključe predstavljajo 4 bajtna števila in indeksi vozlišč so prav tako 
veliki 4 bajte, potem nastavitev $B=256$ pomeni, da vsako vozlišče hrani
\[
(4+4)\times 2B
 = 8\times512=4096
\]
bajtov podatkov. To bi bila odlična vrednost $B$ za trdi disk ali
pogon SSD (predstavljen v uvodu tega poglavja), kateri
ima velikost bloka $4096$ bajtov.

#BTree# razred, ki implementira $B$-drevo, vsebuje #BlockStore#,
#bs#,ki vsebuje #BTree# vozlišča in prav tako indeks, #ri#, korena.  
Kot ponavadi, število #n# predstavlja količino podatkov v podatkovni
strukturi:
\codeimport{ods/BTree.n.ri.bs}

\subsection{Iskanje}

Implementacija operacije #find(x)#, ilustrirana v 
\figref{btree-find}, je posplošitev operacije #find(x)# v dvojiškem
iskalnem drevesu.  Iskanje #x#-a se začne v korenu. Z uporabo ključev,
shranjenih v vozlišču, #u#, določimo v katerem otroku od #u# bomo
nadaljevali iskanje.

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/btree-2}}
  \caption[Searching in a $B$-tree]{Uspešno iskanje (vrednosti 4)
    in neuspešno iskanje (za vrednost 16.5) v $B$-drevesu. Obarvana vozlišča predstavljajo, kje se je vrednost med iskanjem #z#ja spremenila.}
  \figlabel{btree-find}
\end{figure}
Bolj natančno, v vozlišču #u# iskanje preveri če je #x# shranjen
v #u.keys#. Če je, je bil #x# najden in iskanje je zaključeno.
V nasprotnem primeru, najdemo najmanjše število #i#, da je
$#u.keys[i]# > #x#$ in nadaljujemo iskanje v poddrevesu zakoreninjenem na
#u.children[i]#. Če noben ključ v #u.keys# ni večji od #x#, potem iskanje
nadaljujemo v najbolj desnem otroku od #u#. Tako kot pri dvojiškem iskalnem
drevesu, si algoritem zapolni nedavno viden ključ, #z#, ki je
večji od #x#. V primeru, ko #x# ni najden, se #z# vrne kot
najmanjša vrednost, ki je večja ali enaka #x#.
\codeimport{ods/BTree.find(x)}
Osrednjega pomena za metodo #find(x)# je metoda #findIt(a,x)#, ki
išče v #null#-napolnjeno urejeno polje, #a#, vrednost #x#.
Ta metoda, predstavljena v \figref{findit}, deluje za vsako polje,
#a#, kjer je $#a#[0],\ldots,#a#[k-1]$ urejeno zaporedje ključev
in so $#a#[k],\ldots,#a#[#a.length#-1]$ vsi postavljeni na #null#.
Če je #x# v polju na mestu #i#, potem metoda #findIt(a,x)# vrne
$-#i#-1$. V nasprotnem primeru vrne najmanjši indeks, #i#, za katerga velja, da
$#a[i]#>#x#$ ali $#a[i]#=#null#$.
\begin{figure}
  \centering{\includegraphics[scale=0.90909]{figs/findit}}
  \caption[The findIt(a,x) method]{Izvajanje metode #findIt(a,27)#.}
  \figlabel{findit}
\end{figure}
\codeimport{ods/BTree.findIt(a,x)}
Metoda #findIt(a,x)# uporabi dvojiško iskanje 
\index{binary search}%
, ki razpolovi iskanje pri vsakem koraku.
Za delovanje porabi $O(\log(#a.length#))$ časa. V našem primeru, $#a.length#=2B$, zato #findIt(a,x)# porabi $O(\log B)$ časa.

Čas delovanja obeh operacij $B$-drevesa #find(x)# lahko analiziramo
v običajnem besednem-RAM modelu (kjer štejemo vsak ukaz) in v
zunanjem pomnilniškem modelu (kjer štejemo samo število obiskanih vozlišč).
Ker vsak list v $B$-drevesu shranjuje vsaj en ključ in je višina 
$B$-drevesa z $\ell$ listi $O(\log_B\ell)$, je višina od
$B$-drevesa, ki shranjuje #n# ključev $O(\log_B #n#)$. Zato je v zunanjem 
pomnilniškem modelu čas, ki ga porabi operacija #find(x)#
$O(\log_B #n#)$. Da določimo čas delovanja v RAM modelu,
moramo računati čas klicanja operacije #findIt(a,x)# za vsako vozlišče,
ki ga obiščemo. Čas delovanja operacije #find(x)# v modelu besedni RAM je
\[
   O(\log_B #n#)\times O(\log B) = O(\log #n#) \enspace .
\]

\subsection{Dodajanje}
\translatedby{Gašper Ferdin}{sl}

Ena glavnih razlik med podatkovnima strukturama $B$-dreves in dvojiških
iskalnih dreves (\secref{binarysearchtree}) je, da vozlišča
$B$-dreves ne hranijo kazalcev na njihove starše.  Vzrok tega bomo
razložili malce kasneje.  Ker kazalci na starše ne obstajajo, pomeni,
da je operaciji #add(x)# in #remove(x)# v $B$-drevesih najlažje
implementirani s pomočjo rekurzije.

Kot za vsa uravnotežena iskalna drevesa je tudi tu potrebno uravnoteženje drevesa, 
če se pri izvajanju operacije #add(x)# drevo izrodi. Pri $B$-drevesih za to 
skrbi \emph{razdeljevanje} vozlišč.
\index{razdeljevanje}%
Za nadaljevanje glejte \figref{btree-split}.
Čeprav razdeljevanje deluje na dveh plasteh drevesa, je najbolj razumljivo, kot
operacija, ki vzame vozlišče #u#, ki vsebuje $2B$ ključev in ima $2B+1$ otrok.
Ustvari novo vozlišče #w#, ki podeduje $#u.children#[B],\ldots,#u.children#[2B]$.
Novo vozlišče #w# prav tako vzame največje ključe $B$, $#u.keys#[B],\ldots,#u.keys#[2B-1]$
od vozlišča #u#.  Na tej točki ima #u# $B$ otrok in $B$ ključev. Dodaten ključ, $#u.keys#[B-1]$,
se posreduje staršem vozlišča #u#, posreduje pa se tudi vozlišče #w#.

Opazimo, da operacija razdeljevanja spreminja tri vozlišča: #u#, starše
vozlišča #u# in novo vozlišče #w#.  Sedaj smo prišli do odgovora, zakaj
vozlišča $B$-dreves ne ohranjajo kazalcev na starše. Če bi jih, bi morali
vsem $B+1$ otrokom, ki so podedovani vozlišču #w# popraviti kazalce na
njihove starše. Število dostopov do zunanjega pomnilnika bi se povečalo
s 3 na $B+4$ dostope. To bi poslabšalo učinkovitost $B$-drevesa pri 
večjih številih $B$.

\begin{figure}
   \centering{\begin{tabular}{@{}l@{}}
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-split-1} \\[2ex]
     \multicolumn{1}{c}{#u.split()#} \\ 
     \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-split-2} \\
   \end{tabular}}
   \caption[Razdeljevanje vozlišča v $B$-drevesu]{Razdeljvanje vozlišča #u# v
     $B$-drevesu ($B=3$). Opazimo, da se ključ $#u.keys#[2]=\mathrm{m}$
     posreduje iz #u# njegovim staršem.}
   \figlabel{btree-split}
\end{figure}

Metoda #add(x)# v $B$-drevesih je prikazana v \figref{btree-add}.
V višji plasti metoda poišče list, #u#, v katerega bo dodala vrednost
#x#. Če dodajanje pozroči, da #u# postane prepoln (ker že vsebuje $B-1$ ključev),
se #u# razdeli. Lahko se zgodi, da postanejo tudi starši prepolni. V tem
primeru se razdelijo tudi starši. To lahko spet povzroči deljenje prastaršev
vozilišča #u# in tako naprej. To se vzpenja po drevesu toliko časa, dokler
ne doseže vozlišča, ki ni prepoln ali dokler se koren drevesa ne razdeli.
V prvem primeru se postopek ustavi. V drugem primeru, se ustvari novo
vozlišče, katerega otroci postanejo pridobljena vozlišča pri razdelitvi
prvotnega korena.

\begin{figure}
   \centering{\begin{tabular}{@{}l@{}}
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-add-1} \\[2ex]
     \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-add-2} \\[2ex]
     \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-add-3} 
   \end{tabular}}
   \caption[Dodajanje v $B$-drevo]{Operacija #add(x)# v $B$-drevesu.
   	  Dodajanje vrednosti 21, dva vozlišča se razdelita}
   \figlabel{btree-add}
\end{figure}

Povzetek metode #add(x)# je, da se sprehaja od korena do iskanega(#x#) lista,
doda #x# v ta list, se začne pomikati nazaj proti korenu, razdeli vsa
prepolna vozlišča na katere naleti na poti navzgor. S tem preletom v mislih,
se lahko sedaj spustimo v detajle, kako naj bo ta rekurzivna metoda implementirana.

Večino dela #add(x)# je narejenega z metodo #addRecursive(x,ui)#, katera
doda vrednost #x# v poddrevo, katerega koren #u#, ima identifikator #ui#.
Če je #u# list, se #x# enostavno vsavi v #u.keys#, sicer se doda rekurzivno
v poddrevo ustreznega sina $#u#'$ od #u#. Rezultat tega rekurzivnega klica
je ponavadi #null#, ampak lahko je tudi referenca na novo kreirano vozlišče
#w#, kateri je nastal zaradi razdelitve $#u#'$. V tem primeru #u# podeduje
#w# in vzame njegovo prvo vrednost, ter dokonča razdelitev na $#u#'$.

Ko je bila vrednost #x# dodana (ali v #u# ali v potomce #u#), metoda
#addRecursive(x,ui)# preveri, če #u# hrani preveč (več kot $2B-1$) ključev.
V primeru ko jih hrani preveč, se mora #u# \emph{razdeliti} z klicom metode
#u.split()#. Rezultat klica #u.split()# je novo vozlišče, ki je uporabljeno kot
rezultat metode #addRecursive(x,ui)#.
\codeimport{ods/BTree.addRecursive(x,ui)}

Metoda #addRecursive(x,ui)# je pomožna metoda metode #add(x)#, katera kliče
#addRecursive(x,ri)#, da vstavi #x# v koren $B$-drevesa. Če #addRecursive(x,ri)#
povzroči, da se koren razdeli, se ustvari nov koren in si za svoje otroke vzame 
otroke starega korena in otroke novega vozlišča, pridobljenega pri razdelitvi
starega korena.
\codeimport{ods/BTree.add(x)}

Metodo #add(x)# in pomožno metodo #addRecursive(x,ui)# lahko analiziramo v
dveh fazah:

\begin{description}
  \item[faza ugrezanja:]
    Med fazo ugrezanja rekurzije, preden je #x# dodan, imamo dostop do
    zaporedja vozlišč $B$-dreves in nad vsakim vozliščem kličemo metodo 
    #findIt(a,x)#. Kot pri metodi #find(x)# to potrebuje $O(\log_B #n#)$
    časa v zunanjem spominskem modelu in $O(\log #n#)$ časa v modelu RAM.
  
  \item[faza vzpenjanja:]
   Med fazo vzpenjanja rekurzije, po tem ko je #x# dodan, lahko to izvede
   največ $O(\log_B #n#)$ delitev. Vsaka razdelitev vsebuje tri vozlišča,
   tako,da ta faza porabi $O(\log_B #n#)$ časa v zunanjem spominskem modelu.
   Vendar vsaka razdelitev zahteva premikanje $B$ ključev in otrok iz enega
   vozlišča na drugega, tako da porabi $O(B\log #n#)$ časa v modelu RAM. 
\end{description}

Spomnimo, da je lahko vrednost $B$ precej velika, veliko večja
kot $\log #n#$. Zato je v modelu RAM, dodajanje vrednosti v $B$-drevo lahko
veliko počaseje kot dodajanje v uravnovešeno binarno iskalno drevo. Kasneje v
\secref{btree-amortized}, bomo pokazali, da situacija ni tako zelo slaba;
amortizacijska številka operacij razdelitve med izvajanjem operacije #add(x)#
je konstantna. To kaže na to, da (amortiziran) izvajalni čas operacije #add(x)#
v modelu RAM $O(B+\log #n#)$.


\subsection{Odstranjevanje}
\translatedby{Kosta Nedeljković}{sl}

Operacija #remove(x)# v #BTree# je prav tako najlažje implementirana kot rekurzivna metoda.  Čeprav rekurziven način implementacije metode
#remove(x)# razširi kompleksnost čez več metod, je celoten proces, kot je prikazan v \figref{btree-remove-full}, dokaj
preprost. S prestavljanjem ključev okrog problem skrčimo na odstranitev vrednosti, $#x#'$, iz določenega lista, #u#.  Odstranitev $#x#'$
lahko pusti #u# z manj kot $B-1$  ključi;  takšen dogodek se imenuje \emph{spodnja prekoračitev}.
\index{spodnja prekoračitev}%

\begin{figure}
   \centering{\begin{tabular}{@{}l@{}}
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-remove-full-1} \\[2ex]
     \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-remove-full-2} \\[2ex]
     \multicolumn{1}{c}{#merge(v,w)#} \\
     \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-remove-full-3} \\[2ex]
     \multicolumn{1}{c}{#shiftLR(w,v)#} \\
     \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-remove-full-4} \\[2ex]
   \end{tabular}}
   \caption[Odstranitev iz $B$-drevesa]{Odstranitev vrednosti 4 iz $B$-drevesa
     povzroči eno združitev in eno izposojo.}
   \figlabel{btree-remove-full}
\end{figure}

V primeru spodnje prekoračitve, si #u# sposodi ključe od ali je združen z
enim od svojih sorodnikov.  Če pride do združitve #u# s sorodnikom, bo sedaj #u#-jev starš
imel enega otroka in enega ključa manj, kar lahko povzroči spodnjo prekoračitev #u#-jevega starša; to je ponovno popravljeno z izposojo ali združitvijo,
vendar združitev lahko povzroči spodnjo prekoračitev #u#-jevega starega starša.  Ta proces
se ponavlja vse nazaj do korena, dokler ne pride več do prekoračitve ali se korenova zadnja otroka združita v enega samega.
Če se zgodi slednje, je koren odstranjen in njegov preostali otrok postane nov koren.

Sledi podroben ogled načina implementacije posameznega koraka.
Prva naloga metode #remove(x)# je poiskati element #x#, ki ga želimo dstraniti.  Če se #x# nahaja v listu, sledi odstranitev #x# iz tega lista.  V nasprotnem primeru, če je #x# najden v #u.keys[i]# za neko notranje
vozlišče #u#, algoritem odstrani najmanjšo vrednost, #x'#, v poddrevesu s korenom, ki se nahaja na #u.children[i+1]#.  Vrednost #x'# je najmanjša
vrednost shranjena v #BTree#, ki je večja od #x#.  Vrednost #x'#-a nato zamenja vrednost #x# v #u.keys[i]#.  Ta proces je prikazan v \figref{btree-remove}.

\begin{figure}
   \centering{\begin{tabular}{@{}l@{}}
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-remove-1} \\[2ex]
     \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
     \includegraphics[width=\ScaleIfNeeded]{figs/btree-remove-2} 
   \end{tabular}}
   \caption[The remove operation in a $B$-tree] {Operacija #remove(x)#
      v #B-drevesu#. Da odstranimo vrednost $#x#=10$, jo zamenjamo z
 $#x'#=11$ in odstranimo 11 iz lista, ki jo vsebuje.}
   \figlabel{btree-remove}
\end{figure}

Metoda #removeRecursive(x,ui)# je rekurzivna implementacija predhodnega algoritma:
\codeimport{ods/BTree.removeRecursive(x,ui).removeSmallest(ui)}

Po rekurzivnem odstranjevanju vrednosti #x# iz #i#-tega otroka #u#-ja mora
#removeRecursive(x,ui)# zagotoviti, da ima ta otrok še vedno vsaj  $B-1$ ključev.
V predhodni kodi je to zagotovljeno z metodo #checkUnderflow(x,i)#, ki preveri 
podkoračitev v #i#-temu otroku #u#-ja in jo po potrebi popravi.
Naj bo #w# #i#-ti otrok #u#-ja. Če ima #w# samo $B-2$ ključev, ga je treba popraviti, 
za kar pa potrebujemo #w#-jevega brata, ki je lahko #u#-jev otrok z indeksom
 $#i#+1$ ali z indeksom  $#i#-1$. Ponavadi izberemo tistega z indeksom  $#i#-1$, ki
je #w#-jev brat neposredno na njegovi levi. Recimo mu #v#. Edini primer v katerem to
ne deluje je kadar je $#i#=0$. V tem primeru uporabimo brata, ki je neposredno na #w#-jevi
desni. 

\codeimport{ods/BTree.checkUnderflow(u,i)}
Sedaj se osredotočimo na primer, ko je $#i#\neq 0$, tako da bo kakršnakoli podkoračitev pri #i#-temu
otroku vozlišča #u# popravljena s pomočjo njegovega otroka z indeksom $(#i#-1)$. 
Primer, ko je $#i#=0$ je podoben. Podrobnosti so v izvorni kodi.
Da popravimo podkoračitev v vozlišču #w#, moramo temu vozlišču najti več ključev (in po možnosti tudi otrok).
To lahko storimo na dva načina:

\begin{description}
  \item[Izposojanje:]
  \index{borrow}%
  Če ima #w# brata #v# z več kot  $B-1$ ključi, si lahko #w# od #v#-ja izposodi nekaj ključev (in po možnosti tudi otrok).
Natančneje, če ima #v# #size(v)# ključev, imata #v# in #w# skupaj
  \[
     B-2 + #size(w)# \ge 2B-2
  \]
ključev. Torej lahko #v#-jeve ključe prestavimo #w#-ju tako, da imata #v# in #w#
vsaj $B-1$ ključev. Ta proces je prikazan v 
  \figref{btree-borrow}.

  \begin{figure}
      \centering{\begin{tabular}{@{}l@{}}
       \includegraphics[width=\ScaleIfNeeded]{figs/btree-borrow-1} \\[2ex]
       \multicolumn{1}{c}{#shiftRL(v,w)#} \\ 
       \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
       \includegraphics[width=\ScaleIfNeeded]{figs/btree-borrow-2} \\
     \end{tabular}}
    \caption[Borrowing in a $B$-tree]{Če ima #v# več kot  $B-1$ ključev, jih lahko posodi #w#-ju.}
    \figlabel{btree-borrow}
  \end{figure}
  
  \item[Združevanje:]
  \index{merge}%
Če ima #v# samo $B-1$ ključev, moramo narediti nekaj bolj zahtevnega, saj 
#v# ne more posoditi nobenega ključa #w#-ju. Zato vozlišči #w# in #v# \emph{združimo}, 
kot je prikazano v \figref{btree-merge}. 
Združevanje je nasprotna operacija razdelitve. Dve vozlišči, ki imata skupaj $2B-3$ ključev in 
ju združi v eno samo vozlišče v $2B-2$ ključi. Dodaten ključ dobimo zato, ker ima po združevanju
#v#-ja in #w#-ja njun starš #u# enega otroka manj in mora zato oddati en ključ.

  \begin{figure}
     \centering{\begin{tabular}{@{}l@{}}
       \includegraphics[width=\ScaleIfNeeded]{figs/btree-merge-1} \\[2ex]
       \multicolumn{1}{c}{#merge(v,w)#} \\ 
       \multicolumn{1}{c}{$\Downarrow$} \\[2ex]
       \includegraphics[width=\ScaleIfNeeded]{figs/btree-merge-2} \\
     \end{tabular}}
     \caption[Merging in a $B$-tree]{Merging two siblings #v# and #w#
     in a $B$-tree ($B=3$).}
     \figlabel{btree-merge}
  \end{figure}
\end{description}

\codeimport{ods/BTree.checkUnderflowNonZero(u,i).checkUnderflowZero(u,i)}

Da povzamemo, metoda #remove(x)# v $B$-drevesu gre od korenskega vozlišča
do lista, odstrani ključ #x'# iz lista #u# in nato izvede nič ali več operacij združevanja
med #u#-jem in njegovimi predniki in največ eno operacijo izposojanja. Ker pri vsaki operaciji
združevanja in izposojanja spreminjamo največ tri vozlišča, in ker se izvede samo  $O(\log_B #n#)$
takih operacij, to v modelu zunanjega pomnilnika porabi $O(\log_B #n#)$ časa.
Kakorkoli že, vsaka operacija združevanja in izposojanja potrebuje $O(B)$ časa v besednem-RAM modelu, 
zato lahko (za zdaj) za časovno zahtevnost operacije #remove(x)# trdimo, da spada v razred $O(B\log_B #n#)$.

\subsection{Amortizirana analiza $B$-Dreves}
\seclabel{btree-amortized}

Do sedaj smo pokazali, da je
\begin{enumerate}
  \item v modelu zunanjega pomnilnika časovna zahtevnost operacij #find(x)#,
    #add(x)#, in #remove(x)# v $B$-drevesu $O(\log_B #n#)$, in da je
  \item v besednem-RAM modelu časovna zahtevnost operacije #find(x)# $O(\log #n#)$, 
časovna zahtevnost operacij #add(x)# in #remove(x)# pa $O(B\log #n#)$.
\end{enumerate}

Naslednja trditev pokaže, da smo precenili število operacij združevanja in razdelitev v $B$-drevesih.

\begin{lem}\lemlabel{btree-split}
Če imamo prazno $B$-drevo in izvedemo $m$ #add(x)# in #remove(x)# operacij, se izvede
največ  $3m/2$ razdelitev, združevanj in izposojanj.
\end{lem}

\begin{proof}
Dokaz za to je že bil nakazan v
   \secref{redblack-summary} za poseben primer, ko je $B=2$.
   Trditev lahko dokažemo z\index{metodo bankirja}%, v kateri
  \begin{enumerate}
    \item vsaka razdelitev, združevanje ali izposoja se plača z dvema kovancema 
	(plača se vsakič ko se izvede ena izmed teh operacij); in
    \item največ trije kovanci so na razpolago med katerokoli #add(x)# ali
      #remove(x)# operacijo.
  \end{enumerate}

Ker je na razpolago največ $m$ kovancev in vsaka  razdelitev, združevanje in izposoja
stane dva kovanca, sledi, da se izvede največ $3m/2$ razdelitev, združevanj in izposoj.
Kovanci so prikazani z simbolom \cent\ v Slikah~\ref{fig:btree-split}, \ref{fig:btree-borrow}, in
  \ref{fig:btree-merge}.

Da lahko vodimo evidenco o kovancih, dokaz uporablja naslednjo
  \emph{invarianco kovancev}:
  \index{credit invariant}%

Vsako nekorensko vozlišče z $B-1$ ključi shrani tri kovance. Vozlišču, ki ima
najmanj $B$ in največ $2B-2$ ključev ni potrebno hraniti kovancev.
Sedaj moramo samo še pokazati, da lahko ohranjamo invarianco kovancev in se hkrati 
držimo trditev 1 in 2 (zgoraj) pri vsaki #add(x)# in #remove(x)# operaciji.

  \paragraph{Dodajanja:}
Metoda #add(x)# ne uporabi nobenih združevanj ali izposojanj, zato lahko pri klicih te metode upoštevamo samo
operacije razdelitve.

Vsaka operacija razdelitve ima za vzrok dodajanje ključa vozlišču #u#, ki že ima $2B-1$ ključev.
Ko pride do tega, se #u# razdeli na dve vozlišči - vozlišče #u'# z $B-1$ ključi in vozlišče #u''# z $B$ ključi.
Pred to operacijo je imelo vozlišče #u# $2B-1$ ključev in zato tri kovance. Dva kovanca porabimo za operacijo 
razdelitve in preostali kovanec prenesemo na #u'# (ki ima $B-1$ ključev) da ohranimo invarianco kovancev. Tako 
lahko plačamo za razdelitev in hkrati ohranjamo invarianco konvancev med vsakio operacijo razdelitve.

Edina druga sprememba v vozliščih pri operaciji #add(x)# se zgodi šele po vseh
opravljenih razdelitvah, če sploh do njih pride. Ta sprememba vključuje dodajanje 
novega ključa vozlišču #u'#. Če je imelo pred tem vozlišče #u'# $2B-2$ otrok, jih ima sedaj $2B-1$ in zato
prejme tri kovance. Ti kovanci so edini, ki jih dodeli metoda #add(x)#.

  \paragraph{Odstranjevanje:}
Med operacijo #remove(x)# pride do nič ali več operacij združevanja, katerim lahko sledi ena 
opercija izposoje. Do združevanja pride ko sta vozliči #v# in #w# (vsako z po $B-1$ ključi pred klicem medode #remove(x)#)
združeni v eno vozlišče z $2B-2$ ključi. Vsako takšno združevanje sprosti dva kovanca, s katerima lahko plačamo
združevanje.

Po vseh opravljenih operacijah združevanja lahko pride do največ ene operacije izposoje (po tej operaciji
ne pride več do združevanj ali izposojanj). Do te operacije izposoje pride samo v primeru, da iz lista #v#, ki ima $B-1$
ključev, odstranimo ključ. Vozlišče #v# ima tako en kovanec, ki se porabi za to operacijo izposoje. Ker pa en kovanec ni
dovolj, moramo ustvariti še enega.

Ustvarili smo en kovanec in moramo sedaj pokazati, da lahko ohranjamo invarianco kovancev.
V najslabšem primeru ima #v#-jev brat #w# natanko $B$ ključev pred izposojo, tako da imata 
oba (#v# in #w#) po izposoji $B-1$ ključev. To pomeni da bi morala vsak imeti po en kovanec po končani operaciji.
V tem primeru tako ustvarimo dodatna dva kovanca za vozlišči #v# in #w#. Ker se operacija izposoje zgodi največ enkrat 
na klic metode #remove(x)# to pomeni, da ustvarimo skupaj največ tri kovance, kar ne krši pravil.

Če v metodi #remove(x)# ne pride do operacije izposoje je to zato, ker se konča z odstranjevanjem
ključa iz vozlišča, ki je imelo pred operacijo $B$ ali več ključev. V najslabšem primeru je imelo to vozliče
natanko $B$ ključev, zato jih ima po operaciji $B-1$ in potrebuje en kovanec, ki ga ustvarimo.

V vsakem primeru - če se odstranjevanje konča z operacijo izposoje ali ne - je potrebno ustvariti
največ tri kovance pri klicu metode #remove(x)#, da se ohranja incarianco kovancev. Dokaz je s tem zaključen.
\end{proof}

Namen dokaza \lemref{btree-split} je pokazati, da je pri besednem-RAM modelu časovna zahtevnost operacij
razdelitev, združevanje in povezovanje pri $m$ #add(x)# in #remove(x)# operacijah le $O(Bm)$.
To pomeni, da je amortizirana časovna zahtevnost na operacijo samo $O(B)$, torej je amortizirana časovna zahtevnost
metod #add(x)# in #remove(x)# v besednem-RAM modelu $O(B+\log #n#)$.
To je povzeto v naslednjih trditvah:

\begin{thm}[$B$-Drevesa v zunanjem pomnilniku]
   Razred #BTree# implementira vmesnik #SSet#. V modelu zunanjega pomnilnika podpira razred #BTree# operacije
   #add(x)#, #remove(x)# in #find(x)#, katerih časovna zahtevnost je $O(\log_B #n#)$.
\end{thm}

\begin{thm}[Besedni RAM $B$-Drevesa]
  Razred #BTree# implementira vmesnik #SSet#. V besednem-RAM modelu podpira razred #BTree# operacije
   #add(x)#, #remove(x)# in #find(x)#, katerih časovna zahtevnost je $O(\log #n#)$, pri čemer zanemarimo 
   ceno razdelitev, združevanj in izposojanj. 
   Če začnemo z praznim #BTree# in opravimo $m$ #add(x)# in #remove(x)# operacij je časovna zahtevnost 
   razdelitev, združevanj in izposojanj $O(Bm)$.
\end{thm}

\section{Razprave in vaje}

Model računanja v zunanjem pomnilniku sta predstavila Aggarwall in 
Vitter \cite{av88}.Včasih se imenuje tudi \emph{V/I model} (ang. \textit{I/O model})
\index{I/O model}%
ali pa \emph{diskovno dostopni model} (ang. \textit{DAM}). 
\index{disk access model}%


$B$-drevesa so pri iskanju v zunanjem pomnilniku to, kar so dvojiška iskalna drevesa
 pri iskanju v notranjem pomnilniku.  $B$-drevesa sta uvedla Bayer
in McCreight \cite{bm70} leta 1970 in manj kot deset let kasneje jih naslov članka
v ACM computing surveys obravnava kot vseprisotne \cite{c79}.
Tako kot binarnih iskalnih dreves, obstaja veliko različic $B$-dreves, vključno
$B^+$-drevesa,
\index{B+-tree@$B^+$-tree}%
$B^*$-drevesa,
\index{B*-tree@$B^*$-tree}%
in štetje $B$-dreves.
\index{conted $B$-tree}%
$B$-drevesa so resnično vseprisotna in so primarna podatkovna struktura v mnogih datotečnih sistemih,
vključno z Apple-ov HFS+,
\index{HFS+}%
Microsoftov NTFS, 
\index{NTFS}%
in Linuxov Ext4;
\index{Ext4}%
vsak večji sistem podatkovnih baz; in shrambah \textit{key-value}, ki se uporablja v računalništvu v oblaku.
Nedavna raziskava Graefe-a \cite{g10} zagotavlja pregled 200+ strani,  mnogih sodobnih aplikacij, variant in optimizacij $B$-dreves.

$B$-drevesa implementirajo vmesnik #SSet#. Kadar je potreben le vmesnik #USet#, 
se lahko uporablja hashing zunanjega pomnilnika
\index{external memory hashing}% kot alternativo $B$-dreves.  
Obstajajo programi za hashing zunanjega pomnilnika; za primer glej,
Jensen in Pagh~\cite{jp08}.  V teh primerih implementirajo  #USet# operacije v 
pričakovanem času $O(1)$ v modelu zunanjega pomnilnika. Vendar pa
 zaradi različnih razlogov veliko vlog še vedno uporabljajo  $B$-drevesa, 
čeprav so zahtevali le operacije #USet#.

Eden od razlogov, da so $B$-drevesa tako priljubljena izbira je, da so pogosto uspešnejši 
od njihove $O(\log_B #n#)$ predlagane meje časa delovanja. 
Razlog za to je, ker je vrednost $B$ v nastavitvah zunanjega pomnilnika običajno precej velik - na stotine ali celo tisoče.
To pomeni, da je 99\% ali celo 99.9\% podatkov $B$-drevesa shranjenih v listih.
V sistemu baze podatkov z velikim pomnilnikom, je mogoče shraniti vsa notranja vozlišča  $B$-drevesa v RAM, 
saj predstavljajo le 1\% ali 0.1 celotnega nabora podatkov. Ko se to zgodi, to pomeni, da je iskanje v $B$-drevesu
vključuje zelo hitro iskanje v RAM-u, preko notranjih vozlišč, ki mu sledi enojni dostop do 
zunanjega pomnilnika za nalaganje listov..

\begin{exc}
  Pokaži kaj se zgodi z ključema 1.5 ter nato z 7.5, ko ju vstavimo v 
  $B$-drevo, \figref{btree}.
\end{exc}

\begin{exc}
  Pokaži kaj se zgodi z ključema 3 in 4, ko ju odstranimo iz
  $B$-drevesa v \figref{btree}.
\end{exc}

\begin{exc}
   Kakšno je največje število notranjih vozlišč v $B$-drevesu, ki hrani
   #n# ključev (kot funkcija #n# in $B$)?
\end{exc}

\begin{exc}
  V uvodu trdimo, da $B$-drevesa potrebujejo notranji pomnilnik velikosti
  $O(B+\log_B#n#)$. Vendar implementacija podana tukaj ima večjo pomnilniško
  zahtevnost.
  \begin{enumerate}
    \item Pokaži, da implementacija za #add(x)# in #remove(x)# metodi
    podani v tem poglavju uporabljata notranji pomnilnik preporcionalen $B\log_B #n#$
    \item Opiši kako bi lahko te metode preoblikovali, tako da bi zmanjšali
    njihovo pomnilniško zahtevnost na $O(B + \log_B #n#)$.
  \end{enumerate}
\end{exc}

\begin{exc}
  Nariši kredite uporabljene v dokazu \lemref{btree-split} na drevesih v 
  Figures~\ref{fig:btree-add} in \ref{fig:btree-remove-full}. Potrdi, da
  (z tremi dodatnimi krediti) si je mogoče privoščiti rezcepitev, združitve in
  sposojanja ter hkrati obdržati kreditno invarianto.
\end{exc}

\begin{exc}
  Naredi spremenjeno verzijo $B$-drevesa, katera ima lahko 
  od $B$ do $3B$ naslednjikov (in zato od $B-1$ do $3B-1$ ključev).
  Dokaži, da ta nova verzija $B$-drevesa izvaja samo $O(m/B)$ razcepitve,
  združitve, in izposojanja v času zaporedja $m$ operacij. (Nasvet:
  Da bo to delovalo, boste morali biti bolj agresivni z združevanjem,
  občasno združiti dve vozlišči preden bo to nujno potrebno.) 
\end{exc}

\begin{exc}
  V tej vaji boste zasnovali spremenjeno metodo za delitev in združevanje v 
  $B$-drevesih, ki asimptotično zmanjša število delitev, izposojanj in 
  združevanj z upoštevanjem treh vozlišč naenkrat.
  \begin{enumerate}
    \item Naj bo #u# prepolno vozlišče in naj bo #v# brat takoj desno od #u#.
    Obstajata dva načina, da popravimo prekoračitev pri #u#:
    \begin{enumerate}
       \item #u# lahko preseli nekaj svojih ključev na #v#; ali
       \item #u# se lahko razdeli in ključi #u# in #v# se lahko enakomerno razdelijo 
       med #u#, #v# in novo nastalo vozlišče #w#.
    \end{enumerate}
    Pokažite, da se to vedno lahko naredi na način, da imajo po operaciji vsa 
    udeležena vozlišča ( največ 3) vsaj  $B+\alpha B$ ključev in kvečemu $2B-\alpha B$ 
    ključev, za neko konstantno  $\alpha > 0$.
    \item Naj bo #u# vozlišče s premalo ključi in naj bosta #v# ter #w# brata vozlišča #u#.
    Obstajata dva načina kako popraviti praveliko praznost pri #u#:
    \begin{enumerate}
       \item ključi se lahko enakomerno razdelijo med #u#, #v# in #w#; ali
       \item #u#, #v#, #w# združimo v dve vozlišči ter razdelimo ključe vozlišč #u#, #v#, in #w#
       med novonastali vozlišči
    \end{enumerate}
    Pokažite, da se, da to vedno narediti na način, tako, da imajo po operaciji vsa udeležena
    vozlišča (največ 3) vsaj $B+\alpha B$ ključev in kvečjemu $2B-\alpha B$ ključev, za 
    neko konstanto $\alpha > 0$.
    \item Pokažite, da je s temi spremembami, število združevanj, izposojanj in delitev, 
    ki se zgodijo nad $m$ operacijami enako $O(m/B)$.
  \end{enumerate}
\end{exc}


\begin{exc}
  $B^+$-drevo, ilustrirano na \figref{bplustree} hrani vsak ključ v listih, vsak list 
  pa je shranjen kot dvojno povezani seznam. Kot ponavadi, vsak list hrani med $B-1$ in 
  $2B-1$ ključi. Nad listi je običajno $B$-drevo, ki hrani največjo vrednost vsakega lista razen zadnjega.
  \begin{enumerate}
    \item Opišite hitre implementacije metod #add(x)#, #remove(x)# in #find(x)# v $B^+$-drevesu.
    \item Razložite kako učinkovito implementirati metodo #findRange(x,y)# , ki vrne vse vrednosti
    večje od #x# in manjše ali enake #y# v $B^+$-drevesu.
    \item Implementirajte razred, #BPlusTree#, ki implementira #find(x)#,
          #add(x)#, #remove(x)#, in #findRange(x,y)#.
      \index{BPlusTree@#BPlusTree#}%
    \item  $B^+$-drevo podvoji nekatere ključe, saj so shranjeni hkrati v $B$-drevesu ter v listu. 
    Razložite zakaj se to podvajanje ne pozna toliko na velikih vrednostih od $B$.
  \end{enumerate}
\end{exc}

\begin{figure}
  \centering{\includegraphics[width=\ScaleIfNeeded]{figs/bplustree}} 
  \caption{$B^+$-drevo je $B$-drevo na vrhu dvojno povezanega seznama blokov.}
  \figlabel{bplustree}
\end{figure}
